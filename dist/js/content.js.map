{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/ts/content.ts","webpack:///./src/ts/modules/API.ts","webpack:///./src/ts/modules/BlackandWhiteImage.ts","webpack:///./src/ts/modules/BookmarkAllWorks.ts","webpack:///./src/ts/modules/BookmarksAddTag.ts","webpack:///./src/ts/modules/CenterPanel.ts","webpack:///./src/ts/modules/Colors.ts","webpack:///./src/ts/modules/Config.ts","webpack:///./src/ts/modules/ConvertUgoira.ts","webpack:///./src/ts/modules/DOM.ts","webpack:///./src/ts/modules/Deduplication.ts","webpack:///./src/ts/modules/DeleteWorks.ts","webpack:///./src/ts/modules/Download.ts","webpack:///./src/ts/modules/DownloadControl.ts","webpack:///./src/ts/modules/DownloadStates.ts","webpack:///./src/ts/modules/EVT.ts","webpack:///./src/ts/modules/FastScreen.ts","webpack:///./src/ts/modules/FileName.ts","webpack:///./src/ts/modules/Filter.ts","webpack:///./src/ts/modules/FormHTML.ts","webpack:///./src/ts/modules/ImageToIcon.ts","webpack:///./src/ts/modules/ImgViewer.ts","webpack:///./src/ts/modules/IndexedDB.ts","webpack:///./src/ts/modules/InitBookmarkLegacyPage.ts","webpack:///./src/ts/modules/InitBookmarkPage.ts","webpack:///./src/ts/modules/InitFollowingPage.ts","webpack:///./src/ts/modules/InitIndexPage.ts","webpack:///./src/ts/modules/InitPage.ts","webpack:///./src/ts/modules/InitPageBase.ts","webpack:///./src/ts/modules/InitPixivisionPage.ts","webpack:///./src/ts/modules/InitUserPage.ts","webpack:///./src/ts/modules/Lang.ts","webpack:///./src/ts/modules/Log.ts","webpack:///./src/ts/modules/Options.ts","webpack:///./src/ts/modules/Output.ts","webpack:///./src/ts/modules/PageInfo.ts","webpack:///./src/ts/modules/PageType.ts","webpack:///./src/ts/modules/ProgressBar.ts","webpack:///./src/ts/modules/QuickBookmark.ts","webpack:///./src/ts/modules/Resume.ts","webpack:///./src/ts/modules/RightIcon.ts","webpack:///./src/ts/modules/SaveAvatarIcon.ts","webpack:///./src/ts/modules/SaveSettings.ts","webpack:///./src/ts/modules/Settings.ts","webpack:///./src/ts/modules/Store.ts","webpack:///./src/ts/modules/Support.ts","webpack:///./src/ts/modules/ThemeColor.ts","webpack:///./src/ts/modules/Tip.ts","webpack:///./src/ts/modules/TitleBar.ts","webpack:///./src/ts/modules/artwork/InitAreaRankingPage.ts","webpack:///./src/ts/modules/artwork/InitArtworkPage.ts","webpack:///./src/ts/modules/artwork/InitBookmarkDetailPage.ts","webpack:///./src/ts/modules/artwork/InitBookmarkNewArtworkPage.ts","webpack:///./src/ts/modules/artwork/InitDiscoverPage.ts","webpack:///./src/ts/modules/artwork/InitNewArtworkPage.ts","webpack:///./src/ts/modules/artwork/InitRankingArtworkPage.ts","webpack:///./src/ts/modules/artwork/InitSearchArtworkPage.ts","webpack:///./src/ts/modules/artwork/InitSeriesPage.ts","webpack:///./src/ts/modules/artwork/SaveArtworkData.ts","webpack:///./src/ts/modules/langText.ts","webpack:///./src/ts/modules/novel/InitBookmarkNewNovelPage.ts","webpack:///./src/ts/modules/novel/InitNewNovelPage.ts","webpack:///./src/ts/modules/novel/InitNovelPage.ts","webpack:///./src/ts/modules/novel/InitNovelSeriesPage.ts","webpack:///./src/ts/modules/novel/InitRankingNovelPage.ts","webpack:///./src/ts/modules/novel/InitSearchNovelPage.ts","webpack:///./src/ts/modules/novel/MakeEPUB.ts","webpack:///./src/ts/modules/novel/MakeNovelFile.ts","webpack:///./src/ts/modules/novel/SaveNovelData.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,2BAA2B;AAC3B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;AACG;AACH;AACO;AACN;AACN;AACG;AACC;;;;;;;;;;;;;AClB3B;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,uDAAuD,GAAG,GAAG,KAAK,iBAAiB,IAAI,UAAU,OAAO,kBAAkB,uBAAuB,OAAO,cAAc;AACtK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK;AACxD;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,uDAAuD,GAAG,oBAAoB,OAAO,SAAS,MAAM,QAAQ,KAAK,OAAO,IAAI,QAAQ,KAAK;AACzI;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,GAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,GAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,GAAG,GAAG,KAAK,WAAW,IAAI,UAAU,OAAO,SAAS,MAAM;AACjH;AACA;AACA;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA;AACA;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA;AACA;AACA;AACA,wDAAwD,GAAG;AAC3D;AACA;AACA;AACA;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA;AACA;AACA;AACA;AACA,4DAA4D,YAAY,KAAK,SAAS;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,GAAG,uBAAuB,OAAO;AACxG;AACA;AACA;AACA,oEAAoE;AACpE;AACA,uDAAuD,KAAK,GAAG,yBAAyB,QAAQ,yBAAyB,KAAK,EAAE;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,8DAA8D,yBAAyB,QAAQ,yBAAyB,KAAK,EAAE;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,cAAc,SAAS,aAAa,QAAQ,YAAY,OAAO,WAAW;AAC5I;AACA;AACA;AACA;AACA,iEAAiE,cAAc,SAAS,aAAa,OAAO,WAAW;AACvH;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK,SAAS,EAAE;AAC3D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA,uEAAuE,UAAU,SAAS,MAAM,cAAc,WAAW,YAAY,SAAS;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;;;;;;;;;;;;;ACzaf;AAAA;AAAA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,IAAI;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,IAAI;AAClE,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,4CAA4C;AAC5C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AAC8B;;;;;;;;;;;;;AC5F9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACM;AACJ;AACI;AAClC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB,wCAAG;AACxB,oBAAoB,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AAC9D;AACA;AACA;AACA;AACA;AACA,kBAAkB,0CAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wCAAG;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW,KAAK,mBAAmB;AAC9E;AACA;AACA;AACA;AACA;AACA,6BAA6B,wCAAG;AAChC;AACA;AACA,6BAA6B,wCAAG;AAChC;AACA,+CAA+C;AAC/C,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW,KAAK,mBAAmB;AAClF;AACA;AACA,YAAY,8CAAI;AAChB;AACA;AACA,cAAc,wCAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;;;;;;;;;;;;;ACjH5B;AAAA;AAAA;AAAA;AAA4B;AACA;AAC5B;AACA;AACA;AACA,8BAA8B;AAC9B,6BAA6B;AAC7B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,YAAY,wCAAG,iBAAiB,wCAAG;AACnC,YAAY,wCAAG,iBAAiB,wCAAG;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wCAAG;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wCAAG;AACjB;AACA;AACA,sCAAsC,MAAM,KAAK,eAAe;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2B;;;;;;;;;;;;;ACrF3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8B;AACF;AACA;AACI;AACU;AAC1C;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,0CAAI,mBAAmB;AACtF;AACA;AACA,wDAAwD,0CAAI,mBAAmB;AAC/E;AACA;AACA,iEAAiE,0CAAI,iBAAiB;AACtF;AACA;AACA,6EAA6E,0CAAI,sBAAsB;AACvG;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wDAAwD,0CAAI,iBAAiB;AAC7E,6GAA6G,0CAAI,iBAAiB;AAClI,+BAA+B,0CAAI,iBAAiB;AACpD,yGAAyG,0CAAI,6BAA6B;AAC1I;AACA;AACA;AACA;AACA,gCAAgC,0CAAI,iBAAiB;AACrD;;AAEA;AACA;AACA;AACA;AACA,QAAQ,sDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC,iBAAiB,4CAAK,0BAA0B,4CAAK;AACrD;AACA;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6CAA6C,wCAAG;AAChD;AACA;AACA,0CAA0C,0CAAI;AAC9C;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACuB;;;;;;;;;;;;;AC3IvB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACkB;;;;;;;;;;;;;ACPlB;AAAA;AACe;AACf;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACJF;AAAA;AAAA;AAAA;AAC4B;AAC5B;AACA;AACA;AACA,gCAAgC;AAChC,uBAAuB;AACvB,0BAA0B;AAC1B;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,SAAS,wCAAG,uBAAuB,wCAAG;AACtC;AACA;AACA,aAAa;AACb,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACqB;;;;;;;;;;;;;ACpNrB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,KAAK;AACnE;AACA,6CAA6C,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;;;;;;;;;;;;;ACtJf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACE;AACI;AACM;AACR;AACM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,6BAA6B;AAC7B,gCAAgC;AAChC,uBAAuB,oDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gBAAgB;AAC9E,mDAAmD,eAAe;AAClE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB,8CAAI;AACvB;AACA,6BAA6B,4CAAK;AAClC;AACA,uBAAuB,kDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,SAAS,wCAAG,qBAAqB,wCAAG;AACpC;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B,aAAa;AACb;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0CAAI;AACzB;AACA;AACA;AACyB;;;;;;;;;;;;;ACxJzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4B;AACE;AACI;AACN;AACgB;AACZ;AACJ;AAC5B;AACA;AACA,gCAAgC;AAChC,mCAAmC;AACnC,iCAAiC;AACjC,6BAA6B;AAC7B,yCAAyC,GAAG;AAC5C;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,eAAe,4CAAK;AACpB;AACA;AACA,oDAAoD,EAAE;AACtD;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,MAAM,0CAAI;AAChD,sBAAsB,0CAAI;AAC1B;AACA;AACA,6BAA6B,0CAAI;AACjC;AACA,YAAY,wDAAW;AACvB;AACA;AACA,SAAS;AACT;AACA;AACA,kDAAkD,EAAE;AACpD;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,MAAM,0CAAI;AAChD,sBAAsB,0CAAI;AAC1B;AACA;AACA,6BAA6B,0CAAI;AACjC;AACA,YAAY,wDAAW;AACvB;AACA;AACA,SAAS;AACT;AACA;AACA,2CAA2C,EAAE;AAC7C;AACA,uBAAuB,wCAAG,qBAAqB,8CAAM,MAAM,0CAAI,+BAA+B,0CAAI;AAClG;AACA;AACA;AACA;AACA,qCAAqC,0CAAI;AACzC;AACA,oBAAoB,wDAAW;AAC/B,iBAAiB;AACjB;AACA;AACA,qCAAqC,0CAAI;AACzC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0CAAI;AACzC;AACA;AACA,oBAAoB,wCAAG;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,wCAAG,SAAS,0CAAI,iBAAiB,wCAAG;AAC5C;AACA;AACuB;;;;;;;;;;;;;ACrHvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4B;AACA;AACE;AACQ;AACA;AACM;AACA;AACV;AACc;AAChD;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,wCAAG,sBAAsB,wCAAG;AACrC;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,QAAQ,wDAAW;AACnB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB,QAAQ,wCAAG;AACX;AACA;AACA;AACA,QAAQ,kDAAQ;AAChB;AACA,gCAAgC,4DAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE,0CAAI;AACnB;AACA;AACA,wBAAwB,kDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8CAAM,QAAQ,oBAAoB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,0CAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,0BAA0B,0CAAI;AAC9B;AACA;AACA;AACA,0BAA0B,0CAAI;AAC9B;AACA,gBAAgB,wCAAG;AACnB;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wDAAS;AAClD;AACA;AACA;AACA,yCAAyC,wDAAS;AAClD;AACA;AACA;AACA,4EAA4E,eAAe;AAC3F,wBAAwB,wCAAG;AAC3B;AACA,wBAAwB,wCAAG,MAAM,wCAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,8CAAM;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,0CAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;;;;;;;;;;;;;ACxMpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4B;AACA;AACI;AACJ;AACE;AACQ;AACJ;AACA;AACI;AACM;AACM;AAChB;AAClC;AACA;AACA,mCAAmC;AACnC,qDAAqD;AACrD,2BAA2B;AAC3B,2BAA2B;AAC3B,8BAA8B;AAC9B,4BAA4B;AAC5B;AACA,4BAA4B;AAC5B,0DAA0D;AAC1D;AACA;AACA,0DAA0D;AAC1D,kCAAkC;AAClC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA;AACA,mCAAmC,0CAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,UAAU,YAAY,yBAAyB,QAAQ;AAC1E,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,OAAO,0CAAI;AAC9B;AACA,SAAS;AACT;AACA;AACA,0BAA0B,+DAAc;AACxC;AACA;AACA,QAAQ,wDAAW;AACnB;AACA;AACA,kCAAkC,0CAAI;AACtC;AACA;AACA,gCAAgC,4CAAK;AACrC,YAAY,wCAAG,MAAM,wCAAG;AACxB;AACA,kCAAkC,0CAAI;AACtC,YAAY,wCAAG,SAAS,0CAAI;AAC5B,YAAY,kDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,4CAAK;AAC/D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0CAAI,+DAA+D;;AAE7E;AACA,oEAAoE,8CAAM,OAAO,KAAK,0CAAI,kBAAkB;AAC5G,0EAA0E,KAAK,0CAAI,kBAAkB;AACrG,mEAAmE,8CAAM,MAAM,KAAK,0CAAI,kBAAkB;AAC1G,8DAA8D,8CAAM,QAAQ,KAAK,0CAAI,kBAAkB;AACvG;AACA;AACA;AACA,YAAY,0CAAI,iBAAiB;AACjC,2CAA2C,0CAAI,kBAAkB;AACjE;AACA;AACA;AACA;AACA,mBAAmB,wCAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,4CAAK;AACjB,yBAAyB,0CAAI;AAC7B;AACA;AACA,iBAAiB,4CAAK;AACtB;AACA,SAAS;AACT,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA,mBAAmB,0CAAI;AACvB,SAAS;AACT;AACA;AACA;AACA,mCAAmC,8CAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,YAAY,4CAAK;AACjB,kCAAkC,4CAAK;AACvC;AACA;AACA,QAAQ,wDAAW;AACnB;AACA;AACA;AACA,yCAAyC,4CAAK;AAC9C;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA,6BAA6B,8CAAI;AACjC,8BAA8B,4CAAK;AACnC,YAAY,kDAAQ;AACpB;AACA;AACA,4BAA4B,4CAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4CAAK,qBAAqB,4CAAK;AAC5C;AACA;AACA;AACA,oCAAoC,+CAAM;AAC1C;AACA,YAAY,+DAAc;AAC1B;AACA;AACA;AACA;AACA,YAAY,+DAAc;AAC1B;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA,8BAA8B,0CAAI;AAClC,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4CAAK;AACtB,0CAA0C;AAC1C,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B,gBAAgB,kDAAQ;AACxB,sCAAsC,0CAAI;AAC1C,gBAAgB,wCAAG,SAAS,0CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB,QAAQ,kDAAQ;AAChB,8BAA8B,0CAAI;AAClC,QAAQ,wCAAG,OAAO,0CAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAc;AACtB;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4CAAK;AACnC;AACA;AACA;AACA;AACA;AACA,4DAA4D,4CAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB,KAAK,4CAAK,eAAe;AAC/D;AACA;AACA;AACA;AACA,QAAQ,wCAAG;AACX;AACA;AACA;AACA,sBAAsB,+DAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4CAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAQ;AACxB;AACA;AACA;AACA;;;;;;;;;;;;;ACtYA;AAAA;AAAA;AAAA;AAA4B;AACI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC,6CAA6C,wCAAG;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,4CAAK;AACrC;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;;;;;;;;;;;;;ACnE1B;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;;;;;;;;;;;;;ACrDf;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACU;AACI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,sDAAU;AAClB;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAQ;AACjC;AACA;AACA,gEAAgE,kDAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG;AACX;AACA;AACsB;;;;;;;;;;;;;ACjEtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4B;AACA;AACE;AACI;AACF;AACF;AAC9B;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB,qBAAqB,8CAAI,wBAAwB,GAAG;AACpD,yEAAyE;AACzE;AACA;AACA,cAAc,QAAQ;AACtB,uBAAuB,4CAAK;AAC5B;AACA;AACA,aAAa;AACb,cAAc,MAAM;AACpB,uBAAuB,4CAAK;AAC5B;AACA;AACA,aAAa;AACb,cAAc,GAAG;AACjB;AACA;AACA;AACA,aAAa;AACb,cAAc,OAAO;AACrB;AACA;AACA;AACA,aAAa;AACb,cAAc,MAAM;AACpB;AACA;AACA;AACA,aAAa;AACb,cAAc,KAAK;AACnB;AACA;AACA;AACA,aAAa;AACb,cAAc,MAAM;AACpB;AACA;AACA;AACA,aAAa;AACb,cAAc,KAAK;AACnB;AACA;AACA;AACA,aAAa;AACb,cAAc,OAAO;AACrB;AACA;AACA;AACA,aAAa;AACb,cAAc,QAAQ;AACtB;AACA;AACA;AACA,aAAa;AACb,cAAc,GAAG;AACjB;AACA,0CAA0C,GAAG;AAC7C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb,cAAc,KAAK;AACnB;AACA;AACA;AACA,aAAa;AACb,cAAc,eAAe;AAC7B;AACA;AACA;AACA,aAAa;AACb,cAAc,IAAI;AAClB;AACA;AACA;AACA,aAAa;AACb,cAAc,KAAK;AACnB;AACA;AACA;AACA,aAAa;AACb,cAAc,KAAK;AACnB;AACA;AACA;AACA,aAAa;AACb,cAAc,aAAa;AAC3B;AACA;AACA;AACA,aAAa;AACb,cAAc,aAAa;AAC3B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB,wCAAG;AACpB;AACA;AACA;AACA,iCAAiC,MAAM,kBAAkB,8CAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,MAAM;AACpC;AACA,8BAA8B,GAAG,wBAAwB,OAAO;AAChE;AACA;AACA;AACA;AACA,2BAA2B,wCAAG;AAC9B;AACA;AACA,oBAAoB,8CAAI;AACxB;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA,8DAA8D,IAAI;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB,YAAY,4CAAK;AACjB,YAAY,8CAAI;AAChB;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAI;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAI;AACpB;AACA;AACA;AACA,qBAAqB,8CAAI;AACzB;AACA;AACA,uCAAuC,GAAG;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8CAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB,yBAAyB,0CAAI;AAC7B;AACA;AACA;AACA,uBAAuB,4CAAK;AAC5B,uBAAuB,YAAY;AACnC,yBAAyB,4CAAK;AAC9B;AACA;AACA;AACA,+BAA+B,YAAY,IAAI,SAAS;AACxD,yBAAyB,+CAAM;AAC/B;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA,4DAA4D,IAAI;AAChE;AACA;AACA;AACA,4DAA4D,IAAI;AAChE;AACA;AACA;AACA,iDAAiD,gBAAgB,IAAI,aAAa;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA,mBAAmB,0CAAI;AACvB,SAAS;AACT;AACA;AACA;AACoB;;;;;;;;;;;;;ACtPpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACJ;AACF;AACA;AACA;AAC8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,2CAA2C;AAC3C,2CAA2C;AAC3C,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,mCAAmC;AACnC,0BAA0B;AAC1B,8BAA8B;AAC9B;AACA;AACA,mCAAmC;AACnC,6BAA6B;AAC7B,sCAAsC;AACtC,6BAA6B;AAC7B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8CAAI;AAChC;AACA;AACA;AACA;AACA,2BAA2B,8CAAI;AAC/B;AACA;AACA;AACA;AACA,YAAY,8CAAI;AAChB;AACA;AACA;AACA,6BAA6B,8CAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAI;AACjC;AACA;AACA;AACA;AACA,gCAAgC,8CAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB,QAAQ,wCAAG;AACX;AACA;AACA;AACA;AACA;AACA,yBAAyB,8CAAI;AAC7B,yBAAyB,8CAAI;AAC7B,yBAAyB,8CAAI;AAC7B,yBAAyB,8CAAI;AAC7B;AACA;AACA;AACA;AACA;AACA,4BAA4B,0CAAI;AAChC;AACA;AACA,4CAA4C,0CAAI;AAChD,4CAA4C,0CAAI;AAChD,4CAA4C,0CAAI;AAChD,4CAA4C,0CAAI;AAChD;AACA,YAAY,wCAAG,SAAS,0CAAI;AAC5B;AACA;AACA;AACA,6BAA6B,8CAAI;AACjC,4BAA4B,8CAAI;AAChC;AACA,gDAAgD,0CAAI;AACpD,+CAA+C,0CAAI;AACnD;AACA,YAAY,wCAAG,SAAS,0CAAI;AAC5B;AACA;AACA;AACA;AACA,4BAA4B,8CAAI;AAChC,iCAAiC,8CAAI;AACrC;AACA;AACA,4BAA4B,0CAAI;AAChC;AACA;AACA,+CAA+C,0CAAI;AACnD,oDAAoD,0CAAI;AACxD;AACA,YAAY,wCAAG,SAAS,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAE,sBAAsB,8CAAI;AACnD;AACA,YAAY,wCAAG,SAAS,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAE,sBAAsB,8CAAI;AACnD;AACA,YAAY,wCAAG,SAAS,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG,qBAAqB,8CAAI;AACvD,4BAA4B,wCAAG,qBAAqB,8CAAI;AACxD;AACA;AACA;AACA,uBAAuB,8CAAI;AAC3B;AACA;AACA;AACA,YAAY,wCAAG,SAAS,0CAAI;AAC5B;AACA;AACA,kCAAkC,0CAAI;AACtC,kCAAkC,0CAAI;AACtC,gBAAgB,0CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAG,qBAAqB,8CAAI;AAChD,oBAAoB,wCAAG,qBAAqB,8CAAI;AAChD;AACA;AACA,YAAY,wCAAG,SAAS,0CAAI;AAC5B;AACA;AACA;AACA,YAAY,wCAAG,SAAS,0CAAI;AAC5B;AACA;AACA;AACA;AACA,uBAAuB,8CAAI;AAC3B;AACA,YAAY,wCAAG,SAAS,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAI;AACzB;AACA,YAAY,wCAAG,SAAS,0CAAI,wBAAwB,0CAAI;AACxD;AACA;AACA,YAAY,wCAAG,SAAS,0CAAI,wBAAwB,0CAAI;AACxD;AACA;AACA;AACA,uCAAuC,8CAAI;AAC3C;AACA;AACA,gBAAgB,8CAAI;AACpB,6BAA6B,0CAAI;AACjC;AACA;AACA,gBAAgB,wCAAG,SAAS,0CAAI,oBAAoB,8CAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAI;AACpC;AACA,8BAA8B,8CAAI;AAClC;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA;AACA,gBAAgB,wCAAG;AACnB;AACA;AACA;AACA;AACA,YAAY,wCAAG,iBAAiB,8CAAI,oBAAoB;AACxD;AACA;AACA,YAAY,wCAAG,iBAAiB,8CAAI,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAI;AAChB;AACA;AACA;AACA;AACA,2CAA2C,8CAAI;AAC/C,yCAAyC,8CAAI;AAC7C;AACA;AACA;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B;AACA,gBAAgB,wCAAG;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,YAAY,0CAAI,iBAAiB,IAAI,8CAAI,qBAAqB,KAAK,8CAAI,mBAAmB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8CAAI;AAC3B;AACA,YAAY,wCAAG,SAAS,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA,YAAY,8CAAI;AAChB,iCAAiC,8CAAI;AACrC;AACA,iCAAiC,8CAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG,kBAAkB,IAAI,OAAO,IAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sEAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,8CAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8CAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAAI;AACjB;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC,6CAA6C,wCAAG;AAChD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACkB;;;;;;;;;;;;;ACrmBlB;AAAA;AAA8B;AAC9B;AACA;AACA,yBAAyB,0CAAI,eAAe;AAC5C,yBAAyB,0CAAI,eAAe;AAC5C,yBAAyB,0CAAI,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA,0EAA0E,0CAAI,eAAe,2BAA2B,IAAI,0CAAI,eAAe;AAC/I,oDAAoD;AACpD;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,sBAAsB,IAAI,0CAAI,mBAAmB;AAC/G;AACA;AACA,mCAAmC,0CAAI,eAAe,MAAM;AAC5D;AACA;AACA,mCAAmC,0CAAI,eAAe,MAAM;AAC5D;AACA;AACA,mCAAmC,0CAAI,eAAe,MAAM;AAC5D;AACA;AACA,mCAAmC,0CAAI,eAAe,MAAM;AAC5D;AACA;AACA,0DAA0D,0CAAI,sBAAsB,IAAI,0CAAI,mBAAmB;AAC/G;AACA;AACA,uCAAuC,0CAAI,iBAAiB,MAAM;AAClE;AACA;AACA,sCAAsC,0CAAI,iBAAiB,MAAM;AACjE;AACA;AACA,0DAA0D,0CAAI,sBAAsB,IAAI,0CAAI,mBAAmB;AAC/G;AACA;AACA,sCAAsC,0CAAI,iBAAiB,MAAM;AACjE;AACA;AACA,2CAA2C,0CAAI,iBAAiB,MAAM;AACtE;AACA;AACA,0DAA0D,0CAAI,qBAAqB,IAAI,0CAAI,mBAAmB;AAC9G;AACA;AACA;AACA,QAAQ,0CAAI,oBAAoB;AAChC;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,sBAAsB,IAAI,0CAAI,mBAAmB;AAC/G;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,sBAAsB,IAAI,0CAAI,mBAAmB;AAC/G;AACA;AACA;AACA,cAAc,0CAAI,gBAAgB,MAAM;AACxC;AACA,cAAc,0CAAI,gBAAgB,MAAM;AACxC;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,yBAAyB,GAAG,0CAAI,sBAAsB,IAAI,0CAAI,sBAAsB;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,wBAAwB,IAAI,0CAAI,mBAAmB;AACjH;AACA;AACA;AACA;AACA;AACA,6BAA6B,0CAAI,eAAe,MAAM;AACtD;AACA;AACA,6BAA6B,0CAAI,eAAe,MAAM;AACtD;AACA;AACA,6BAA6B,0CAAI,kBAAkB;AACnD;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,qBAAqB,IAAI,0CAAI,mBAAmB,MAAM,MAAM;AAC1H;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAAI,eAAe,MAAM;AACzD;AACA;AACA,gCAAgC,0CAAI,eAAe,MAAM;AACzD;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,qBAAqB,IAAI,0CAAI,mBAAmB;AAC9G;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,uBAAuB,IAAI,0CAAI,oBAAoB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,uBAAuB,IAAI,0CAAI,oBAAoB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,sBAAsB,IAAI,0CAAI,kBAAkB;AAC9G,8FAA8F,GAAG;AACjG;AACA;AACA;AACA,wBAAwB,GAAG,GAAG,GAAG;AACjC,wBAAwB,KAAK,GAAG,KAAK;AACrC,wBAAwB,QAAQ,GAAG,QAAQ;AAC3C,wBAAwB,MAAM,GAAG,MAAM;AACvC,wBAAwB,QAAQ,GAAG,QAAQ;AAC3C,wBAAwB,KAAK,GAAG,KAAK;AACrC,wBAAwB,eAAe,GAAG,eAAe;AACzD,wBAAwB,MAAM,GAAG,MAAM;AACvC,wBAAwB,KAAK,GAAG,KAAK;AACrC,wBAAwB,IAAI,GAAG,IAAI;AACnC,wBAAwB,KAAK,GAAG,KAAK;AACrC,wBAAwB,KAAK,GAAG,KAAK;AACrC,wBAAwB,GAAG,GAAG,GAAG;AACjC,wBAAwB,aAAa,GAAG,aAAa;AACrD,wBAAwB,aAAa,GAAG,aAAa;AACrD,wBAAwB,OAAO,GAAG,OAAO;AACzC,wBAAwB,MAAM,GAAG,MAAM;AACvC;AACA,YAAY;AACZ;AACA;AACA;AACA,gBAAgB,0CAAI;AACpB;AACA,2BAA2B;AAC3B;AACA,0BAA0B,GAAG;AAC7B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,KAAK;AAC/B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,QAAQ;AAClC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,MAAM;AAChC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,QAAQ;AAClC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,KAAK;AAC/B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,eAAe;AACzC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,MAAM;AAChC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,KAAK;AAC/B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,IAAI;AAC9B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,KAAK;AAC/B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,KAAK;AAC/B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,GAAG;AAC7B,QAAQ,0CAAI;AACZ;AACA,0BAA0B,aAAa;AACvC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,aAAa;AACvC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,OAAO;AACjC,QAAQ,0CAAI;AACZ;AACA,0BAA0B,MAAM;AAChC,QAAQ,0CAAI;AACZ;AACA,QAAQ,0CAAI;AACZ;AACA;AACA,0DAA0D,0CAAI,qBAAqB,IAAI,0CAAI,qBAAqB;AAChH;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,uBAAuB,IAAI,0CAAI,qBAAqB;AAClH;AACA;AACA;AACA;AACA,0DAA0D,0CAAI,qBAAqB,IAAI,0CAAI,mBAAmB;AAC9G;AACA;AACA;AACA,cAAc,0CAAI,kBAAkB;AACpC;AACA;AACA,qDAAqD;AACrD;AACA;AACA,+CAA+C,0CAAI,iBAAiB,MAAM;AAC1E;AACA;;AAEA;AACA,0DAA0D,0CAAI,wBAAwB,IAAI,0CAAI,sBAAsB;AACpH;AACA;AACA;;AAEA;;AAEA;AACA,0DAA0D,0CAAI,0BAA0B;AACxF,QAAQ,0CAAI,mBAAmB;AAC/B;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,iBAAiB,IAAI,0CAAI,mBAAmB;AAC1G;AACA;;AAEA;AACA,0DAA0D,0CAAI,oBAAoB,IAAI,0CAAI,mBAAmB;AAC7G;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,0DAA0D,0CAAI,wBAAwB,IAAI,0CAAI,mBAAmB;AACjH;AACA;AACA,oCAAoC,0CAAI,sBAAsB,OAAO;AACrE;AACA;AACA,mCAAmC,0CAAI,gBAAgB,OAAO;AAC9D;AACA;AACA,mCAAmC,0CAAI,oBAAoB,OAAO;AAClE;;AAEA;AACA,0DAA0D,0CAAI,wBAAwB,IAAI,0CAAI,sBAAsB;AACpH;AACA,8CAA8C,0CAAI,wBAAwB,KAAK,0CAAI,eAAe;AAClG;;AAEA;AACA,wCAAwC,0CAAI,mBAAmB,2BAA2B;AAC1F;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA,0DAA0D,0CAAI,wBAAwB,IAAI,0CAAI,sBAAsB;AACpH;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,qBAAqB,IAAI,0CAAI,mBAAmB;AAC9G;AACA;AACA;;AAEA;AACA,0DAA0D,0CAAI,uBAAuB;AACrF,QAAQ,0CAAI,oBAAoB;AAChC;AACA;AACA;AACA,kBAAkB,GAAG,0CAAI,eAAe;AACxC;AACA;AACA,8DAA8D,0CAAI,mBAAmB,IAAI,0CAAI,eAAe;AAC5G;AACA;AACA,8DAA8D,0CAAI,mBAAmB,IAAI,0CAAI,eAAe;AAC5G,YAAY;AACZ,6EAA6E,0CAAI,mBAAmB;AACpG;AACA;;AAEA;AACA,0DAA0D,0CAAI,qBAAqB,IAAI,0CAAI,mBAAmB;AAC9G;AACA;AACA;;AAEA;AACA;AACA;AACA;AACe,uEAAQ,EAAC;;;;;;;;;;;;;AClXxB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA;AACA,6BAA6B;AAC7B,8BAA8B;AAC9B,yBAAyB;AACzB,yBAAyB;AACzB,gCAAgC;AAChC,iCAAiC;AACjC,mDAAmD;AACnD,kCAAkC;AAClC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACmB;;;;;;;;;;;;;ACtLnB;AAAA;AAAA;AAAA;AAAA;AACA;AAC4B;AACc;AAC1C;AACA;AACA,2DAA2D;AAC3D,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8CAA8C;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,2BAA2B,wCAAG,gBAAgB,wCAAG;AACjD;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA,mCAAmC,wBAAwB;AAC3D,iDAAiD,iCAAiC,cAAc,oCAAoC;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0CAA0C,IAAI,MAAM,IAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACqB;;;;;;;;;;;;;AC9PrB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACqB;;;;;;;;;;;;;ACpJrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AAClB;AACM;AACJ;AACM;AACgB;AACpB;AACJ;AACA;AACU;AACtC,qCAAqC,0DAAY;AACjD;AACA;AACA,yBAAyB;AACzB,8BAA8B;AAC9B,sBAAsB;AACtB,4BAA4B;AAC5B,+BAA+B;AAC/B,+BAA+B;AAC/B,wBAAwB;AACxB,sCAAsC;AACtC;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY,wCAAG;AACf,wBAAwB,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI,8BAA8B,0CAAI;AACpG,gBAAgB,gEAAe;AAC/B;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,qBAAqB,0CAAI;AACzB;AACA,SAAS;AACT;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA,sBAAsB,0CAAI;AAC1B;AACA;AACA,sBAAsB,0CAAI;AAC1B;AACA,mDAAmD,0CAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAG,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAQ;AAC3B;AACA;AACA,sBAAsB,wCAAG;AACzB,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,iBAAiB,wCAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,UAAU,4CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wCAAG,eAAe,wCAAG;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,kCAAkC,4CAAK;AACvC;AACA;AACkC;;;;;;;;;;;;;ACvLlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AAClB;AACM;AACJ;AACM;AACgB;AACpB;AACJ;AACA;AACU;AACtC,+BAA+B,0DAAY;AAC3C;AACA;AACA,yBAAyB;AACzB,8BAA8B;AAC9B,sBAAsB;AACtB,4BAA4B;AAC5B,+BAA+B;AAC/B,+BAA+B;AAC/B,wBAAwB;AACxB;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA,YAAY,wCAAG;AACf,wBAAwB,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI,8BAA8B,0CAAI;AACpG,gBAAgB,gEAAe;AAC/B;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,qBAAqB,0CAAI;AACzB;AACA,SAAS;AACT;AACA,QAAQ,gDAAO;AACf;AACA;AACA,mDAAmD,0CAAI,uBAAuB,0CAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAG,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAQ;AAC3B;AACA;AACA,sBAAsB,wCAAG;AACzB,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,iBAAiB,wCAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,UAAU,4CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;;;;;;;;;;;;;AClI5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AACZ;AACJ;AACM;AACR;AACI;AACJ;AACA;AAC5B,gCAAgC,0DAAY;AAC5C;AACA;AACA,4BAA4B;AAC5B,6BAA6B;AAC7B,+BAA+B;AAC/B,yBAAyB;AACzB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,qBAAqB,0CAAI;AACzB;AACA,SAAS;AACT;AACA;AACA,mDAAmD,0CAAI,uBAAuB,0CAAI;AAClF;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG;AAC9B;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,UAAU,4CAAK;AAC5B;AACA;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI,mBAAmB,4CAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,aAAa,wCAAG;AAC7B;AACA;AAC6B;;;;;;;;;;;;;ACzI7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AACZ;AACJ;AACc;AACR;AACR;AACI;AACJ;AAC5B,4BAA4B,0DAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACrE;AACA;AACA;AACA;AACA;AACA,qDAAqD,0CAAI;AACzD,QAAQ,wCAAG;AACX;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,wDAAW;AAC3B,gDAAgD,0CAAI;AACpD;AACA;AACA;AACA,gBAAgB,wDAAW;AAC3B,gDAAgD,0CAAI;AACpD;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,OAAO,0CAAI;AAC9B;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX;AACA;AACyB;;;;;;;;;;;;;AC3FzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4B;AACU;AACU;AACY;AACd;AACoB;AACZ;AACkB;AACJ;AACM;AAChB;AACgB;AACQ;AACpB;AACI;AACZ;AACY;AACA;AACE;AACQ;AAChB;AACF;AACF;AACxD;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,gBAAgB,kDAAQ;AACxB;AACA,2BAA2B,4DAAa;AACxC;AACA,2BAA2B,wEAAe;AAC1C;AACA,2BAA2B,0DAAY;AACvC;AACA,2BAA2B,8EAAsB;AACjD;AACA,2BAA2B,kEAAgB;AAC3C;AACA,2BAA2B,oFAAqB;AAChD;AACA,2BAA2B,gFAAmB;AAC9C;AACA,2BAA2B,sFAAsB;AACjD;AACA,2BAA2B,uEAAkB;AAC7C;AACA,2BAA2B,uFAAsB;AACjD;AACA,2BAA2B,+FAA0B;AACrD;AACA,2BAA2B,2EAAgB;AAC3C;AACA,2BAA2B,+EAAkB;AAC7C;AACA,2BAA2B,mEAAa;AACxC;AACA,2BAA2B,+EAAmB;AAC9C;AACA,2BAA2B,+EAAmB;AAC9C;AACA,2BAA2B,iFAAoB;AAC/C;AACA,2BAA2B,yFAAwB;AACnD;AACA,2BAA2B,yEAAgB;AAC3C;AACA,2BAA2B,uEAAc;AACzC;AACA,2BAA2B,qEAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8B;AACI;AACN;AACQ;AACwB;AACN;AACpB;AACN;AACI;AACJ;AACA;AACe;AACL;AACA;AACtC;AACA;AACA,6BAA6B;AAC7B,gCAAgC;AAChC,6BAA6B;AAC7B,6BAA6B;AAC7B,kCAAkC;AAClC,qCAAqC;AACrC,mDAAmD;AACnD,qCAAqC;AACrC;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA,gCAAgC,yCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,qBAAqB,0CAAI;AACzB;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,yCAAG,MAAM,yCAAG;AACpB,oBAAoB,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG;AACf;AACA;AACA,YAAY,wCAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wCAAG,qBAAqB,+CAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAO;AAC9B;AACA,YAAY,yCAAG,MAAM,yCAAG;AACxB,wBAAwB,0CAAI,4BAA4B,0CAAI;AAC5D,YAAY,wCAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,YAAY,+CAAI;AAChB;AACA,YAAY,wCAAG,SAAS,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA,aAAa,4CAAK;AAClB,yBAAyB,0CAAI;AAC7B;AACA;AACA,QAAQ,yCAAG,MAAM,yCAAG;AACpB,QAAQ,wCAAG;AACX,QAAQ,wCAAG,SAAS,0CAAI;AACxB,QAAQ,mDAAQ;AAChB;AACA;AACA,QAAQ,8CAAM;AACd,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI,mBAAmB,4CAAK;AAC5C;AACA;AACA,YAAY,4CAAK;AACjB,+BAA+B,4CAAK;AACpC;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA,2BAA2B,4CAAK;AAChC;AACA;AACA;AACA;AACA,mCAAmC,wCAAG;AACtC,sBAAsB,kEAAa;AACnC;AACA;AACA,mCAAmC,wCAAG;AACtC,sBAAsB,wEAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI,oBAAoB,4CAAK;AAC7C,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yCAAG,MAAM,yCAAG;AACpB;AACA;AACA;AACA,QAAQ,wCAAG,OAAO,0CAAI;AACtB;AACA;AACA,4BAA4B,0CAAI;AAChC;AACA;AACA,4BAA4B,0CAAI;AAChC;AACA;AACA,4BAA4B,0CAAI;AAChC;AACA;AACA,4BAA4B,0CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI,oBAAoB,4CAAK;AAC7C;AACA;AACA;AACA,QAAQ,yCAAG,MAAM,yCAAG;AACpB,QAAQ,mDAAQ;AAChB,QAAQ,wCAAG,OAAO,0CAAI;AACtB,qBAAqB,0CAAI;AACzB;AACA;AACA,kBAAkB;AAClB;AACwB;;;;;;;;;;;;;AC7QxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AACZ;AACJ;AACF;AACQ;AACF;AACF;AAChC,iCAAiC,0DAAY;AAC7C;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACrD;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAAI,uBAAuB,QAAQ,EAAE,GAAG;AAChD;AACA;AACA;AACA;AACA,iBAAiB;AACjB,4BAA4B;AAC5B;AACA;AACA,QAAQ,4CAAK;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2EAA2E;AAC3E;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8B;;;;;;;;;;;;;ACjJ9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC8C;AACZ;AACJ;AACM;AACR;AACI;AACJ;AACA;AACU;AACY;AAClD,2BAA2B,0DAAY;AACvC;AACA;AACA,sBAAsB;AACtB,0BAA0B;AAC1B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT,oBAAoB,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AAC9D,sBAAsB,0CAAI;AAC1B;AACA,YAAY,8DAAc;AAC1B;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,qBAAqB,0CAAI;AACzB;AACA,SAAS;AACT;AACA;AACA,mDAAmD,0CAAI,uBAAuB,0CAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,oBAAoB,kDAAQ;AAC5B,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA,wBAAwB,wCAAG,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG,oBAAoB,wCAAG;AACrD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,UAAU,4CAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,2BAA2B,wCAAG;AAC1D;AACA;AACA;AACA,2CAA2C,4CAAK;AAChD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,aAAa,wCAAG;AAC7B;AACA;AACwB;;;;;;;;;;;;;AC1MxB;AAAA;AAAA;AAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,sBAAsB,kDAAQ;AAC9B,2DAA2D;AAC3D;AACA;AACA;AACA;AACgB;;;;;;;;;;;;;ACrChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACI;AACU;AAC1C;AACA;AACA;AACA,qDAAqD;AACrD,4BAA4B;AAC5B,sDAAsD;AACtD;AACA;AACA,gCAAgC,wCAAG;AACnC,gBAAgB,4CAAK;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG;AACf,YAAY,sDAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;;;;;;;;;;;;;AC/Ef;AAAA;AAAA;AAAA;AACkC;AAClC;AACA;AACA,yBAAyB,8CAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmB;;;;;;;;;;;;;ACpDnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4B;AACE;AACE;AACJ;AACE;AACY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0CAAI,eAAe;AACzD,+BAA+B,0CAAI,iBAAiB;AACpD;AACA;AACA,0CAA0C,0CAAI,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA,QAAQ,sDAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0CAAI;AAC3C;AACA;AACA,2CAA2C,0CAAI;AAC/C,aAAa;AACb,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA,4BAA4B,0CAAI;AAChC;AACA,YAAY,4CAAK,iBAAiB,+CAAM;AACxC,uDAAuD;AACvD;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,wCAAG;AACf;AACA;AACA,sBAAsB,0CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrFA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK;AACb,QAAQ,4CAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,wCAAG;AAC7C;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC,6CAA6C,wCAAG;AAChD;AACA;AACA,SAAS;AACT;AACA;AACA;AACoB;;;;;;;;;;;;;ACnDpB;AAAA;AAAA;AAAA;AAC4B;AAC5B;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB;AACA;AACA;AACA;AACA;AACA;AACoB;;;;;;;;;;;;;ACnGpB;AAAA;AAAA;AAAA;AAAA;AAAA;AACgC;AACJ;AACE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0CAAI,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,MAAM,MAAM,MAAM,MAAM,MAAM,GAAG,0CAAI,gBAAgB,MAAM,MAAM;AACvG;AACA;AACA;AACA,oBAAoB,wCAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4CAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4CAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,+BAA+B,GAAG,8BAA8B;AACpG,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuB;;;;;;;;;;;;;AClFvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4B;AACE;AACI;AAClC;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wCAAG,gBAAgB,8CAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,cAAc,wCAAG;AAC7C;AACA;AACA,yBAAyB,wCAAG,gBAAgB,wCAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kBAAkB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wCAAG,gBAAgB,wCAAG;AAC5D;AACA;AACA;AACA,gBAAgB,wCAAG,oCAAoC,wCAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0DAA0D,wCAAG,cAAc;AAC3E;AACA;AACA,uEAAuE,wCAAG,eAAe;AACzF;AACA;AACA;AACyB;;;;;;;;;;;;;ACpJzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACI;AACJ;AACE;AACoB;AACV;AACxC;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC,uCAAuC;AACvC,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,mCAAmC;AACnC,8BAA8B;AAC9B,uBAAuB,oDAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,mDAAmD,eAAe;AAClE,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA,iBAAiB;AACjB,mDAAmD,eAAe;AAClE;AACA;AACA;AACA;AACA,iBAAiB;AACjB,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa,4CAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,SAAS,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA,oBAAoB,4CAAK;AACzB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,8DAAc;AAC1B;AACA;AACA;AACA,QAAQ,wCAAG,SAAS,0CAAI;AACxB;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB,uBAAuB,wCAAG;AAC1B,SAAS;AACT;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC,6CAA6C,wCAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAc,uBAAuB,4CAAK;AAC1D;AACA;AACA,YAAY,wCAAG,SAAS,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAc;AACtC;AACA;AACA,YAAY,wCAAG,SAAS,0CAAI;AAC5B,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAc;AAC1C;AACA;AACA;AACA,oBAAoB,8DAAc,uBAAuB,4CAAK;AAC9D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4CAAK;AACzC;AACA;AACA;AACA;AACA,sBAAsB,4CAAK;AAC3B;AACA;AACA;AACA;AACA,iDAAiD;AACjD,6BAA6B;AAC7B;AACA,2CAA2C,4CAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACkB;;;;;;;;;;;;;ACjWlB;AAAA;AAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8B;AACF;AACA;AACA;AACgB;AACJ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,wCAAG;AAC1B,kCAAkC,wCAAG;AACrC,iDAAiD;AACjD,uDAAuD;AACvD;AACA;AACA,2BAA2B,oDAAO;AAClC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,sBAAsB,GAAG,OAAO;AAC5D,QAAQ,wCAAG;AACX,QAAQ,wCAAG,gBAAgB,0CAAI;AAC/B,QAAQ,wDAAW;AACnB;AACA;AAC0B;;;;;;;;;;;;;ACrC1B;AAAA;AAAA;AAAA;AACA;AAC4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG,wBAAwB,2BAA2B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACwB;;;;;;;;;;;;;ACzTxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACA;AACA;AACM;AACJ;AACE;AACc;AACZ;AAClC;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,oBAAoB,wCAAG,iBAAiB,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,gCAAgC,wCAAG;AACnC,iBAAiB,4CAAK;AACtB;AACA;AACA,SAAS;AACT;AACA,QAAQ,wCAAG,sBAAsB,8CAAM,QAAQ,0CAAI;AACnD,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA;AACA;AACA,6CAA6C,wCAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG,wBAAwB,2BAA2B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,aAAa;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wCAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;;;;;;;;;;;;;ACvMzB;AAAA;AAAA;AAAA;AAC4B;AAC5B;AACA;AACA;AACA,yBAAyB;AACzB,6BAA6B;AAC7B;AACA,+BAA+B;AAC/B;AACA,yBAAyB;AACzB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf,YAAY,wCAAG;AACf;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,gCAAgC,wCAAG,oBAAoB,wCAAG;AAC1D;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT,gCAAgC,wCAAG;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA,6CAA6C,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiB;;;;;;;;;;;;;AC5IjB;AAAA;AAAA;AAAA;AAAA;AAA8B;AACF;AACA;AACE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG;AACX,gCAAgC,wCAAG;AACnC;AACA,YAAY,wCAAG;AACf,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,0CAAI,iBAAiB;AAC1E,6BAA6B,0CAAI,qBAAqB;AACtD,8BAA8B,0CAAI,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,MAAM,wCAAG;AAC5B,aAAa;AACb,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;ACtGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsB;;;;;;;;;;;;ACpEtB;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AACsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA,gCAAgC,MAAM,GAAG,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;;;;;;;;;;;;;AC3FpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACF;AACQ;AACF;AACN;AACI;AACjC,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,2BAA2B,wCAAG;AAC9B,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AAC+B;;;;;;;;;;;;;ACtD/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACN;AACE;AACM;AACJ;AACgB;AACR;AACZ;AACA;AACA;AACsB;AACnD,8BAA8B,0DAAY;AAC1C;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC,gCAAgC,wCAAG;AACnC;AACA;AACA,YAAY,oDAAS;AACrB;AACA;AACA,YAAY,4DAAa;AACzB;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD;AACA;AACA,SAAS;AACT,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD;AACA;AACA,SAAS;AACT,+BAA+B,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACxE;AACA;AACA;AACA,SAAS;AACT,oBAAoB,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AAC9D,sBAAsB,0CAAI;AAC1B;AACA,YAAY,+DAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,gDAAgD,0CAAI;AACpD;AACA;AACA,YAAY,4CAAK;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB;AACA,gBAAgB,0CAAI;AACpB,qBAAqB,0CAAI;AACzB;AACA,SAAS;AACT;AACA;AACA,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX;AACA,QAAQ,wCAAG;AACX;AACA,mCAAmC,wCAAG;AACtC,mCAAmC,wCAAG;AACtC;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0CAAI;AAC1B,sBAAsB,0CAAI;AAC1B,2DAA2D,0CAAI;AAC/D;AACA;AACA;AACA,2DAA2D,0CAAI,sBAAsB,0CAAI;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4CAAK;AACtB;AACA,YAAY,4CAAK;AACjB;AACA,oBAAoB,wCAAG;AACvB,aAAa;AACb,YAAY,yCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG,oBAAoB,wCAAG;AACrD;AACA,6BAA6B,wCAAG;AAChC;AACA;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,4CAAK,aAAa,wCAAG;AACrC;AACA;AACA;AACA,gBAAgB,4CAAK,aAAa,wCAAG;AACrC;AACA,YAAY,4CAAK,UAAU,4CAAK;AAChC;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,gBAAgB,wCAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA,aAAa;AACb;AACA,QAAQ,yCAAG,KAAK,0CAAI,qBAAqB,4CAAK;AAC9C;AACA;AACA;AACA,gCAAgC;AAChC,kCAAkC;AAClC;AACA;AAC2B;;;;;;;;;;;;;ACtL3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACF;AACQ;AACR;AACI;AACjC,qCAAqC,0DAAY;AACjD;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,oBAAoB,wCAAG;AACnD;AACA,YAAY,4CAAK;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4BAA4B;AAC5B;AACkC;;;;;;;;;;;;;ACpDlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACF;AACQ;AACF;AACN;AACI;AACJ;AAC7B,yCAAyC,0DAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA,oBAAoB;AACpB;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,SAAS,0CAAI;AACxB;AACA;AACA;AACA,kBAAkB,wCAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wCAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB,0BAA0B,wCAAG;AAC7B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsC;;;;;;;;;;;;;ACjGtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACF;AACQ;AACQ;AAChB;AACI;AACjC,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,gDAAO;AACf;AACA;AACA,gCAAgC,wDAAW;AAC3C;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wCAAG;AAC1B,YAAY,4CAAK;AACjB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B;AAC4B;;;;;;;;;;;;;AC/C5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACM;AACF;AACN;AACI;AACJ;AACA;AAC7B,iCAAiC,0DAAY;AAC7C;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA,oBAAoB;AACpB;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,SAAS,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB,0BAA0B,wCAAG;AAC7B;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8B;;;;;;;;;;;;;AC9H9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACN;AACE;AACF;AACQ;AACF;AACA;AACF;AACJ;AAC7B,qCAAqC,0DAAY;AACjD;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA,YAAY,8CAAI;AAChB;AACA,SAAS;AACT;AACA;AACA,mBAAmB,wCAAG;AACtB;AACA,YAAY,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACrD,0BAA0B,0CAAI;AAC9B;AACA,gBAAgB,8CAAI;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0CAAI,wBAAwB,0CAAI;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG;AAC9B,gCAAgC,wCAAG;AACnC,2BAA2B,wCAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB,gBAAgB,4CAAK;AACrB,0BAA0B,wCAAG;AAC7B;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;;;;;;;;;;;;;AC5IlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAqB,SAAI,IAAI,SAAI;AACjC;AACA;AACA,2GAA2G,sFAAsF,aAAa,EAAE;AAChN,sBAAsB,8BAA8B,gDAAgD,uDAAuD,EAAE,EAAE,GAAG;AAClK,4CAA4C,sCAAsC,UAAU,oBAAoB,EAAE,EAAE,UAAU;AAC9H;AACA;AAC+C;AACZ;AACJ;AACM;AACE;AACM;AAChB;AACM;AACN;AACI;AACJ;AACgB;AACN;AACK;AACD;AACd;AAC0B;AACvD,oCAAoC,0DAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,0BAA0B;AAC1B,gCAAgC;AAChC,6BAA6B;AAC7B,kCAAkC;AAClC,mFAAmF;AACnF,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAK;AAC7B;AACA,YAAY,yCAAG,SAAS,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iBAAiB,qBAAqB,cAAc;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe,aAAa,WAAW;AACxD;AACA;AACA;AACA,mEAAmE,WAAW;AAC9E;AACA;;AAEA;AACA,cAAc;;AAEd;AACA,cAAc;;AAEd;AACA;AACA;AACA,wBAAwB,WAAW,SAAS,WAAW,2BAA2B,gCAAgC;AAClH;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA,2CAA2C,oBAAoB;AAC/D,mFAAmF,eAAe;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW,IAAI,WAAW;AACvF;AACA;AACA;AACA;AACA;AACA,oDAAoD,YAAY;AAChE,oCAAoC,UAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA,6BAA6B,QAAQ,kCAAkC,EAAE;AACzE,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,+CAAI;AACpB;AACA;AACA,YAAY,wCAAG,8DAA8D,wCAAG;AAChF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sCAAsC,4CAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAU;AACtB;AACA;AACA;AACA,8BAA8B,+CAAI;AAClC,gCAAgC,wCAAG;AACnC;AACA,gCAAgC,wCAAG;AACnC,gCAAgC,wCAAG;AACnC,gCAAgC,wCAAG;AACnC,gCAAgC,wCAAG;AACnC,gCAAgC,wCAAG;AACnC,gCAAgC,wCAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAG;AACnB;AACA,SAAS;AACT;AACA;AACA,QAAQ,yCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AAClD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT,QAAQ,yCAAG,qBAAqB,8CAAM,MAAM,0CAAI;AAChD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA,gCAAgC,mEAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC,wDAAW,KAAK,eAAe;AAC/D,4CAA4C,mBAAmB;AAC/D,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT,0CAA0C,iBAAiB;AAC3D,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA,YAAY,wCAAG,MAAM,wCAAG;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C;AACA,SAAS;AACT;AACA;AACA,QAAQ,yCAAG;AACX,QAAQ,yCAAG;AACX,mCAAmC,wCAAG;AACtC,mCAAmC,wCAAG;AACtC,mCAAmC,wCAAG;AACtC;AACA,QAAQ,4CAAK;AACb;AACA;AACA,aAAa,4CAAK;AAClB,yBAAyB,0CAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0CAAI;AAC7B;AACA;AACA,yBAAyB,0CAAI;AAC7B;AACA,QAAQ,yDAAW;AACnB,QAAQ,yCAAG;AACX,iDAAiD;AACjD;AACA;AACA,6DAA6D,gCAAgC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ,gBAAgB;AAC/C;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,MAAM,wCAAG;AACpB;AACA;AACA;AACA,QAAQ,4CAAK;AACb;AACA;AACA,4BAA4B,kDAAO;AACnC;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA,YAAY,4CAAK;AACjB,SAAS;AACT,QAAQ,wCAAG,MAAM,wCAAG;AACpB,QAAQ,mDAAQ;AAChB;AACA;AACA;AACA,aAAa,4CAAK;AAClB,yBAAyB,0CAAI;AAC7B;AACA,QAAQ,yCAAG;AACX,QAAQ,8CAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8CAAM;AACzB,SAAS;AACT;AACA;AACA,mDAAmD,0CAAI,uBAAuB,0CAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,eAAe,kDAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG;AACnB;AACA;AACA;AACA;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB,0BAA0B,wCAAG;AAC7B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,yCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yCAAG,KAAK,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,iBAAiB,wCAAG;AACjC,QAAQ,4CAAK,aAAa,wCAAG;AAC7B;AACA;AACA;AACA;AACA,QAAQ,4CAAK;AACb;AACA;AACiC;;;;;;;;;;;;;ACzlBjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACN;AACE;AACF;AACQ;AACF;AACF;AACJ;AAC7B,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,SAAS,0CAAI;AACxB;AACA;AACA;AACA,kBAAkB,wCAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;;;;;;;;;;;;;ACnH1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6B;AACM;AACS;AACX;AACjC;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,uCAAuC;AACvC,uCAAuC;AACvC,sCAAsC;AACtC,wBAAwB;AACxB,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAAM;AACxB;AACA;AACA,2CAA2C;AAC3C,uCAAuC;AACvC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,EAAE,GAAG,EAAE,GAAG,EAAE;AACxC,0BAA0B;AAC1B,2BAA2B,4CAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAO;AACvC,kDAAkD;AAClD;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mCAAmC,wCAAG;AACtC;AACA;AACA;AACA;AACA;AACA,4BAA4B,8CAAI,oBAAoB;AACpD,gBAAgB,4CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AAC2B;;;;;;;;;;;;;ACjI3B;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,sBAAsB;AACtB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,eAAe;AACf,yBAAyB;AACzB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,mBAAmB;AACnB,oBAAoB;AACpB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,0BAA0B;AAC1B,gDAAgD;AAChD,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd,yBAAyB;AACzB,eAAe;AACf;AACA;AACA,eAAe;AACf,cAAc;AACd,+BAA+B;AAC/B,eAAe;AACf;AACA;AACA,kBAAkB;AAClB,mBAAmB;AACnB,gBAAgB;AAChB,mBAAmB;AACnB;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB,sCAAsC;AACtC,kBAAkB;AAClB;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB,2BAA2B;AAC3B,iBAAiB;AACjB;AACA;AACA,uBAAuB;AACvB,2BAA2B;AAC3B,yDAAyD;AACzD,wBAAwB;AACxB;AACA;AACA,0BAA0B;AAC1B,4BAA4B;AAC5B,4CAA4C;AAC5C,2BAA2B;AAC3B;AACA;AACA,iBAAiB;AACjB,WAAW;AACX,wBAAwB;AACxB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,WAAW;AACX,mBAAmB;AACnB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,WAAW;AACX,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc;AACd,4BAA4B;AAC5B,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ,EAAE,KAAK,EAAE,GAAG;AACnD,kCAAkC,QAAQ,EAAE,KAAK,EAAE,GAAG;AACtD,yDAAyD,QAAQ,EAAE,KAAK,EAAE,GAAG;AAC7E,gCAAgC,QAAQ,EAAE,KAAK,EAAE,GAAG;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,GAAG,EAAE,OAAO,WAAW,GAAG,KAAK,OAAO;AAC/E,4DAA4D,GAAG,EAAE,OAAO,OAAO,GAAG,IAAI,OAAO;AAC7F,2GAA2G,GAAG,EAAE,OAAO,wBAAwB,GAAG,KAAK,OAAO;AAC9J,wCAAwC,GAAG,EAAE,OAAO,WAAW,GAAG,KAAK,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,oBAAoB;AACpB,kDAAkD;AAClD,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,gBAAgB;AAChB,WAAW;AACX,sBAAsB;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,wBAAwB;AACxB,2BAA2B;AAC3B,qBAAqB;AACrB;AACA;AACA,cAAc;AACd,gBAAgB;AAChB,gBAAgB;AAChB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB;AAChB,qBAAqB;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB,4CAA4C;AAC5C,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoB;;;;;;;;;;;;;AC9wCpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACN;AACE;AACF;AACQ;AACF;AACF;AACJ;AAC7B,uCAAuC,0DAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,SAAS,0CAAI;AACxB;AACA;AACA;AACA,kBAAkB,wCAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoC;;;;;;;;;;;;;AC3HpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACM;AACF;AACN;AACI;AACJ;AACA;AAC7B,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA,oBAAoB;AACpB;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,SAAS,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC4B;;;;;;;;;;;;;ACtH5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACM;AACJ;AACgB;AACpB;AACA;AACA;AACA;AACsB;AACnD,4BAA4B,0DAAY;AACxC;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAG;AACnC;AACA;AACA,YAAY,4DAAa;AACzB;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD;AACA;AACA,SAAS;AACT,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD;AACA;AACA,SAAS;AACT,oBAAoB,wCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AAC9D,sBAAsB,0CAAI;AAC1B;AACA,YAAY,+DAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,gDAAgD,0CAAI;AACpD;AACA;AACA,YAAY,4CAAK;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB;AACA,gBAAgB,0CAAI;AACpB,qBAAqB,0CAAI;AACzB;AACA,SAAS;AACT;AACA;AACA,QAAQ,wCAAG;AACX,QAAQ,wCAAG;AACX;AACA,QAAQ,wCAAG;AACX,mCAAmC,wCAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0CAAI;AACtB,kBAAkB,0CAAI;AACtB,uDAAuD,0CAAI;AAC3D;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA,YAAY,4CAAK;AACjB;AACA,oBAAoB,wCAAG;AACvB,aAAa;AACb,YAAY,wCAAG,KAAK,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAG,oBAAoB,wCAAG;AACrD;AACA,6BAA6B,wCAAG;AAChC;AACA;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA;AACA;AACA,gBAAgB,4CAAK;AACrB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gBAAgB,4CAAK,aAAa,wCAAG;AACrC;AACA;AACA;AACA,gBAAgB,4CAAK,aAAa,wCAAG;AACrC;AACA,YAAY,4CAAK,UAAU,4CAAK;AAChC;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACyB;;;;;;;;;;;;;ACxIzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACM;AACJ;AACJ;AACA;AAC7B,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD;AACA,SAAS;AACT;AACA,oBAAoB;AACpB;AACA;AACA,QAAQ,gDAAO;AACf;AACA,mBAAmB;AACnB;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA,iCAAiC,wCAAG;AACpC;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;;;;;;;;;;;;;ACvD/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACF;AACQ;AACF;AACF;AACJ;AAC7B,mCAAmC,0DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAG,qBAAqB,8CAAM,OAAO,0CAAI;AACjD,sBAAsB,0CAAI;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA,mDAAmD,0CAAI,wBAAwB,0CAAI;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;;;;;;;;;;;;;AC7HhC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC+C;AACZ;AACJ;AACM;AACE;AACJ;AACN;AACI;AACJ;AACc;AACd;AAC0B;AACvD,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA;AACA,iCAAiC;AACjC,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAU;AACtB;AACA;AACA,QAAQ,yCAAG,qBAAqB,8CAAM,QAAQ,0CAAI;AAClD,sBAAsB,0CAAI,mBAAmB,0CAAI;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mEAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,kBAAkB,0CAAI;AACtB,iBAAiB,0CAAI;AACrB,4BAA4B,cAAc;AAC1C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0CAAI,uBAAuB,0CAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAG,oBAAoB,kDAAQ;AACxD;AACA;AACA;AACA;AACA,gBAAgB,wCAAG;AACnB;AACA;AACA;AACA;AACA,wBAAwB,wCAAG;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B,gBAAgB,4CAAK;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,wCAAG,KAAK,0CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wCAAG,KAAK,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAK,iBAAiB,wCAAG;AACjC,QAAQ,4CAAK,aAAa,wCAAG;AAC7B;AACA;AAC+B;;;;;;;;;;;;;ACpM/B;AAAA;AAAA;AAA6B;AAC7B;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wCAAG;AAC/B;AACA;AACA;AACA;AACA,aAAa;AACb,+EAA+E,aAAa;AAC5F;AACA;AACA;AACA,aAAa;AACb,2BAA2B,wCAAG;AAC9B,+DAA+D,mBAAmB;AAClF;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACoB;;;;;;;;;;;;;AC9BpB;AAAA;AAAA;AAAsC;AACtC;AACA;AACA,eAAe,kDAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACyB;;;;;;;;;;;;;ACbzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmC;AACF;AACE;AACa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,sCAAsC;AACtC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,EAAE,GAAG,EAAE,GAAG,EAAE;AACxC;AACA;AACA,2BAA2B,4CAAK;AAChC;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAI;AAC1B;AACA;AACA,gBAAgB,8CAAI;AACpB,2EAA2E,GAAG;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAAa;AACpC;AACA;AACA;AACA;AACA,iCAAiC,4DAAa;AAC9C;AACA;AACA;AACA,2BAA2B,4DAAa;AACxC;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe,GAAG,eAAe;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe,GAAG,eAAe;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe;AAC7D,sEAAsE,IAAI,oBAAoB,IAAI;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB","file":"content.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/ts/content.ts\");\n","/*\r\n * project: Powerful Pixiv Downloader\r\n * author:  xuejianxianzun; 雪见仙尊\r\n * license: GPL-3.0-or-later; http://www.gnu.org/licenses/gpl-3.0.txt\r\n * Github： https://github.com/xuejianxianzun/PixivBatchDownloader\r\n * Releases: https://github.com/xuejianxianzun/PixivBatchDownloader/releases\r\n * Wiki:    https://github.com/xuejianxianzun/PixivBatchDownloader/wiki\r\n * Website: https://pixiv.download/\r\n * E-mail:  xuejianxianzun@gmail.com\r\n * QQ group:  675174717\r\n */\r\nimport './modules/PageType';\r\nimport './modules/CenterPanel';\r\nimport './modules/InitPage';\r\nimport './modules/DownloadControl';\r\nimport './modules/RightIcon';\r\nimport './modules/Tip';\r\nimport './modules/Output';\r\nimport './modules/Support';\r\n","class API {\r\n    // 根据对象某个属性的值（视为数字）排序对象。返回的结果是降序排列\r\n    static sortByProperty(propertyName) {\r\n        return function (object1, object2) {\r\n            // 排序的内容有时可能是字符串，需要转换成数字排序\r\n            const value1 = parseInt(object1[propertyName]);\r\n            const value2 = parseInt(object2[propertyName]);\r\n            if (value2 < value1) {\r\n                return -1;\r\n            }\r\n            else if (value2 > value1) {\r\n                return 1;\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        };\r\n    }\r\n    // 用正则过滤不安全的字符，（Chrome 和 Windows 不允许做文件名的字符）\r\n    // 把一些特殊字符替换成全角字符\r\n    static replaceUnsafeStr(str) {\r\n        str = str.replace(this.unsafeStr, '');\r\n        for (let index = 0; index < this.fullWidthDict.length; index++) {\r\n            const rule = this.fullWidthDict[index];\r\n            const reg = new RegExp(rule[0], 'g');\r\n            str = str.replace(reg, rule[1]);\r\n        }\r\n        return str;\r\n    }\r\n    // 检查给定的字符串解析为数字后，是否大于 0\r\n    static checkNumberGreater0(arg) {\r\n        let num = parseInt(arg);\r\n        // 空值会是 NaN\r\n        if (!isNaN(num) && num > 0) {\r\n            // 符合条件\r\n            return {\r\n                result: true,\r\n                value: num,\r\n            };\r\n        }\r\n        // 不符合条件\r\n        return {\r\n            result: false,\r\n            value: 0,\r\n        };\r\n    }\r\n    // 从 url 中获取指定的查询字段的值\r\n    // 注意：返回值经过 encodeURIComponent 编码！\r\n    static getURLSearchField(url, query) {\r\n        const result = new URL(url).searchParams.get(query);\r\n        if (result !== null) {\r\n            return encodeURIComponent(result);\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    // 从 url 中获取 tag\r\n    static getTagFromURL(url) {\r\n        const nowURL = new URL(url);\r\n        // 2 用户作品列表页\r\n        if (/\\/users\\/\\d+/.test(url) && !url.includes('/bookmarks')) {\r\n            // 匹配 pathname 里用户 id 之后的字符\r\n            const test = nowURL.pathname.match(/\\/users\\/\\d+(\\/.+)/);\r\n            if (test && test.length === 2) {\r\n                const str = test[1];\r\n                // 如果用户 id 之后的字符多于一个路径，则把最后一个路径作为 tag，示例\r\n                // https://www.pixiv.net/users/2188232/illustrations/ghostblade\r\n                const array = str.split('/');\r\n                // [\"\", \"illustrations\", \"ghostblade\"]\r\n                if (array.length > 2) {\r\n                    return array[array.length - 1];\r\n                }\r\n            }\r\n        }\r\n        // 4 旧版收藏页面\r\n        if (nowURL.pathname === '/bookmark.php') {\r\n            if (parseInt(this.getURLSearchField(nowURL.href, 'untagged')) === 1) {\r\n                // 旧版 “未分类” tag 是个特殊标记\r\n                // https://www.pixiv.net/bookmark.php?untagged=1\r\n                return '未分類';\r\n            }\r\n        }\r\n        // 4 新版收藏页面\r\n        if (nowURL.pathname.includes('/bookmarks/')) {\r\n            // 新版收藏页 url，tag 在路径末端，如\r\n            // https://www.pixiv.net/users/9460149/bookmarks/artworks/R-18\r\n            // https://www.pixiv.net/users/9460149/bookmarks/novels/R-18\r\n            const test = /\\/bookmarks\\/\\w*\\/(.[^\\/|^\\?|^&]*)/.exec(nowURL.pathname);\r\n            if (test !== null && test.length > 1 && !!test[1]) {\r\n                return test[1];\r\n            }\r\n        }\r\n        // 5 搜索页面\r\n        if (nowURL.pathname.includes('/tags/')) {\r\n            return nowURL.pathname.split('tags/')[1].split('/')[0];\r\n        }\r\n        // 默认情况，从查询字符串里获取，如下网址\r\n        // https://www.pixiv.net/bookmark.php?tag=R-18\r\n        return this.getURLSearchField(nowURL.href, 'tag');\r\n    }\r\n    // 更新 token\r\n    static updateToken() {\r\n        // 每隔一段时间更新 token，如果未达到指定时间间隔，则不检查\r\n        const interval = 300000; // 两次检查之间的间隔。目前设置为 5 分钟\r\n        const nowTime = new Date().getTime();\r\n        const lastTimeStr = localStorage.getItem('xzTokenTime');\r\n        const token = localStorage.getItem('xzToken');\r\n        if (token &&\r\n            lastTimeStr &&\r\n            nowTime - Number.parseInt(lastTimeStr) < interval) {\r\n            return;\r\n        }\r\n        // 从网页源码里获取用户 token，并储存起来\r\n        fetch('https://www.pixiv.net/artworks/62751951')\r\n            .then((response) => {\r\n            return response.text();\r\n        })\r\n            .then((data) => {\r\n            let result = data.match(/token\":\"(\\w+)\"/);\r\n            if (result) {\r\n                localStorage.setItem('xzToken', result[1]);\r\n                localStorage.setItem('xzTokenTime', new Date().getTime().toString());\r\n            }\r\n            else {\r\n                console.warn('UpdateToken failed: no token found!');\r\n            }\r\n        });\r\n    }\r\n    // 获取 token\r\n    // 从本地存储里获取用户 token\r\n    static getToken() {\r\n        const token = localStorage.getItem('xzToken');\r\n        if (token) {\r\n            return token;\r\n        }\r\n        else {\r\n            this.updateToken();\r\n            return '';\r\n        }\r\n    }\r\n    // 从 url 里获取 artworks id\r\n    // 可以传入 url，无参数则使用当前页面的 url\r\n    static getIllustId(url) {\r\n        const str = url || window.location.search || location.href;\r\n        if (str.includes('illust_id')) {\r\n            // 传统 url\r\n            return /illust_id=(\\d*\\d)/.exec(str)[1];\r\n        }\r\n        else if (str.includes('/artworks/')) {\r\n            // 新版 url\r\n            return /artworks\\/(\\d*\\d)/.exec(str)[1];\r\n        }\r\n        else {\r\n            // 直接取出 url 中的数字，不保证准确\r\n            return /\\d*\\d/.exec(location.href)[0];\r\n        }\r\n    }\r\n    // 从 url 里获取 novel id\r\n    // https://www.pixiv.net/novel/show.php?id=12771688\r\n    static getNovelId(url) {\r\n        const str = url || window.location.search || location.href;\r\n        const test = str.match(/\\?id=(\\d*)?/);\r\n        return test[1];\r\n    }\r\n    // 通用的请求流程\r\n    // 发送 get 请求，返回 json 数据，抛出异常\r\n    static request(url) {\r\n        return new Promise((resolve, reject) => {\r\n            fetch(url, {\r\n                method: 'get',\r\n                credentials: 'same-origin',\r\n            })\r\n                .then((response) => {\r\n                if (response.ok) {\r\n                    return response.json();\r\n                }\r\n                else {\r\n                    // 第一种异常，请求成功但状态不对\r\n                    reject({\r\n                        status: response.status,\r\n                        statusText: response.statusText,\r\n                    });\r\n                }\r\n            })\r\n                .then((data) => {\r\n                resolve(data);\r\n            })\r\n                .catch((error) => {\r\n                // 第二种异常，请求失败\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n    // 获取收藏数据\r\n    // 这个 api 返回的作品列表顺序是按收藏顺序由近期到早期排列的\r\n    static async getBookmarkData(id, type = 'illusts', tag, offset, hide = false) {\r\n        const url = `https://www.pixiv.net/ajax/user/${id}/${type}/bookmarks?tag=${tag}&offset=${offset}&limit=100&rest=${hide ? 'hide' : 'show'}&rdm=${Math.random()}`;\r\n        return this.request(url);\r\n    }\r\n    // 添加收藏\r\n    static async addBookmark(type, id, tags, hide, token) {\r\n        const restrict = hide ? 1 : 0;\r\n        let body = {};\r\n        if (type === 'illusts') {\r\n            body = {\r\n                comment: '',\r\n                illust_id: id,\r\n                restrict: restrict,\r\n                tags: tags,\r\n            };\r\n        }\r\n        else {\r\n            body = {\r\n                comment: '',\r\n                novel_id: id,\r\n                restrict: restrict,\r\n                tags: tags,\r\n            };\r\n        }\r\n        return fetch(`https://www.pixiv.net/ajax/${type}/bookmarks/add`, {\r\n            method: 'POST',\r\n            credentials: 'same-origin',\r\n            headers: {\r\n                Accept: 'application/json',\r\n                'Content-Type': 'application/json; charset=utf-8',\r\n                'x-csrf-token': token,\r\n            },\r\n            body: JSON.stringify(body),\r\n        });\r\n    }\r\n    // 获取关注的用户列表\r\n    static getFollowingList(id, rest = 'show', offset = 0, limit = 100, tag = '', lang = 'zh') {\r\n        const url = `https://www.pixiv.net/ajax/user/${id}/following?offset=${offset}&limit=${limit}&rest=${rest}&tag=${tag}&lang=${lang}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取用户信息\r\n    static getUserProfile(id) {\r\n        // full=1 在画师的作品列表页使用，获取详细信息\r\n        // full=0 在作品页内使用，只获取少量信息\r\n        const url = `https://www.pixiv.net/ajax/user/${id}?full=1`;\r\n        return this.request(url);\r\n    }\r\n    // 获取用户指定类型的作品列表\r\n    // 返回作品的 id 列表，不包含详细信息\r\n    static async getUserWorksByType(id, type = ['illusts', 'manga', 'novels']) {\r\n        let typeSet = new Set(type);\r\n        let result = [];\r\n        const url = `https://www.pixiv.net/ajax/user/${id}/profile/all`;\r\n        let data = await this.request(url);\r\n        for (const type of typeSet.values()) {\r\n            const idList = Object.keys(data.body[type]);\r\n            for (const id of idList) {\r\n                result.push({\r\n                    type,\r\n                    id,\r\n                });\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    // 获取用户指定类型、并且指定 tag 的作品列表\r\n    // 返回整个请求的结果，里面包含作品的详细信息\r\n    // 必须带 tag 使用。不带 tag 虽然也能获得数据，但是获得的并不全，很奇怪。\r\n    static getUserWorksByTypeWithTag(id, type, tag, offset = 0, limit = 999999) {\r\n        // https://www.pixiv.net/ajax/user/2369321/illusts/tag?tag=Fate/GrandOrder&offset=0&limit=9999999\r\n        const url = `https://www.pixiv.net/ajax/user/${id}/${type}/tag?tag=${tag}&offset=${offset}&limit=${limit}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取插画 漫画 的详细信息\r\n    static getArtworkData(id) {\r\n        const url = `https://www.pixiv.net/ajax/illust/${id}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取作品的动图信息\r\n    static getUgoiraMeta(id) {\r\n        const url = `https://www.pixiv.net/ajax/illust/${id}/ugoira_meta`;\r\n        return this.request(url);\r\n    }\r\n    // 获取小说的详细信息\r\n    static getNovelData(id) {\r\n        const url = `https://www.pixiv.net/ajax/novel/${id}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取相关作品\r\n    static getRelatedData(id) {\r\n        // 最后的 18 是预加载首屏的多少个作品的信息，和下载并没有关系\r\n        const url = `https://www.pixiv.net/ajax/illust/${id}/recommend/init?limit=18`;\r\n        return this.request(url);\r\n    }\r\n    // 获取排行榜数据\r\n    // 排行榜数据基本是一批 50 条作品信息\r\n    static getRankingData(option) {\r\n        let url = `https://www.pixiv.net/ranking.php?mode=${option.mode}&p=${option.p}&format=json`;\r\n        // 把可选项添加到 url 里\r\n        let temp = new URL(url);\r\n        // 下面两项需要判断有值再添加。不可以添加了这些字段却使用空值。\r\n        if (option.worksType) {\r\n            temp.searchParams.set('content', option.worksType);\r\n        }\r\n        if (option.date) {\r\n            temp.searchParams.set('date', option.date);\r\n        }\r\n        url = temp.toString();\r\n        return this.request(url);\r\n    }\r\n    // 获取收藏后的相似作品数据\r\n    // 需要传入作品 id 和要抓取的数量。但是实际获取到的数量会比指定的数量少一些\r\n    static getRecommenderData(id, number) {\r\n        const url = `/rpc/recommender.php?type=illust&sample_illusts=${id}&num_recommendations=${number}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取搜索数据\r\n    static getSearchData(word, type = 'artworks', p = 1, option = {}) {\r\n        // 基础的 url\r\n        let url = `https://www.pixiv.net/ajax/search/${type}/${encodeURIComponent(word)}?word=${encodeURIComponent(word)}&p=${p}`;\r\n        // 把可选项添加到 url 里\r\n        let temp = new URL(url);\r\n        for (const [key, value] of Object.entries(option)) {\r\n            if (value) {\r\n                temp.searchParams.set(key, value);\r\n            }\r\n        }\r\n        url = temp.toString();\r\n        return this.request(url);\r\n    }\r\n    static getNovelSearchData(word, p = 1, option = {}) {\r\n        // 基础的 url\r\n        let url = `https://www.pixiv.net/ajax/search/novels/${encodeURIComponent(word)}?word=${encodeURIComponent(word)}&p=${p}`;\r\n        // 把可选项添加到 url 里\r\n        let temp = new URL(url);\r\n        for (const [key, value] of Object.entries(option)) {\r\n            if (value) {\r\n                temp.searchParams.set(key, value);\r\n            }\r\n        }\r\n        url = temp.toString();\r\n        return this.request(url);\r\n    }\r\n    // 获取大家的新作品的数据\r\n    static getNewIllustData(option) {\r\n        let url = `https://www.pixiv.net/ajax/illust/new?lastId=${option.lastId}&limit=${option.limit}&type=${option.type}&r18=${option.r18}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取大家的新作小说的数据\r\n    static getNewNovleData(option) {\r\n        let url = `https://www.pixiv.net/ajax/novel/new?lastId=${option.lastId}&limit=${option.limit}&r18=${option.r18}`;\r\n        return this.request(url);\r\n    }\r\n    // 获取关注的的新作品的数据\r\n    static getBookmarkNewIllustData(p = 1, r18 = false) {\r\n        let path = r18 ? 'bookmark_new_illust_r18' : 'bookmark_new_illust';\r\n        let url = `https://www.pixiv.net/${path}.php?p=${p}`;\r\n        return new Promise((resolve, reject) => {\r\n            fetch(url, {\r\n                method: 'get',\r\n                credentials: 'same-origin',\r\n            })\r\n                .then((response) => {\r\n                if (response.ok) {\r\n                    return response.text();\r\n                }\r\n                else {\r\n                    throw new Error(response.status.toString());\r\n                }\r\n            })\r\n                .then((data) => {\r\n                let listPageDocument = new DOMParser().parseFromString(data, 'text/html');\r\n                let worksInfoText = listPageDocument.querySelector('#js-mount-point-latest-following').dataset.items;\r\n                resolve(JSON.parse(worksInfoText));\r\n            })\r\n                .catch((error) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n    // 根据 illustType，返回作品类型的描述\r\n    // 主要用于储存进 idList\r\n    static getWorkType(illustType) {\r\n        switch (parseInt(illustType.toString())) {\r\n            case 0:\r\n                return 'illusts';\r\n            case 1:\r\n                return 'manga';\r\n            case 2:\r\n                return 'ugoira';\r\n            case 3:\r\n                return 'novels';\r\n            default:\r\n                return 'unknown';\r\n        }\r\n    }\r\n    // 从 URL 中获取指定路径名的值，适用于符合 RESTful API 风格的路径\r\n    // 如 https://www.pixiv.net/novel/series/1090654\r\n    // 把路径用 / 分割，查找 key 所在的位置，后面一项就是它的 value\r\n    static getURLPathField(query) {\r\n        const pathArr = location.pathname.split('/');\r\n        const index = pathArr.indexOf(query);\r\n        if (index > 0) {\r\n            return pathArr[index + 1];\r\n        }\r\n        throw new Error(`getURLPathField ${query} failed!`);\r\n    }\r\n    // 获取小说的系列作品信息\r\n    // 这个 api 目前一批最多只能返回 30 个作品的数据，所以可能需要多次获取\r\n    static getNovelSeriesData(series_id, limit = 30, last_order, order_by = 'asc') {\r\n        const url = `https://www.pixiv.net/ajax/novel/series_content/${series_id}?limit=${limit}&last_order=${last_order}&order_by=${order_by}`;\r\n        return this.request(url);\r\n    }\r\n}\r\n// 不安全的字符，这里多数是控制字符，需要替换掉\r\nAPI.unsafeStr = new RegExp(/[\\u0001-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0605\\u061c\\u06dd\\u070f\\u08e2\\u180e\\u200b-\\u200f\\u202a-\\u202e\\u2060-\\u2064\\u2066-\\u206f\\ufdd0-\\ufdef\\ufeff\\ufff9-\\ufffb\\ufffe\\uffff]/g);\r\n// 一些需要替换成全角字符的符号，左边是正则表达式的字符\r\nAPI.fullWidthDict = [\r\n    ['\\\\\\\\', '＼'],\r\n    ['/', '／'],\r\n    [':', '：'],\r\n    ['\\\\?', '？'],\r\n    ['\"', '＂'],\r\n    ['<', '＜'],\r\n    ['>', '＞'],\r\n    ['\\\\*', '＊'],\r\n    ['\\\\|', '｜'],\r\n    ['~', '～'],\r\n];\r\nexport { API };\r\n","// 检查图片是否是黑白图片\r\nclass BlackAndWhiteImage {\r\n    constructor() {\r\n        this.latitude = 1; // 宽容度\r\n    }\r\n    async check(imgUrl) {\r\n        const img = await this.loadImg(imgUrl).catch((error) => {\r\n            console.log(error);\r\n        });\r\n        // 当加载图片失败时，无法进行判断，默认为彩色图片\r\n        if (!img) {\r\n            return false;\r\n        }\r\n        const first = this.getResult(this.getColor(img));\r\n        return first;\r\n        // 当判断结果是彩色图片的时候，基本不会是误判。但如果结果是黑白图，可能存在误判。\r\n        // 因此，如果第一次判断是黑白的，可以考虑进行第二次检测，第二次只检测局部\r\n    }\r\n    // 加载图片\r\n    async loadImg(url) {\r\n        return new Promise(async (resolve, reject) => {\r\n            const img = document.createElement('img');\r\n            img.onload = () => resolve(img);\r\n            img.onerror = () => {\r\n                reject(new Error(`Load image error! url: ${url}`));\r\n            };\r\n            // 如果传递的时 blobURL 就直接使用，不是的话先获取图片\r\n            if (url.startsWith('blob')) {\r\n                img.src = url;\r\n            }\r\n            else {\r\n                const res = await fetch(url).catch((error) => {\r\n                    throw new Error(`Load image error! url: ${url}`);\r\n                });\r\n                const blob = await res.blob();\r\n                const blobURL = URL.createObjectURL(blob);\r\n                img.src = blobURL;\r\n            }\r\n        });\r\n    }\r\n    // 获取图片中 rgb 三色的平均值\r\n    getColor(img) {\r\n        const width = img.width;\r\n        const height = img.height;\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        const con = canvas.getContext('2d');\r\n        con.drawImage(img, 0, 0);\r\n        const imageData = con.getImageData(0, 0, width, height);\r\n        const data = imageData.data;\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        // 取所有像素的平均值\r\n        for (let row = 0; row < height; row++) {\r\n            for (let col = 0; col < width; col++) {\r\n                r += data[(width * row + col) * 4];\r\n                g += data[(width * row + col) * 4 + 1];\r\n                b += data[(width * row + col) * 4 + 2];\r\n            }\r\n        }\r\n        // 求取平均值\r\n        r /= width * height;\r\n        g /= width * height;\r\n        b /= width * height;\r\n        // 将最终的值取整\r\n        r = Math.round(r);\r\n        g = Math.round(g);\r\n        b = Math.round(b);\r\n        return [r, g, b];\r\n    }\r\n    // 根据 rgb 的值，判断是否是黑白图片\r\n    getResult(rgb) {\r\n        const [r, g, b] = rgb;\r\n        // 如果 rgb 值相同则是黑白图片\r\n        if (r === g && g === b) {\r\n            return true;\r\n        }\r\n        else {\r\n            // 如果 rgb 值不相同，则根据宽容度判断是否近似为黑白图片\r\n            // 这是因为获取 rgb 的结果时，进行了四舍五入，即使 rgb 非常接近，也可能会相差 1（未论证）\r\n            const max = Math.max(r, g, b); // 取出 rgb 中的最大值\r\n            const min = max - this.latitude; // 允许的最小值\r\n            // 如果 rgb 三个数值与最大的数值相比，差距在宽容度之内，则检查通过\r\n            return [r, g, b].every((number) => {\r\n                return number >= min;\r\n            });\r\n        }\r\n    }\r\n}\r\nconst blackAndWhiteImage = new BlackAndWhiteImage();\r\nexport { blackAndWhiteImage };\r\n","import { API } from './API';\r\nimport { DOM } from './DOM';\r\nimport { Colors } from './Colors';\r\nimport { lang } from './Lang';\r\nimport { form } from './Settings';\r\n// 一键收藏本页面上的所有作品\r\nclass BookmarkAllWorks {\r\n    constructor() {\r\n        this.type = 'illusts'; // 页面是图片还是小说\r\n        this.idList = [];\r\n        this.addTagList = []; // 需要添加 tag 的作品的数据\r\n        this.index = 0;\r\n        this.workList = null;\r\n        this.token = API.getToken();\r\n        const btn = DOM.addBtn('otherBtns', Colors.green, lang.transl('_收藏本页面的所有作品'));\r\n        this.btn = btn;\r\n    }\r\n    // workList 是作品列表元素的合集。本模块会尝试分析每个作品元素中的超链接，提取出作品 id\r\n    setWorkList(list) {\r\n        if (!list) {\r\n            alert(lang.transl('_没有数据可供使用'));\r\n            return;\r\n        }\r\n        this.workList = list;\r\n        this.readyAddTag();\r\n    }\r\n    // 准备添加 tag\r\n    async readyAddTag(loop = 0) {\r\n        // 每次点击清空结果\r\n        this.idList = [];\r\n        this.addTagList = [];\r\n        this.index = 0;\r\n        this.token = API.getToken();\r\n        this.btn.setAttribute('disabled', 'disabled');\r\n        this.btn.textContent = `Checking`;\r\n        if (window.location.pathname.includes('/novel')) {\r\n            this.type = 'novels';\r\n        }\r\n        this.getIdList();\r\n    }\r\n    // 获取作品列表里的作品 id\r\n    getIdList() {\r\n        if (!this.workList) {\r\n            return;\r\n        }\r\n        const regExp = this.type === 'illusts' ? /\\/artworks\\/(\\d*)/ : /\\?id=(\\d*)/;\r\n        for (const el of this.workList) {\r\n            const a = el.querySelector('a');\r\n            if (a) {\r\n                // \"https://www.pixiv.net/artworks/82618568\"\r\n                // \"https://www.pixiv.net/novel/show.php?id=12350618\"\r\n                const test = regExp.exec(a.href);\r\n                if (test && test.length > 1) {\r\n                    this.idList.push(test[1]);\r\n                }\r\n            }\r\n        }\r\n        this.getTagData();\r\n    }\r\n    // 获取每个作品的详细信息，保存它们的 tag\r\n    async getTagData() {\r\n        this.btn.textContent = `Get data ${this.index} / ${this.idList.length}`;\r\n        const id = this.idList[this.index];\r\n        try {\r\n            let data;\r\n            // 发起请求\r\n            if (this.type === 'novels') {\r\n                data = await API.getNovelData(id);\r\n            }\r\n            else {\r\n                data = await API.getArtworkData(id);\r\n            }\r\n            const tagArr = data.body.tags.tags; // 取出 tag 信息\r\n            const tags = []; // 保存 tag 列表\r\n            for (const tagData of tagArr) {\r\n                tags.push(tagData.tag);\r\n            }\r\n            this.addTagList.push({\r\n                id: data.body.id,\r\n                tags: tags,\r\n                restrict: false,\r\n            });\r\n            this.index++;\r\n            if (this.index === this.idList.length) {\r\n                this.index = 0;\r\n                return this.addTag();\r\n            }\r\n            this.getTagData();\r\n        }\r\n        catch (error) {\r\n            this.getTagData();\r\n        }\r\n    }\r\n    // 给所有作品添加 tag（即使之前收藏过的，也会再次收藏）\r\n    async addTag() {\r\n        this.btn.textContent = `Add bookmark ${this.index} / ${this.idList.length}`;\r\n        const data = this.addTagList[this.index];\r\n        // 如果设置了不启用快速收藏，则把 tag 设置为空\r\n        if (form.quickBookmarks.checked === false) {\r\n            data.tags = [];\r\n        }\r\n        await API.addBookmark(this.type, data.id, data.tags, data.restrict, this.token);\r\n        this.index++;\r\n        // 添加完毕\r\n        if (this.index === this.addTagList.length) {\r\n            this.btn.textContent = `✓ Complete`;\r\n            this.btn.removeAttribute('disabled');\r\n            return;\r\n        }\r\n        // 继续添加\r\n        this.addTag();\r\n    }\r\n}\r\nexport { BookmarkAllWorks };\r\n","import { API } from './API';\r\nimport { DOM } from './DOM';\r\n// 给收藏页面里的未分类作品批量添加 tag\r\nclass BookmarksAddTag {\r\n    constructor(btn) {\r\n        this.type = 'illusts'; // 页面是图片还是小说\r\n        this.addTagList = []; // 需要添加 tag 的作品的数据\r\n        this.once = 100; // 一次请求多少个作品的数据\r\n        this.btn = btn;\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        this.btn.addEventListener('click', () => {\r\n            this.addTagList = []; // 每次点击清空结果\r\n            this.btn.setAttribute('disabled', 'disabled');\r\n            this.btn.textContent = `Checking`;\r\n            if (window.location.pathname.includes('/novel')) {\r\n                this.type = 'novels';\r\n            }\r\n            this.readyAddTag();\r\n        });\r\n    }\r\n    // 准备添加 tag。loop 表示这是第几轮循环\r\n    async readyAddTag(loop = 0) {\r\n        const offset = loop * this.once; // 一次请求只能获取一部分，所以可能有多次请求，要计算偏移量\r\n        // 发起请求\r\n        const [showData, hideData] = await Promise.all([\r\n            API.getBookmarkData(DOM.getUserId(), this.type, '未分類', offset, false),\r\n            API.getBookmarkData(DOM.getUserId(), this.type, '未分類', offset, true),\r\n        ]).catch((error) => {\r\n            if (error.status && error.status === 403) {\r\n                this.btn.textContent = `× Permission denied`;\r\n            }\r\n            throw new Error('Permission denied');\r\n        });\r\n        // 保存有用的数据\r\n        for (const data of [showData, hideData]) {\r\n            const works = data.body.works;\r\n            // 如果作品的 bookmarkData 为假说明没有实际数据，可能是在获取别人的收藏数据。\r\n            if (works.length > 0 && works[0].bookmarkData) {\r\n                works.forEach((work) => {\r\n                    this.addTagList.push({\r\n                        id: work.id,\r\n                        tags: work.tags,\r\n                        restrict: work.bookmarkData.private,\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        // 已删除或无法访问的作品不会出现在请求结果里。本来一次请求 100 个，但返回的结果有可能会比 100 个少，甚至极端情况下是 0。所以实际获取到的作品可能比  total 数量少，这是正常的。\r\n        // 判断是否请求了所有未分类的作品数据\r\n        const total = offset + this.once;\r\n        if (total >= showData.body.total && total >= hideData.body.total) {\r\n            if (this.addTagList.length === 0) {\r\n                // 如果结果为空，不需要处理\r\n                this.btn.textContent = `✓ No need`;\r\n                this.btn.removeAttribute('disabled');\r\n                return;\r\n            }\r\n            else {\r\n                // 开始添加 tag\r\n                this.addTag(0, this.addTagList, API.getToken());\r\n            }\r\n        }\r\n        else {\r\n            // 需要继续获取\r\n            this.readyAddTag(++loop);\r\n        }\r\n    }\r\n    // 给未分类作品添加 tag\r\n    async addTag(index, addList, tt) {\r\n        const item = addList[index];\r\n        await API.addBookmark(this.type, item.id, item.tags, item.restrict, tt);\r\n        if (index < addList.length - 1) {\r\n            index++;\r\n            this.btn.textContent = `${index} / ${addList.length}`;\r\n            // 继续添加下一个\r\n            this.addTag(index, addList, tt);\r\n        }\r\n        else {\r\n            this.btn.textContent = `✓ Complete`;\r\n            this.btn.removeAttribute('disabled');\r\n        }\r\n    }\r\n}\r\nexport { BookmarksAddTag };\r\n","// 用户界面\r\nimport { lang } from './Lang';\r\nimport { EVT } from './EVT';\r\nimport { DOM } from './DOM';\r\nimport { store } from './Store';\r\nimport { themeColor } from './ThemeColor';\r\n// 中间面板\r\nclass CenterPanel {\r\n    constructor() {\r\n        this.centerPanel = document.createElement('div'); // 中间面板\r\n        this.updateLink = document.createElement('a');\r\n        this.updateActiveClass = 'updateActiveClass';\r\n        this.addCenterPanel();\r\n        this.bindEvents();\r\n    }\r\n    // 添加中间面板\r\n    addCenterPanel() {\r\n        const centerPanelHTML = `\n      <div class=\"centerWrap\">\n      <div class=\"centerWrap_head\">\n      <p class=\"centerWrap_title blue\">Powerful Pixiv Downloader</p>\n      <div class=\"btns\">\n      <a class=\"has_tip centerWrap_top_btn update\" data-tip=\"${lang.transl('_newver')}\" href=\"https://github.com/xuejianxianzun/PixivBatchDownloader/releases/latest\" target=\"_blank\">\n      <svg t=\"1574401457339\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4736\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"16\" height=\"16\"><defs><style type=\"text/css\"></style></defs><path d=\"M894.72 795.477333l-85.418667-85.418667c0.128-0.170667 0.170667-0.341333 0.298667-0.512l-158.890667-158.890667c0.042667-0.597333 37.248-37.248 37.248-37.248l178.773333 0 1.706667-1.493333c-0.853333-196.736-160.426667-356.053333-357.418667-356.053333-72.704 0-140.202667 22.016-196.650667 59.306667L228.949333 129.664C307.968 71.466667 405.333333 36.650667 511.018667 36.650667c263.296 0 476.757333 213.461333 476.757333 476.714667C987.776 619.093333 952.96 716.416 894.72 795.477333zM369.493333 476.117333c-0.042667 0.597333-37.248 37.248-37.248 37.248l-178.773333 0c0 197.461333 160.085333 357.546667 357.546667 357.546667 72.192 0 139.093333-21.76 195.285333-58.538667l85.589333 85.589333c-78.848 57.685333-175.701333 92.117333-280.874667 92.117333-263.296 0-476.757333-213.461333-476.757333-476.757333 0-105.173333 34.474667-202.069333 92.16-280.874667l85.589333 85.589333C211.925333 318.208 211.882667 318.336 211.797333 318.464L369.493333 476.117333z\" p-id=\"4737\"></path></svg>\n      </a>\n      <a class=\"has_tip centerWrap_top_btn\" data-tip=\"${lang.transl('_github')}\" href=\"https://github.com/xuejianxianzun/PixivBatchDownloader\" target=\"_blank\">\n      <svg t=\"1574401005111\" class=\"icon\" widht=\"16\" height=\"16\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"2594\" xmlns:xlink=\"http://www.w3.org/1999/xlink><defs><style type=\"text/css\"></style></defs><path d=\"M0 520.886c0-69.368 13.51-135.697 40.498-199.02 26.987-63.323 63.322-117.826 109.006-163.51 45.65-45.65 100.154-81.985 163.51-109.006A502.289 502.289 0 0 1 512 8.92c69.335 0 135.663 13.477 198.986 40.497 63.356 26.988 117.86 63.323 163.51 109.007 45.684 45.65 82.02 100.154 109.006 163.51A502.289 502.289 0 0 1 1024 520.852c0 111.318-32.504 211.472-97.511 300.494-64.975 88.989-148.48 150.825-250.484 185.476-5.351 0-9.348-0.99-11.99-2.973-2.676-1.982-4.196-3.997-4.526-6.012a59.458 59.458 0 0 1-0.495-8.984 7.663 7.663 0 0 1-0.991-3.006v-128.99c0-40.63-14.336-75.314-43.008-103.986 76.667-13.345 134.011-41.819 171.999-85.487 37.987-43.669 57.013-96.52 57.013-158.522 0-58.005-18.663-108.346-56.022-150.99 13.345-42.678 11-87.668-6.97-135.003-18.697-1.322-39.011 1.85-61.01 9.513-22 7.663-38.318 14.831-49.02 21.47-10.637 6.673-20.316 13.016-28.97 19.027-38.68-10.669-81.854-16.02-129.486-16.02-47.7 0-90.509 5.351-128.529 16.02-7.333-5.35-15.855-11.164-25.5-17.507-9.68-6.342-26.493-14.005-50.507-22.99-23.982-9.018-45.65-12.85-65.008-11.495-18.663 47.996-20.645 93.646-5.979 136.984-36.665 42.678-54.998 92.986-54.998 150.99 0 62.002 18.663 114.689 55.99 157.994 37.326 43.339 94.67 72.01 171.998 86.016a142.303 142.303 0 0 0-39.969 70.029c-56.683 13.972-96.355 3.963-119.015-30.06-42.017-61.308-79.674-83.307-113.003-65.965-4.69 4.657-3.997 9.48 1.982 14.501 6.012 4.988 14.996 11.66 27.02 19.985 11.99 8.357 20.976 17.507 26.987 27.515 0.661 1.322 2.51 6.177 5.517 14.502a831.917 831.917 0 0 0 8.985 23.981c2.973 7.663 8.654 16.186 17.011 25.5 8.324 9.349 18.003 17.178 29.003 23.52 11 6.309 26.161 11 45.485 14.006 19.324 2.972 41.323 3.138 65.998 0.495v100.484c0 0.991-0.165 2.643-0.495 5.021-0.33 2.312-0.991 3.964-1.982 4.955-0.991 1.024-2.345 2.015-4.03 3.039a12.52 12.52 0 0 1-6.474 1.486c-2.676 0-6.012-0.33-10.009-0.99-101.343-35.345-183.825-97.182-247.51-185.51C31.842 731.037 0 631.577 0 520.92z\" p-id=\"2595\"></path></svg>\n      </a>\n      <a class=\"has_tip centerWrap_top_btn wiki_url\" data-tip=\"${lang.transl('_wiki')}\" href=\"https://github.com/xuejianxianzun/PixivBatchDownloader/wiki\" target=\"_blank\">\n      <svg t=\"1574400169015\" class=\"icon\" widht=\"16\" height=\"16\" viewBox=\"0 0 1088 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1872\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"17\" height=\"16\"><defs><style type=\"text/css\"></style></defs><path d=\"M1044.286732 3.51978A1138.616836 1138.616836 0 0 0 618.841322 58.172364a198.963565 198.963565 0 0 0-26.814324 10.815324V1023.936004l0.895944-0.383976a979.52278 979.52278 0 0 1 443.236298-68.411724 47.741016 47.741016 0 0 0 51.580776-43.261296V50.172864a47.165052 47.165052 0 0 0-43.453284-46.653084z m-74.299356 632.15249h-224.369977V541.470158h224.369977v94.202112z m0-231.921504h-224.369977V309.484657h224.369977v94.266109zM469.154678 58.172364A1138.296856 1138.296856 0 0 0 43.645272 3.455784 47.421036 47.421036 0 0 0 0 50.172864V908.103244a46.653084 46.653084 0 0 0 15.35904 34.493844 48.060996 48.060996 0 0 0 36.285732 12.415224 980.610712 980.610712 0 0 1 443.300294 68.347728l0.895944 0.575964V68.7957a202.099369 202.099369 0 0 0-26.686332-10.751328zM351.146053 635.800262H126.776076V541.59815h224.369977v94.202112z m0-231.921504H126.776076V309.612649h224.369977v94.266109z\" p-id=\"1873\"></path></svg>\n      </a>\n        <div class=\"has_tip centerWrap_top_btn centerWrap_close\" data-tip=\"${lang.transl('_快捷键切换显示隐藏')}\">\n        <svg t=\"1574392276519\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"1123\" data-spm-anchor-id=\"a313x.7781069.0.i0\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"14\" height=\"14\"><defs><style type=\"text/css\"></style></defs><path d=\"M521.693867 449.297067L111.4112 39.0144a51.2 51.2 0 1 0-72.430933 72.362667l410.282666 410.3168-410.282666 410.3168a51.2 51.2 0 1 0 72.3968 72.3968l410.3168-410.282667 410.3168 410.282667a51.2 51.2 0 1 0 72.3968-72.362667l-410.282667-410.350933 410.282667-410.282667a51.2 51.2 0 1 0-72.3968-72.3968l-410.282667 410.282667z\" p-id=\"1124\"></path></svg>\n        </div>\n      </div>\n      </div>\n\n      <div class=\"centerWrap_con\">\n      <slot data-name=\"form\"></slot>\n      </div>\n\n      <div class=\"gray1 bottom_help_bar\"> \n      <a href=\"javascript:void()\" class=\"showDownTip\">${lang.transl('_常见问题')}</a>\n      <a class=\"wiki2\" href=\"https://github.com/xuejianxianzun/PixivBatchDownloader/wiki\" target=\"_blank\"> ${lang.transl('_wiki')}</a>\n      <span id=\"resetOption\">${lang.transl('_重置设置')}</span>\n      <a class=\"gray1\" href=\"https://github.com/xuejianxianzun/PixivFanboxDownloader\" target=\"_blank\"> ${lang.transl('_fanboxDownloader')}</a>\n      <a id=\"zanzhu\" class=\"wiki2 patronText\" href=\"https://afdian.net/@xuejianxianzun\" target=\"_blank\">通过“爱发电”网站支持我</a>\n      <a id=\"patreon\" class=\"wiki2 patronText\" href=\"https://www.patreon.com/xuejianxianzun\" target=\"_blank\">Become a patron</a>\n      <a class=\"gray1\" href=\"https://discord.gg/eW9JtTK\" target=\"_blank\">Discord</a>\n      <br>\n      <p class=\"downTip tip\"> ${lang.transl('_下载说明')}</p>\n      </div>\n\n      </div>\n      `;\r\n        document.body.insertAdjacentHTML('beforeend', centerPanelHTML);\r\n        this.centerPanel = document.querySelector('.centerWrap');\r\n        themeColor.register(this.centerPanel);\r\n        this.updateLink = this.centerPanel.querySelector('.update');\r\n        const userLang = document.documentElement.lang;\r\n        const donateId = ['zh', 'zh-CN', 'zh-Hans'].includes(userLang)\r\n            ? 'zanzhu'\r\n            : 'patreon';\r\n        document.getElementById(donateId).style.display = 'inline-block';\r\n    }\r\n    // 绑定中间面板上的事件\r\n    bindEvents() {\r\n        // 监听点击扩展图标的消息，开关中间面板\r\n        chrome.runtime.onMessage.addListener((msg) => {\r\n            if (msg.msg === 'click_icon') {\r\n                if (this.centerPanel.style.display === 'block') {\r\n                    this.close();\r\n                }\r\n                else {\r\n                    this.show();\r\n                }\r\n            }\r\n        });\r\n        // 关闭按钮\r\n        document\r\n            .querySelector('.centerWrap_close')\r\n            .addEventListener('click', () => {\r\n            this.close();\r\n        });\r\n        // 使用快捷键 Alt + x 切换中间面板显示隐藏\r\n        window.addEventListener('keydown', (ev) => {\r\n            if (ev.altKey && ev.keyCode === 88) {\r\n                const nowDisplay = this.centerPanel.style.display;\r\n                if (nowDisplay === 'block') {\r\n                    this.close();\r\n                }\r\n                else {\r\n                    this.show();\r\n                }\r\n            }\r\n        }, false);\r\n        // 点击右侧图标时，显示\r\n        window.addEventListener(EVT.events.clickRightIcon, () => {\r\n            this.show();\r\n        });\r\n        // 开始抓取作品时，隐藏\r\n        window.addEventListener(EVT.events.crawlStart, () => {\r\n            this.close();\r\n        });\r\n        // 抓取完作品详细数据时，显示\r\n        window.addEventListener(EVT.events.crawlFinish, () => {\r\n            if (!store.states.quickDownload && !store.states.notAutoDownload) {\r\n                this.show();\r\n            }\r\n        });\r\n        // 显示更新按钮\r\n        window.addEventListener(EVT.events.hasNewVer, () => {\r\n            this.updateLink.classList.add(this.updateActiveClass);\r\n            this.updateLink.style.display = 'inline-block';\r\n        });\r\n        // 显示常见问题\r\n        document\r\n            .querySelector('.showDownTip')\r\n            .addEventListener('click', () => DOM.toggleEl(document.querySelector('.downTip')));\r\n        // 重置设置\r\n        document.getElementById('resetOption').addEventListener('click', () => {\r\n            const result = window.confirm(lang.transl('_是否重置设置'));\r\n            if (result) {\r\n                EVT.fire(EVT.events.resetOption);\r\n            }\r\n        });\r\n    }\r\n    // 显示中间区域\r\n    show() {\r\n        this.centerPanel.style.display = 'block';\r\n        EVT.fire(EVT.events.showCenterPanel);\r\n    }\r\n    // 隐藏中间区域\r\n    close() {\r\n        this.centerPanel.style.display = 'none';\r\n        EVT.fire(EVT.events.hideCenterPanel);\r\n    }\r\n}\r\nconst centerPanel = new CenterPanel();\r\nexport { centerPanel };\r\n","// 颜色\r\nclass Colors {\r\n}\r\nColors.blue = '#0ea8ef';\r\nColors.green = '#14ad27';\r\nColors.red = '#f33939';\r\nColors.yellow = '#e49d00';\r\nexport { Colors };\r\n","// 存放全局常量。运行过程中不会被修改的值。\r\nexport default {\r\n    outputMax: 5000,\r\n    latestReleaseAPI: 'https://api.github.com/repos/xuejianxianzun/PixivBatchDownloader/releases/latest',\r\n};\r\n","// 转换动图\r\nimport { EVT } from './EVT';\r\nclass ConvertUgoira {\r\n    constructor() {\r\n        this.gifWorkerUrl = '';\r\n        this.downloading = true; // 是否在下载。如果下载停止了则不继续转换后续任务，避免浪费资源\r\n        this.count = 0; // 统计有几个转换任务\r\n        this.maxCount = 1; // 允许同时运行多少个转换任务\r\n        this.loadWorkerJS();\r\n        window.addEventListener(EVT.events.downloadStart, () => {\r\n            this.downloading = true;\r\n        });\r\n        [EVT.events.downloadPause, EVT.events.downloadStop].forEach((event) => {\r\n            window.addEventListener(event, () => {\r\n                this.downloading = false;\r\n            });\r\n        });\r\n        window.addEventListener(EVT.events.settingChange, (ev) => {\r\n            const data = ev.detail.data;\r\n            if (data.name === 'convertUgoiraThread') {\r\n                this.maxCount = parseInt(data.value) || 1;\r\n            }\r\n        });\r\n        window.addEventListener(EVT.events.convertError, () => {\r\n            this.complete();\r\n        });\r\n    }\r\n    set setCount(num) {\r\n        this.count = num;\r\n        EVT.fire(EVT.events.convertChange, this.count);\r\n    }\r\n    async loadWorkerJS() {\r\n        if ('zip' in window === false) {\r\n            return;\r\n        }\r\n        // 添加 zip 的 worker 文件\r\n        let zipWorker = await fetch(chrome.extension.getURL('lib/z-worker.js'));\r\n        const zipWorkerBolb = await zipWorker.blob();\r\n        const zipWorkerUrl = URL.createObjectURL(zipWorkerBolb);\r\n        zip.workerScripts = {\r\n            inflater: [zipWorkerUrl],\r\n        };\r\n        // 添加 gif 的 worker 文件\r\n        let gifWorker = await fetch(chrome.extension.getURL('lib/gif.worker.js'));\r\n        const gifWorkerBolb = await gifWorker.blob();\r\n        this.gifWorkerUrl = URL.createObjectURL(gifWorkerBolb);\r\n    }\r\n    // 解压 zip 文件\r\n    async readZip(zipFile, ugoiraInfo) {\r\n        return new Promise(function (resolve, reject) {\r\n            zip.createReader(new zip.BlobReader(zipFile), (zipReader) => {\r\n                // 读取成功时的回调函数，files 保存了文件列表的信息\r\n                zipReader.getEntries((files) => {\r\n                    // 创建数组，长度与文件数量一致\r\n                    const imgFile = new Array(files.length);\r\n                    // 获取每个文件的数据。因为这个操作是异步的，所以必须检查图片数量\r\n                    files.forEach((file) => {\r\n                        file.getData(new zip.Data64URIWriter(ugoiraInfo.mime_type), (data) => {\r\n                            const fileNo = parseInt(file.filename);\r\n                            imgFile[fileNo] = data;\r\n                            // 把图片按原编号存入对应的位置。这是因为我怀疑有时候 zip.Data64URIWriter 的回调顺序不一致，直接 push 可能导致图片的顺序乱掉\r\n                            for (let i = 0; i < imgFile.length; i++) {\r\n                                // 检测到空值说明没有添加完毕，退出循环\r\n                                if (!imgFile[i]) {\r\n                                    break;\r\n                                }\r\n                                // 如果检查到最后一项，说明添加完毕\r\n                                if (i === imgFile.length - 1) {\r\n                                    resolve(imgFile);\r\n                                }\r\n                            }\r\n                        });\r\n                    });\r\n                });\r\n            }, (message) => {\r\n                EVT.fire(EVT.events.convertError);\r\n                reject(new Error('ReadZIP error: ' + message));\r\n            });\r\n        });\r\n    }\r\n    // 添加每一帧的数据\r\n    async getFrameData(imgFile, type = 'webm') {\r\n        const resultList = new Array(imgFile.length);\r\n        return new Promise(function (resolve, reject) {\r\n            const drawImg = function (index) {\r\n                const img = new Image();\r\n                img.onload = function (event) {\r\n                    // 处理视频\r\n                    if (type === 'webm') {\r\n                        const canvasEl = document.createElement('canvas');\r\n                        const ctx = canvasEl.getContext('2d');\r\n                        canvasEl.width = img.width;\r\n                        canvasEl.height = img.height;\r\n                        ctx.drawImage(img, 0, 0);\r\n                        resultList[index] = canvasEl;\r\n                    }\r\n                    // 处理 gif\r\n                    if (type === 'gif') {\r\n                        resultList[index] = img;\r\n                    }\r\n                    // 继续下一个\r\n                    if (index < imgFile.length - 1) {\r\n                        index++;\r\n                        drawImg(index);\r\n                    }\r\n                    else {\r\n                        resolve(resultList);\r\n                    }\r\n                };\r\n                img.src = imgFile[index];\r\n            };\r\n            // onload 完成时的顺序和添加事件时的顺序不一致，为了避免图片顺序乱掉，这里逐个添加每个图片\r\n            drawImg(0);\r\n        });\r\n    }\r\n    // 编码视频\r\n    async encodeVideo(encoder) {\r\n        return new Promise(function (resolve, reject) {\r\n            encoder.compile(false, function (video) {\r\n                resolve(video);\r\n            });\r\n        });\r\n    }\r\n    // 开始转换，这一步主要是解压文件\r\n    async start(file, info) {\r\n        return new Promise(async (resolve, reject) => {\r\n            const t = window.setInterval(async () => {\r\n                if (this.count < this.maxCount) {\r\n                    window.clearInterval(t);\r\n                    if (!this.downloading) {\r\n                        return;\r\n                    }\r\n                    this.setCount = this.count + 1;\r\n                    // 将压缩包里的图片转换为 base64 字符串\r\n                    await this.readZip(file, info)\r\n                        .then((data) => {\r\n                        resolve(data);\r\n                    })\r\n                        .catch(() => {\r\n                        reject(new Error('readZip error'));\r\n                    });\r\n                }\r\n            }, 200);\r\n        });\r\n    }\r\n    complete() {\r\n        this.setCount = this.count - 1;\r\n    }\r\n    // 转换成 webm\r\n    async webm(file, info) {\r\n        return new Promise(async (resolve, reject) => {\r\n            // 创建视频编码器\r\n            const encoder = new Whammy.Video();\r\n            // 获取解压后的图片数据\r\n            let base64Arr = await this.start(file, info).catch(() => {\r\n                reject(new Error('Start error'));\r\n            });\r\n            if (!base64Arr) {\r\n                return;\r\n            }\r\n            // 生成每一帧的数据\r\n            let canvasData = await this.getFrameData(base64Arr);\r\n            // 添加帧数据\r\n            for (let index = 0; index < canvasData.length; index++) {\r\n                const base64 = canvasData[index];\r\n                encoder.add(base64, info.frames[index].delay);\r\n            }\r\n            base64Arr = null;\r\n            canvasData = null;\r\n            // 获取生成的视频\r\n            file = (await this.encodeVideo(encoder));\r\n            this.complete();\r\n            resolve(file);\r\n        });\r\n    }\r\n    // 转换成 gif\r\n    async gif(file, info) {\r\n        return new Promise(async (resolve, reject) => {\r\n            // 配置 gif.js\r\n            let gif = new GIF({\r\n                workers: 4,\r\n                quality: 10,\r\n                workerScript: this.gifWorkerUrl,\r\n            });\r\n            // 绑定渲染完成事件\r\n            gif.on('finished', (file) => {\r\n                this.complete();\r\n                resolve(file);\r\n            });\r\n            // 获取解压后的图片数据\r\n            let base64Arr = await this.start(file, info).catch(() => {\r\n                reject(new Error('Start error'));\r\n            });\r\n            if (!base64Arr) {\r\n                return;\r\n            }\r\n            // 生成每一帧的数据\r\n            let imgData = await this.getFrameData(base64Arr, 'gif');\r\n            // 添加帧数据\r\n            for (let index = 0; index < imgData.length; index++) {\r\n                gif.addFrame(imgData[index], {\r\n                    delay: info.frames[index].delay,\r\n                });\r\n            }\r\n            base64Arr = null;\r\n            imgData = null;\r\n            // 渲染 gif\r\n            gif.render();\r\n        });\r\n    }\r\n}\r\nconst converter = new ConvertUgoira();\r\nexport { converter };\r\n","// DOM 操作类\r\n// 保存公用的 DOM 操作方法，以及从 DOM 中获取数据的 API\r\nclass DOM {\r\n    // 获取指定元素里，可见的结果\r\n    static getVisibleEl(selector) {\r\n        const list = document.querySelectorAll(selector);\r\n        return Array.from(list).filter((el) => {\r\n            return el.style.display !== 'none';\r\n        });\r\n    }\r\n    // 删除 DOM 元素\r\n    static removeEl(el) {\r\n        if (!el) {\r\n            return;\r\n        }\r\n        if (Reflect.has(el, 'length')) {\r\n            // 如果有 length 属性则循环删除。\r\n            ;\r\n            el.forEach((el) => {\r\n                if (el.parentNode) {\r\n                    el.parentNode.removeChild(el);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            // 没有 length 属性的直接删除（querySelector 的返回值是 HTMLElement）\r\n            const parent = el.parentNode;\r\n            if (parent) {\r\n                parent.removeChild(el);\r\n            }\r\n        }\r\n    }\r\n    // 切换 DOM 元素的可见性\r\n    static toggleEl(el) {\r\n        el.style.display = el.style.display === 'block' ? 'none' : 'block';\r\n    }\r\n    // 将元素插入到页面顶部\r\n    /*\r\n    newindex-inner 是在未登录时的用户作品列表页面使用的\r\n    layout-body 是在未登录时的搜索页使用的\r\n    */\r\n    static insertToHead(el) {\r\n        if (document.body) {\r\n            document.body.insertAdjacentElement('afterbegin', el);\r\n        }\r\n        else {\r\n            ;\r\n            (document.querySelector('.newindex-inner') ||\r\n                document.querySelector('.layout-body')).insertAdjacentElement('beforebegin', el);\r\n        }\r\n        return el;\r\n    }\r\n    // 动态添加 css 样式\r\n    static addStyle(css) {\r\n        const e = document.createElement('style');\r\n        e.innerHTML = css;\r\n        document.body.append(e);\r\n    }\r\n    // 通过创建 a 标签来下载文件\r\n    static downloadFile(url, fileName) {\r\n        const a = document.createElement('a');\r\n        a.href = url;\r\n        a.download = fileName;\r\n        a.click();\r\n    }\r\n    // 获取用户 id\r\n    // 这是一个不够可靠的 api\r\n    // 测试：在 https://www.pixiv.net/artworks/79399027 获取 userid ，正确的结果应该是 13895186\r\n    static getUserId() {\r\n        const newRegExp = /\\/users\\/(\\d+)/; // 获取 /users/ 后面连续的数字部分，也就是用户的 id\r\n        // 列表页里从 url 中获取\r\n        const test4 = newRegExp.exec(location.pathname);\r\n        if (!!test4 && test4.length > 1 && !!test4[1]) {\r\n            return test4[1];\r\n        }\r\n        // 获取包含用户 id 的元素，注意这些选择器可能会变，需要进行检查\r\n        const testA = document.querySelector('.sc-LzOjP a') ||\r\n            document.querySelector('aside a') ||\r\n            document.querySelector('nav a');\r\n        // 第一个元素是作品页内，作品下方的作者头像区域的 a 标签\r\n        // 第一个元素是作品页内，页面右侧作者信息区域的 a 标签\r\n        // 第二个元素是用户主页或列表页里，“主页”按钮的 a 标签\r\n        if (testA && testA.href) {\r\n            const test5 = newRegExp.exec(testA.href);\r\n            if (!!test5 && test5.length > 1 && !!test5[1]) {\r\n                return test5[1];\r\n            }\r\n        }\r\n        // 从旧版页面的 head 元素的 script 脚本内容里匹配这一部分\r\n        // pixiv.context.user.id = \"<userid>\"\r\n        const test1 = /user.id = \"(\\d*)\"/.exec(document.head.innerHTML);\r\n        if (test1 && test1.length > 0) {\r\n            return test1[1];\r\n        }\r\n        // 从旧版页面的 head 元素的 script 脚本内容里匹配这一部分\r\n        // pixiv.context.userId = \"<userid>\"\r\n        const test2 = /userId = \"(\\d*)\"/.exec(document.head.innerHTML);\r\n        if (test2 && test2.length > 0) {\r\n            return test2[1];\r\n        }\r\n        // 最后从 body 里匹配\r\n        // Warning ：这有可能会匹配到错误的（其他）用户 id！\r\n        const test3 = newRegExp.exec(document.body.innerHTML);\r\n        if (test3) {\r\n            return test3[1];\r\n        }\r\n        // 如果都没有获取到\r\n        throw new Error('getUserId failed!');\r\n    }\r\n    // 寻找 slot，本程序使用的 slot 都要有 data-name 属性\r\n    static findSlot(name) {\r\n        const slot = document.querySelector(`slot[data-name=${name}]`);\r\n        if (!slot) {\r\n            throw new Error(`No such slot: ${name}`);\r\n        }\r\n        return slot;\r\n    }\r\n    // 使用指定的插槽\r\n    static useSlot(name, element) {\r\n        const slot = this.findSlot(name);\r\n        if (typeof element === 'string') {\r\n            // 插入字符串形式的元素\r\n            const wrap = document.createElement('div');\r\n            wrap.innerHTML = element;\r\n            const el = wrap.children[0];\r\n            slot.appendChild(el);\r\n            return el;\r\n        }\r\n        else {\r\n            // 插入 html 元素\r\n            slot.appendChild(element);\r\n            return element;\r\n        }\r\n    }\r\n    // 清空指定的插槽\r\n    static clearSlot(name) {\r\n        this.findSlot(name).innerHTML = '';\r\n    }\r\n    static addBtn(slot, bg = '', text = '', attr = []) {\r\n        const e = document.createElement('button');\r\n        e.type = 'button';\r\n        e.style.backgroundColor = bg;\r\n        e.textContent = text;\r\n        for (const [key, value] of attr) {\r\n            e.setAttribute(key, value);\r\n        }\r\n        this.useSlot(slot, e);\r\n        return e;\r\n    }\r\n}\r\nexport { DOM };\r\n","import { EVT } from './EVT';\r\nimport { lang } from './Lang';\r\nimport { form } from './Settings';\r\nimport { IndexedDB } from './IndexedDB';\r\nimport { store } from './Store';\r\nimport { fileName } from './FileName';\r\n// 去重\r\n// 通过保存和查询下载记录，判断重复文件\r\nclass Deduplication {\r\n    constructor() {\r\n        this.DBName = 'DLRecord';\r\n        this.DBVer = 1;\r\n        this.storeNameList = [\r\n            'record1',\r\n            'record2',\r\n            'record3',\r\n            'record4',\r\n            'record5',\r\n            'record6',\r\n            'record7',\r\n            'record8',\r\n            'record9',\r\n        ]; // 表名的列表\r\n        this.skipIdList = []; // 被跳过下载的文件的 id。当收到下载成功事件时，根据这个 id 列表判断这个文件是不是真的被下载了。如果这个文件是被跳过的，则不保存到下载记录里。\r\n        this.existedIdList = []; // 检查文件是否重复时，会查询数据库。查询到的数据的 id 会保存到这个列表里。当向数据库添加记录时，可以先查询这个列表，如果已经有过记录就改为 put 而不是 add，因为添加主键重复的数据会报错\r\n        this.IDB = new IndexedDB();\r\n        this.init();\r\n    }\r\n    async init() {\r\n        if (location.hostname.includes('pixivision.net')) {\r\n            return;\r\n        }\r\n        await this.initDB();\r\n        this.bindEvent();\r\n    }\r\n    // 初始化数据库，获取数据库对象\r\n    async initDB() {\r\n        // 在升级事件里创建表和索引\r\n        const onUpdate = (db) => {\r\n            for (const name of this.storeNameList) {\r\n                if (!db.objectStoreNames.contains(name)) {\r\n                    const store = db.createObjectStore(name, { keyPath: 'id' });\r\n                    store.createIndex('id', 'id', { unique: true });\r\n                }\r\n            }\r\n        };\r\n        return new Promise(async (resolve, reject) => {\r\n            resolve(await this.IDB.open(this.DBName, this.DBVer, onUpdate));\r\n        });\r\n    }\r\n    // 生成一个下载记录\r\n    createRecord(resultId) {\r\n        let name = form.userSetName.value;\r\n        // 查找这个抓取结果，获取其文件名\r\n        for (const result of store.result) {\r\n            if (result.id === resultId) {\r\n                name = fileName.getFileName(result);\r\n                break;\r\n            }\r\n        }\r\n        return {\r\n            id: resultId,\r\n            n: name,\r\n        };\r\n    }\r\n    // 当要查找或存储一个 id 时，返回它所对应的 storeName\r\n    getStoreName(id) {\r\n        const firstNum = parseInt(id[0]);\r\n        return this.storeNameList[firstNum - 1];\r\n    }\r\n    bindEvent() {\r\n        // 当有文件被跳过时，保存到 skipIdList\r\n        window.addEventListener(EVT.events.skipSaveFile, (ev) => {\r\n            const data = ev.detail.data;\r\n            this.skipIdList.push(data.id);\r\n        });\r\n        // 当有文件下载完成时，存储这个任务的记录\r\n        window.addEventListener(EVT.events.downloadSucccess, (ev) => {\r\n            const successData = ev.detail.data;\r\n            // 不储存被跳过下载的文件\r\n            if (this.skipIdList.includes(successData.id)) {\r\n                return;\r\n            }\r\n            const data = this.createRecord(successData.id);\r\n            if (this.existedIdList.includes(successData.id)) {\r\n                this.IDB.put(this.getStoreName(successData.id), data);\r\n            }\r\n            else {\r\n                this.IDB.add(this.getStoreName(successData.id), data).catch(() => {\r\n                    this.IDB.put(this.getStoreName(successData.id), data);\r\n                });\r\n            }\r\n        });\r\n        [EVT.events.crawlFinish, EVT.events.downloadComplete].forEach((val) => {\r\n            window.addEventListener(val, () => {\r\n                this.skipIdList = [];\r\n            });\r\n        });\r\n        // 给“清空下载记录”的按钮绑定事件\r\n        const btn = document.querySelector('#clearDownloadRecords');\r\n        if (btn) {\r\n            btn.addEventListener('click', () => {\r\n                EVT.fire(EVT.events.clearDownloadRecords);\r\n            });\r\n        }\r\n        // 监听清空下载记录的事件\r\n        window.addEventListener(EVT.events.clearDownloadRecords, () => {\r\n            // 清空下载记录\r\n            this.clearRecords();\r\n            // 清空 duplicateList\r\n            this.existedIdList = [];\r\n        });\r\n    }\r\n    // 检查一个 id 是否是重复下载\r\n    // 返回值 true 表示重复，false 表示不重复\r\n    async check(resultId) {\r\n        return new Promise(async (resolve, reject) => {\r\n            // 如果未启用去重，直接返回不重复\r\n            if (form.deduplication.checked === false) {\r\n                resolve(false);\r\n            }\r\n            // 在数据库进行查找\r\n            const storeNmae = this.getStoreName(resultId);\r\n            const data = (await this.IDB.get(storeNmae, resultId));\r\n            // 查询结果为空，返回不重复\r\n            if (data === null) {\r\n                resolve(false);\r\n            }\r\n            else {\r\n                this.existedIdList.push(data.id);\r\n                // 查询到了对应的记录，根据策略进行判断\r\n                if (form.dupliStrategy.value === 'loose') {\r\n                    // 如果是宽松策略（只考虑 id），返回重复\r\n                    resolve(true);\r\n                }\r\n                else {\r\n                    // 如果是严格策略（同时考虑 id 和文件名），则比较文件名\r\n                    const record = this.createRecord(resultId);\r\n                    resolve(record.n === data.n);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    // 清空下载记录\r\n    clearRecords() {\r\n        for (const name of this.storeNameList) {\r\n            this.IDB.clear(name);\r\n        }\r\n        window.alert(lang.transl('_下载记录已清除'));\r\n    }\r\n}\r\nconst deduplication = new Deduplication();\r\nexport { deduplication };\r\n","// 删除页面上的作品\r\nimport { log } from './Log';\r\nimport { lang } from './Lang';\r\nimport { Colors } from './Colors';\r\nimport { DOM } from './DOM';\r\nimport { centerPanel } from './CenterPanel';\r\nimport { store } from './Store';\r\nimport { EVT } from './EVT';\r\nclass DeleteWorks {\r\n    constructor(worksSelectors) {\r\n        this.worksSelector = ''; // 选择页面上所有作品的选择器\r\n        this.multipleSelector = ''; // 多图作品特有的元素的标识\r\n        this.ugoiraSelector = ''; // 动图作品特有的元素的标识\r\n        this.delMode = false; // 是否处于删除作品状态\r\n        this.deleteWorkCallback = () => { }; // 保存手动删除作品的回调函数，因为可能会多次绑定手动删除事件，所以需要保存传入的 callback 备用\r\n        this.worksSelector = worksSelectors;\r\n        // 作品列表更新后，需要重新给作品绑定删除事件\r\n        window.addEventListener(EVT.events.worksUpdate, () => {\r\n            if (this.delMode) {\r\n                this.bindDeleteEvent();\r\n            }\r\n        });\r\n    }\r\n    allowWork() {\r\n        return store.states.allowWork;\r\n    }\r\n    // 清除多图作品的按钮\r\n    addClearMultipleBtn(selector, callback = () => { }) {\r\n        this.multipleSelector = selector;\r\n        DOM.addBtn('crawlBtns', Colors.red, lang.transl('_清除多图作品'), [\r\n            ['title', lang.transl('_清除多图作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            if (!this.allowWork()) {\r\n                return alert(lang.transl('_当前任务尚未完成'));\r\n            }\r\n            centerPanel.close();\r\n            this.clearMultiple();\r\n            callback();\r\n        }, false);\r\n    }\r\n    // 清除动图作品的按钮\r\n    addClearUgoiraBtn(selector, callback = () => { }) {\r\n        this.ugoiraSelector = selector;\r\n        DOM.addBtn('crawlBtns', Colors.red, lang.transl('_清除动图作品'), [\r\n            ['title', lang.transl('_清除动图作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            if (!this.allowWork()) {\r\n                return alert(lang.transl('_当前任务尚未完成'));\r\n            }\r\n            centerPanel.close();\r\n            this.ClearUgoira();\r\n            callback();\r\n        }, false);\r\n    }\r\n    // 手动删除作品的按钮\r\n    addManuallyDeleteBtn(callback = () => { }) {\r\n        this.deleteWorkCallback = callback;\r\n        const delBtn = DOM.addBtn('crawlBtns', Colors.red, lang.transl('_手动删除作品'), [['title', lang.transl('_手动删除作品Title')]]);\r\n        delBtn.addEventListener('click', () => {\r\n            this.delMode = !this.delMode;\r\n            this.bindDeleteEvent();\r\n            if (this.delMode) {\r\n                delBtn.textContent = lang.transl('_退出手动删除');\r\n                setTimeout(() => {\r\n                    centerPanel.close();\r\n                }, 300);\r\n            }\r\n            else {\r\n                delBtn.textContent = lang.transl('_手动删除作品');\r\n            }\r\n        });\r\n    }\r\n    // 清除多图作品\r\n    clearMultiple() {\r\n        const allPicArea = document.querySelectorAll(this.worksSelector);\r\n        allPicArea.forEach((el) => {\r\n            if (el.querySelector(this.multipleSelector)) {\r\n                el.remove();\r\n            }\r\n        });\r\n        this.showWorksCount();\r\n    }\r\n    // 清除动图作品\r\n    ClearUgoira() {\r\n        const allPicArea = document.querySelectorAll(this.worksSelector);\r\n        allPicArea.forEach((el) => {\r\n            if (el.querySelector(this.ugoiraSelector)) {\r\n                el.remove();\r\n            }\r\n        });\r\n        this.showWorksCount();\r\n    }\r\n    // 给作品绑定手动删除事件\r\n    // 删除作品后，回调函数可以接收到被删除的元素\r\n    bindDeleteEvent() {\r\n        const listElement = document.querySelectorAll(this.worksSelector);\r\n        listElement.forEach((el) => {\r\n            el.onclick = (ev) => {\r\n                if (this.delMode) {\r\n                    ev.preventDefault();\r\n                    if (!this.allowWork()) {\r\n                        return alert(lang.transl('_当前任务尚未完成'));\r\n                    }\r\n                    const target = ev.currentTarget;\r\n                    DOM.removeEl(target);\r\n                    this.showWorksCount();\r\n                    this.deleteWorkCallback(target);\r\n                }\r\n            };\r\n        });\r\n    }\r\n    // 显示调整后，列表里的作品数量\r\n    showWorksCount() {\r\n        const selector = this.worksSelector;\r\n        log.success(lang.transl('_调整完毕', DOM.getVisibleEl(selector).length.toString()), 2, false);\r\n    }\r\n}\r\nexport { DeleteWorks };\r\n","// 下载文件，并发送给浏览器下载\r\nimport { EVT } from './EVT';\r\nimport { log } from './Log';\r\nimport { lang } from './Lang';\r\nimport { titleBar } from './TitleBar';\r\nimport { fileName } from './FileName';\r\nimport { converter } from './ConvertUgoira';\r\nimport { progressBar } from './ProgressBar';\r\nimport { filter } from './Filter';\r\nimport { deduplication } from './Deduplication';\r\nclass Download {\r\n    constructor(progressBarIndex, data) {\r\n        this.fileName = '';\r\n        this.retry = 0;\r\n        this.retryMax = 30;\r\n        this.cancel = false; // 这个下载被取消（任务停止，或者没有通过某个检查）\r\n        this.sizeCheck = undefined; // 检查文件体积\r\n        this.progressBarIndex = progressBarIndex;\r\n        this.download(data);\r\n        this.listenEvents();\r\n    }\r\n    listenEvents() {\r\n        ;\r\n        [EVT.events.downloadStop, EVT.events.downloadPause].forEach((event) => {\r\n            window.addEventListener(event, () => {\r\n                this.cancel = true;\r\n            });\r\n        });\r\n    }\r\n    // 设置进度条信息\r\n    setProgressBar(loaded, total) {\r\n        progressBar.setProgress(this.progressBarIndex, {\r\n            name: this.fileName,\r\n            loaded: loaded,\r\n            total: total,\r\n        });\r\n    }\r\n    skip(data, msg = '') {\r\n        this.cancel = true;\r\n        EVT.fire(EVT.events.skipSaveFile, data);\r\n        log.warning(msg);\r\n    }\r\n    // 下载文件\r\n    async download(arg) {\r\n        titleBar.change('↓');\r\n        // 检查是否是重复文件\r\n        const duplicate = await deduplication.check(arg.id);\r\n        if (duplicate) {\r\n            return this.skip({\r\n                url: '',\r\n                id: arg.id,\r\n                tabId: 0,\r\n                uuid: false,\r\n            }, lang.transl('_跳过下载因为重复文件', arg.id));\r\n        }\r\n        // 获取文件名\r\n        this.fileName = fileName.getFileName(arg.data);\r\n        // 重设当前下载栏的信息\r\n        this.setProgressBar(0, 0);\r\n        // 下载文件\r\n        let xhr = new XMLHttpRequest();\r\n        xhr.open('GET', arg.data.url, true);\r\n        xhr.responseType = 'blob';\r\n        // 显示下载进度\r\n        xhr.addEventListener('progress', async (event) => {\r\n            // 检查体积设置\r\n            if (this.sizeCheck === undefined) {\r\n                this.sizeCheck = await filter.check({ size: event.total });\r\n                if (this.sizeCheck === false) {\r\n                    // 当因为体积问题跳过下载时，可能这个下载进度还是 0 或者很少，所以这里直接把进度条拉满\r\n                    this.setProgressBar(1, 1);\r\n                    this.skip({\r\n                        url: '',\r\n                        id: arg.id,\r\n                        tabId: 0,\r\n                        uuid: false,\r\n                    }, lang.transl('_不保存图片因为体积', arg.id));\r\n                }\r\n            }\r\n            if (this.cancel) {\r\n                xhr.abort();\r\n                xhr = null;\r\n                return;\r\n            }\r\n            this.setProgressBar(event.loaded, event.total);\r\n        });\r\n        // 图片获取完毕（出错时也会进入 loadend）\r\n        xhr.addEventListener('loadend', async () => {\r\n            if (this.cancel) {\r\n                xhr = null;\r\n                return;\r\n            }\r\n            let file = xhr.response; // 要下载的文件\r\n            // 错误处理\r\n            const downloadError = () => {\r\n                let msg = '';\r\n                if (xhr.status === 404) {\r\n                    // 404 错误时\r\n                    msg = lang.transl('_file404', arg.id);\r\n                }\r\n                else {\r\n                    // 无法处理的错误状态\r\n                    msg = lang.transl('_文件下载失败', arg.id);\r\n                }\r\n                log.error(msg, 1);\r\n                this.cancel = true;\r\n                EVT.fire(EVT.events.downloadError, arg.id);\r\n            };\r\n            if (xhr.status !== 200) {\r\n                // 状态码错误\r\n                // 正常下载完毕的状态码是 200\r\n                // 处理小说恢复后下载出错的问题，重新生成小说的 url\r\n                if (arg.data.type === 3 && xhr.status === 0) {\r\n                    arg.data.url = URL.createObjectURL(arg.data.novelBlob);\r\n                    return this.download(arg);\r\n                }\r\n                // 进入重试环节\r\n                progressBar.showErrorColor(this.progressBarIndex, true);\r\n                this.retry++;\r\n                if (this.retry >= this.retryMax) {\r\n                    // 重试 retryMax 次依然错误\r\n                    // console.log(arg.data.id + ' retryMax')\r\n                    downloadError();\r\n                }\r\n                else {\r\n                    return this.download(arg);\r\n                }\r\n            }\r\n            else {\r\n                // 状态码正常\r\n                progressBar.showErrorColor(this.progressBarIndex, false);\r\n                // 需要转换动图的情况\r\n                if ((arg.data.ext === 'webm' || arg.data.ext === 'gif') &&\r\n                    arg.data.ugoiraInfo) {\r\n                    try {\r\n                        // 需要转换成 webm 视频\r\n                        if (arg.data.ext === 'webm') {\r\n                            file = await converter.webm(file, arg.data.ugoiraInfo);\r\n                        }\r\n                        // 需要转换成 gif 动图\r\n                        if (arg.data.ext === 'gif') {\r\n                            file = await converter.gif(file, arg.data.ugoiraInfo);\r\n                        }\r\n                    }\r\n                    catch (error) {\r\n                        const msg = `Error: convert ugoira error, work id ${arg.data.idNum}.`;\r\n                        log.error(msg, 1);\r\n                        this.cancel = true;\r\n                        EVT.fire(EVT.events.downloadError, arg.id);\r\n                    }\r\n                }\r\n            }\r\n            if (this.cancel) {\r\n                return;\r\n            }\r\n            // 生成下载链接\r\n            const blobUrl = URL.createObjectURL(file);\r\n            // 检查图片的彩色、黑白设置\r\n            // 这里的检查，主要是因为抓取时只能检测第一张的缩略图，有些作品第一张图的颜色和后面不一样。例如某个作品第一张是彩色，后面是黑白；设置条件是只下载彩色。抓取时这个作品通过了检查，后面的黑白图片也会被下载。此时就需要在这里重新检查一次。\r\n            // 对插画、漫画进行检查。动图抓取时检查了第一张图，已经够了，这里不再检查\r\n            // 这里并没有让 filter 初始化，如果用户在抓取之后修改了彩色、黑白的设置，filter 不会响应变化。所以这里不检查第一张图，以避免无谓的检查。如果以后使 filter 在这里初始化了，那么第一张图也需要检查。\r\n            if ((arg.data.type === 0 || arg.data.type === 1) &&\r\n                !arg.data.id.includes('p0')) {\r\n                const result = await filter.check({\r\n                    mini: blobUrl,\r\n                });\r\n                if (!result) {\r\n                    return this.skip({\r\n                        url: blobUrl,\r\n                        id: arg.id,\r\n                        tabId: 0,\r\n                        uuid: false,\r\n                    }, lang.transl('_不保存图片因为颜色设置', arg.id));\r\n                }\r\n            }\r\n            // 向浏览器发送下载任务\r\n            this.browserDownload(blobUrl, this.fileName, arg.id, arg.taskBatch);\r\n            xhr = null;\r\n            file = null;\r\n        });\r\n        xhr.send();\r\n    }\r\n    // 向浏览器发送下载任务\r\n    browserDownload(blobUrl, fileName, id, taskBatch) {\r\n        // 如果任务已停止，不会向浏览器发送下载任务\r\n        if (this.cancel) {\r\n            // 释放 bloburl\r\n            URL.revokeObjectURL(blobUrl);\r\n            return;\r\n        }\r\n        const sendData = {\r\n            msg: 'send_download',\r\n            fileUrl: blobUrl,\r\n            fileName: fileName,\r\n            id,\r\n            taskBatch,\r\n        };\r\n        chrome.runtime.sendMessage(sendData);\r\n    }\r\n}\r\nexport { Download };\r\n","// 下载控制\r\nimport { EVT } from './EVT';\r\nimport { DOM } from './DOM';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nimport { lang } from './Lang';\r\nimport { titleBar } from './TitleBar';\r\nimport { Colors } from './Colors';\r\nimport { form } from './Settings';\r\nimport { Download } from './Download';\r\nimport { progressBar } from './ProgressBar';\r\nimport { downloadStates } from './DownloadStates';\r\nimport { resume } from './Resume';\r\nclass DownloadControl {\r\n    constructor() {\r\n        this.downloadThreadMax = 5; // 同时下载的线程数的最大值，也是默认值\r\n        this.downloadThread = this.downloadThreadMax; // 同时下载的线程数\r\n        this.taskBatch = 0; // 标记任务批次，每次重新下载时改变它的值，传递给后台使其知道这是一次新的下载\r\n        this.taskList = {}; // 下载任务列表，使用下载的文件的 id 做 key，保存下载栏编号和它在下载状态列表中的索引\r\n        this.errorIdList = []; // 有任务下载失败时，保存 id\r\n        this.downloaded = 0; // 已下载的任务数量\r\n        this.convertText = '';\r\n        this.reTryTimer = 0; // 重试下载的定时器\r\n        this.downloadArea = document.createElement('div'); // 下载区域\r\n        this.totalNumberEl = document.createElement('span');\r\n        this.downStatusEl = document.createElement('span');\r\n        this.convertTipEL = document.createElement('div'); // 转换动图时显示提示的元素\r\n        this.downloadStop = false; // 是否停止下载\r\n        this.downloadPause = false; // 是否暂停下载\r\n        this.createDownloadArea();\r\n        this.listenEvents();\r\n    }\r\n    // 返回任务停止状态。暂停和停止都视为停止下载\r\n    get downloadStopped() {\r\n        return this.downloadPause || this.downloadStop;\r\n    }\r\n    listenEvents() {\r\n        window.addEventListener(EVT.events.crawlStart, () => {\r\n            this.hideDownloadArea();\r\n            this.reset();\r\n        });\r\n        window.addEventListener(EVT.events.crawlFinish, () => {\r\n            this.showDownloadArea();\r\n            this.readyDownload();\r\n        });\r\n        window.addEventListener(EVT.events.skipSaveFile, (ev) => {\r\n            const data = ev.detail.data;\r\n            this.downloadSuccess(data);\r\n        });\r\n        window.addEventListener(EVT.events.downloadError, (ev) => {\r\n            const id = ev.detail.data;\r\n            this.downloadError(id);\r\n        });\r\n        window.addEventListener(EVT.events.convertChange, (ev) => {\r\n            const count = ev.detail.data;\r\n            if (count > 0) {\r\n                this.convertText = lang.transl('_转换任务提示', count.toString());\r\n            }\r\n            else {\r\n                this.convertText = '';\r\n            }\r\n            this.convertTipEL.innerHTML = this.convertText;\r\n            this.LogDownloadStates();\r\n        });\r\n        // 监听浏览器下载文件后，返回的消息\r\n        chrome.runtime.onMessage.addListener((msg) => {\r\n            if (!this.taskBatch) {\r\n                return;\r\n            }\r\n            // 文件下载成功\r\n            if (msg.msg === 'downloaded') {\r\n                // 释放 BLOBURL\r\n                URL.revokeObjectURL(msg.data.url);\r\n                this.downloadSuccess(msg.data);\r\n            }\r\n            else if (msg.msg === 'download_err') {\r\n                // 浏览器把文件保存到本地时出错\r\n                log.error(`${msg.data.id} download error! code: ${msg.err}. The downloader will try to download the file again `);\r\n                EVT.fire(EVT.events.saveFileError);\r\n                // 重新下载这个文件\r\n                this.saveFileError(msg.data);\r\n            }\r\n            // UUID 的情况\r\n            if (msg.data && msg.data.uuid) {\r\n                log.error(lang.transl('_uuid'));\r\n            }\r\n        });\r\n    }\r\n    setDownloaded() {\r\n        this.downloaded = downloadStates.downloadedCount();\r\n        this.LogDownloadStates();\r\n        // 设置下载进度信息\r\n        progressBar.setTotalProgress(this.downloaded);\r\n        // 重置下载进度信息\r\n        if (this.downloaded === 0) {\r\n            this.setDownStateText(lang.transl('_未开始下载'));\r\n        }\r\n        // 所有文件正常下载完毕（跳过下载的文件也算正常下载）\r\n        if (this.downloaded === store.result.length) {\r\n            EVT.fire(EVT.events.downloadComplete);\r\n            this.reset();\r\n            this.setDownStateText(lang.transl('_下载完毕'));\r\n            log.success(lang.transl('_下载完毕'), 2);\r\n            titleBar.change('✓');\r\n        }\r\n        this.checkCompleteWithError();\r\n    }\r\n    // 如果带上下载出错的任务的话，是否已经完成了下载\r\n    checkCompleteWithError() {\r\n        // 在有文件下载失败的情况下完成了下载，则进入暂停状态\r\n        if (this.errorIdList.length > 0 &&\r\n            this.downloaded + this.errorIdList.length === store.result.length) {\r\n            this.pauseDownload();\r\n            // 一定时间后自动开始下载\r\n            setTimeout(() => {\r\n                this.startDownload();\r\n            }, 5000);\r\n        }\r\n    }\r\n    // 显示或隐藏下载区域\r\n    showDownloadArea() {\r\n        this.downloadArea.style.display = 'block';\r\n    }\r\n    hideDownloadArea() {\r\n        this.downloadArea.style.display = 'none';\r\n    }\r\n    // 设置下载状态文本，默认颜色为主题蓝色\r\n    setDownStateText(str, color = '') {\r\n        const el = document.createElement('span');\r\n        el.textContent = str;\r\n        if (color) {\r\n            el.style.color = color;\r\n        }\r\n        this.downStatusEl.innerHTML = '';\r\n        this.downStatusEl.appendChild(el);\r\n    }\r\n    reset() {\r\n        this.downloadPause = false;\r\n        this.downloadStop = false;\r\n        clearTimeout(this.reTryTimer);\r\n    }\r\n    createDownloadArea() {\r\n        const html = `<div class=\"download_area\">\n    <p> ${lang.transl('_共抓取到n个文件', '<span class=\"fwb blue imgNum\">0</span>')}</p>\n    \n    <div class=\"centerWrap_btns\">\n    <button class=\"startDownload\" type=\"button\" style=\"background:${Colors.blue};\"> ${lang.transl('_下载按钮1')}</button>\n    <button class=\"pauseDownload\" type=\"button\" style=\"background:#e49d00;\"> ${lang.transl('_下载按钮2')}</button>\n    <button class=\"stopDownload\" type=\"button\" style=\"background:${Colors.red};\"> ${lang.transl('_下载按钮3')}</button>\n    <button class=\"copyUrl\" type=\"button\" style=\"background:${Colors.green};\"> ${lang.transl('_复制url')}</button>\n    </div>\n    <div class=\"centerWrap_down_tips\">\n    <p>\n    <span>${lang.transl('_当前状态')}</span>\n    <span class=\"down_status blue\"><span>${lang.transl('_未开始下载')}</span></span>\n    <span class=\"convert_tip warn\"></span>\n    </p>\n    </div>\n    </div>`;\r\n        const el = DOM.useSlot('downloadArea', html);\r\n        this.downloadArea = el;\r\n        this.downStatusEl = el.querySelector('.down_status ');\r\n        this.convertTipEL = el.querySelector('.convert_tip');\r\n        this.totalNumberEl = el.querySelector('.imgNum');\r\n        document.querySelector('.startDownload').addEventListener('click', () => {\r\n            this.startDownload();\r\n        });\r\n        document.querySelector('.pauseDownload').addEventListener('click', () => {\r\n            this.pauseDownload();\r\n        });\r\n        document.querySelector('.stopDownload').addEventListener('click', () => {\r\n            this.stopDownload();\r\n        });\r\n        document.querySelector('.copyUrl').addEventListener('click', () => {\r\n            this.showURLs();\r\n        });\r\n    }\r\n    // 显示 url\r\n    showURLs() {\r\n        if (store.result.length === 0) {\r\n            return alert(lang.transl('_没有数据可供使用'));\r\n        }\r\n        let result = '';\r\n        result = store.result.reduce((total, now) => {\r\n            return (total += now.url + '<br>');\r\n        }, result);\r\n        EVT.fire(EVT.events.output, {\r\n            content: result,\r\n            title: lang.transl('_复制url'),\r\n        });\r\n    }\r\n    // 下载线程设置\r\n    setDownloadThread() {\r\n        const setThread = parseInt(form.downloadThread.value);\r\n        if (setThread < 1 ||\r\n            setThread > this.downloadThreadMax ||\r\n            isNaN(setThread)) {\r\n            // 如果数值非法，则重设为默认值\r\n            this.downloadThread = this.downloadThreadMax;\r\n        }\r\n        else {\r\n            this.downloadThread = setThread; // 设置为用户输入的值\r\n        }\r\n        // 如果剩余任务数量少于下载线程数\r\n        if (store.result.length - this.downloaded < this.downloadThread) {\r\n            this.downloadThread = store.result.length - this.downloaded;\r\n        }\r\n        // 重设下载进度条\r\n        progressBar.reset(this.downloadThread, this.downloaded);\r\n    }\r\n    // 抓取完毕之后，已经可以开始下载时，显示必要的信息，并决定是否立即开始下载\r\n    readyDownload() {\r\n        this.totalNumberEl.textContent = store.result.length.toString();\r\n        this.setDownloaded();\r\n        this.setDownloadThread();\r\n        // 检查 不自动开始下载 的标记\r\n        if (store.states.notAutoDownload) {\r\n            return;\r\n        }\r\n        const autoDownload = form.quietDownload.checked;\r\n        if (!autoDownload && !store.states.quickDownload) {\r\n            titleBar.change('▶');\r\n        }\r\n        // 视情况自动开始下载\r\n        if (autoDownload || store.states.quickDownload) {\r\n            this.startDownload();\r\n        }\r\n    }\r\n    // 开始下载\r\n    startDownload() {\r\n        // 如果正在下载中，或无结果，则不予处理\r\n        if (!store.states.allowWork || store.result.length === 0) {\r\n            return;\r\n        }\r\n        // 如果之前没有暂停任务，也没有进入恢复模式，则重新下载\r\n        if (!this.downloadPause && !resume.flag) {\r\n            // 初始化下载状态列表\r\n            downloadStates.initList();\r\n        }\r\n        else {\r\n            // 从上次中断的位置继续下载\r\n            // 把“使用中”的下载状态重置为“未使用”\r\n            downloadStates.resume();\r\n        }\r\n        // 清空错误 id 列表\r\n        this.errorIdList = [];\r\n        this.setDownloaded();\r\n        this.taskBatch = new Date().getTime(); // 修改本批下载任务的标记\r\n        // 重置一些数据\r\n        this.downloadPause = false;\r\n        this.downloadStop = false;\r\n        clearTimeout(this.reTryTimer);\r\n        this.setDownloadThread();\r\n        EVT.fire(EVT.events.downloadStart);\r\n        // 启动或继续下载，建立并发下载线程\r\n        for (let i = 0; i < this.downloadThread; i++) {\r\n            this.createDownload(i);\r\n        }\r\n        this.setDownStateText(lang.transl('_正在下载中'));\r\n        log.log(lang.transl('_正在下载中'));\r\n    }\r\n    // 暂停下载\r\n    pauseDownload() {\r\n        clearTimeout(this.reTryTimer);\r\n        if (store.result.length === 0) {\r\n            return;\r\n        }\r\n        // 停止的优先级高于暂停。点击停止可以取消暂停状态，但点击暂停不能取消停止状态\r\n        if (this.downloadStop === true) {\r\n            return;\r\n        }\r\n        if (this.downloadPause === false) {\r\n            // 如果正在下载中\r\n            if (!store.states.allowWork) {\r\n                this.downloadPause = true; // 发出暂停信号\r\n                EVT.fire(EVT.events.downloadPause);\r\n                titleBar.change('║');\r\n                this.setDownStateText(lang.transl('_已暂停'), '#f00');\r\n                log.warning(lang.transl('_已暂停'), 2);\r\n            }\r\n            else {\r\n                // 不在下载中的话不允许启用暂停功能\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    // 停止下载\r\n    stopDownload() {\r\n        clearTimeout(this.reTryTimer);\r\n        if (store.result.length === 0 || this.downloadStop) {\r\n            return;\r\n        }\r\n        this.downloadStop = true;\r\n        EVT.fire(EVT.events.downloadStop);\r\n        titleBar.change('■');\r\n        this.setDownStateText(lang.transl('_已停止'), '#f00');\r\n        log.error(lang.transl('_已停止'), 2);\r\n        this.downloadPause = false;\r\n    }\r\n    downloadError(id) {\r\n        this.errorIdList.push(id);\r\n        // 是否继续下载\r\n        const task = this.taskList[id];\r\n        const no = task.progressBarIndex;\r\n        if (this.checkContinueDownload()) {\r\n            this.createDownload(no);\r\n        }\r\n    }\r\n    saveFileError(data) {\r\n        if (this.downloadPause || this.downloadStop) {\r\n            return false;\r\n        }\r\n        const task = this.taskList[data.id];\r\n        // 复位这个任务的状态\r\n        downloadStates.setState(task.index, -1);\r\n        // 建立下载任务，再次下载它\r\n        this.createDownload(task.progressBarIndex);\r\n    }\r\n    downloadSuccess(data) {\r\n        const task = this.taskList[data.id];\r\n        // 更改这个任务状态为“已完成”\r\n        downloadStates.setState(task.index, 1);\r\n        // 发送下载成功的事件\r\n        EVT.fire(EVT.events.downloadSucccess, data);\r\n        // 统计已下载数量\r\n        this.setDownloaded();\r\n        // 是否继续下载\r\n        const no = task.progressBarIndex;\r\n        if (this.checkContinueDownload()) {\r\n            this.createDownload(no);\r\n        }\r\n    }\r\n    // 当一个文件下载成功或失败之后，检查是否还有后续下载任务\r\n    checkContinueDownload() {\r\n        // 如果没有全部下载完毕\r\n        if (this.downloaded < store.result.length) {\r\n            // 如果任务已停止\r\n            if (this.downloadPause || this.downloadStop) {\r\n                return false;\r\n            }\r\n            // 如果已完成的数量 加上 线程中未完成的数量，仍然没有达到文件总数，继续添加任务\r\n            if (this.downloaded + this.downloadThread - 1 < store.result.length) {\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    // 在日志上显示下载进度\r\n    LogDownloadStates() {\r\n        let text = `${this.downloaded} / ${store.result.length}`;\r\n        // 追加转换动图的提示\r\n        if (this.convertText) {\r\n            text += ', ' + this.convertText;\r\n        }\r\n        log.log(text, 2, false);\r\n    }\r\n    // 查找需要进行下载的作品，建立下载\r\n    createDownload(progressBarIndex) {\r\n        const index = downloadStates.getFirstDownloadItem();\r\n        if (index === undefined) {\r\n            // console.log(downloadStates.states)\r\n            // console.log('getFirstDownloadItem failed')\r\n            // 当已经没有需要下载的作品时，检查是否带着错误完成了下载。\r\n            // 如果下载过程中没有出错，就不会执行到这个分支\r\n            return this.checkCompleteWithError();\r\n        }\r\n        else {\r\n            const workData = store.result[index];\r\n            const data = {\r\n                id: workData.id,\r\n                data: workData,\r\n                index: index,\r\n                progressBarIndex: progressBarIndex,\r\n                taskBatch: this.taskBatch,\r\n            };\r\n            // 保存任务信息\r\n            this.taskList[workData.id] = {\r\n                index,\r\n                progressBarIndex: progressBarIndex,\r\n            };\r\n            // 建立下载\r\n            new Download(progressBarIndex, data);\r\n        }\r\n    }\r\n}\r\nnew DownloadControl();\r\n","import { EVT } from './EVT';\r\nimport { store } from './Store';\r\n// 下载状态列表\r\nclass DownloadStates {\r\n    constructor() {\r\n        this.states = [];\r\n        this.bindEvent();\r\n    }\r\n    bindEvent() {\r\n        window.addEventListener(EVT.events.crawlFinish, async (ev) => {\r\n            if (ev.detail.data.initiator !== EVT.InitiatorList.resume) {\r\n                // 当正常抓取完毕时，初始化下载状态列表。\r\n                // 当需要恢复下载时，不初始化下载状态列表。因为此时 Resume 类会直接传入下载列表\r\n                this.initList();\r\n            }\r\n        });\r\n    }\r\n    // 创建新的状态列表\r\n    initList() {\r\n        this.states = new Array(store.result.length).fill(-1);\r\n    }\r\n    // 统计下载完成的数量\r\n    downloadedCount() {\r\n        let count = 0;\r\n        const length = this.states.length;\r\n        for (let i = 0; i < length; i++) {\r\n            if (this.states[i] === 1) {\r\n                count++;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n    // 替换所有的状态数据\r\n    // 目前只有在恢复下载的时候使用\r\n    replace(states) {\r\n        this.states = states;\r\n    }\r\n    // 恢复之前的下载任务\r\n    // 这会把之前的“下载中”标记复位到“未开始下载”，以便再次下载\r\n    resume() {\r\n        const length = this.states.length;\r\n        for (let i = 0; i < length; i++) {\r\n            if (this.states[i] === 0) {\r\n                this.setState(i, -1);\r\n            }\r\n        }\r\n    }\r\n    // 获取第一个“未开始下载”标记的索引\r\n    getFirstDownloadItem() {\r\n        const length = this.states.length;\r\n        for (let i = 0; i < length; i++) {\r\n            if (this.states[i] === -1) {\r\n                this.setState(i, 0);\r\n                return i;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    // 设置已下载列表中的标记\r\n    setState(index, value) {\r\n        this.states[index] = value;\r\n    }\r\n    clear() {\r\n        this.states = [];\r\n    }\r\n}\r\nconst downloadStates = new DownloadStates();\r\nexport { downloadStates };\r\n","// 事件类\r\nclass EVT {\r\n    // 触发事件，可以携带数据\r\n    static fire(type, data = '') {\r\n        const event = new CustomEvent(type, {\r\n            detail: { data: data },\r\n        });\r\n        setTimeout(() => {\r\n            window.dispatchEvent(event);\r\n        }, 0);\r\n    }\r\n}\r\n// 事件名称列表\r\nEVT.events = {\r\n    crawlStart: 'crawlStart',\r\n    crawlFinish: 'crawlFinish',\r\n    crawlEmpty: 'crawlEmpty',\r\n    crawlError: 'crawlError',\r\n    addResult: 'addResult',\r\n    downloadStart: 'downloadStart',\r\n    downloadPause: 'downloadPause',\r\n    downloadStop: 'downloadStop',\r\n    download: 'download',\r\n    downloadSucccess: 'downloadSucccess',\r\n    downloadError: 'downloadError',\r\n    downloadComplete: 'downloadComplete',\r\n    pageSwitch: 'pageSwitch',\r\n    pageTypeChange: 'pageTypeChange',\r\n    resetOption: 'resetOption',\r\n    convertChange: 'convertChange',\r\n    previewFileName: 'previewFileName',\r\n    output: 'output',\r\n    hideCenterPanel: 'hideCenterPanel',\r\n    showCenterPanel: 'showCenterPanel',\r\n    clearMultiple: 'clearMultiple',\r\n    clearUgoira: 'clearUgoira',\r\n    deleteWork: 'deleteWork',\r\n    worksUpdate: 'worksUpdate',\r\n    settingChange: 'settingChange',\r\n    clickRightIcon: 'clickRightIcon',\r\n    destroy: 'destroy',\r\n    convertError: 'convertError',\r\n    skipSaveFile: 'skipSaveFile',\r\n    saveFileError: 'saveFileError',\r\n    hasNewVer: 'hasNewVer',\r\n    restoreDownload: 'restoreDownload',\r\n    DBupgradeneeded: 'DBupgradeneeded',\r\n    clearDownloadRecords: 'clearDownloadRecords',\r\n};\r\n// 事件发起者的标识列表\r\nEVT.InitiatorList = {\r\n    resume: 'resume',\r\n};\r\nexport { EVT };\r\n","import { EVT } from './EVT';\r\nimport { DOM } from './DOM';\r\nimport { pageInfo } from './PageInfo';\r\nimport { themeColor } from './ThemeColor';\r\n// 在搜索页面按收藏数快速筛选\r\nclass FastScreen {\r\n    constructor() {\r\n        this.favNums = [\r\n            '100users入り',\r\n            '500users入り',\r\n            '1000users入り',\r\n            '3000users入り',\r\n            '5000users入り',\r\n            '10000users入り',\r\n            '20000users入り',\r\n            '30000users入り',\r\n            '50000users入り',\r\n        ]; // 200 和 2000 的因为数量太少，不添加。40000 的也少\r\n        this.create();\r\n        window.addEventListener(EVT.events.pageTypeChange, () => {\r\n            this.destroy();\r\n        });\r\n    }\r\n    // 添加快速筛选功能\r\n    create() {\r\n        // 判断插入点的元素有没有加载出来\r\n        const target = document.querySelector('#root>div');\r\n        if (!target) {\r\n            setTimeout(() => {\r\n                this.create();\r\n            }, 300);\r\n            return;\r\n        }\r\n        const fastScreenArea = document.createElement('div');\r\n        fastScreenArea.className = 'fastScreenArea';\r\n        this.favNums.forEach((secondTag) => {\r\n            const a = document.createElement('a');\r\n            a.innerText = secondTag;\r\n            a.href = 'javascript:viod(0)';\r\n            a.onclick = () => {\r\n                this.openFastScreenLink(secondTag);\r\n            };\r\n            fastScreenArea.appendChild(a);\r\n        });\r\n        themeColor.register(fastScreenArea);\r\n        target.insertAdjacentElement('afterend', fastScreenArea);\r\n    }\r\n    // 打开快速筛选链接\r\n    openFastScreenLink(secondTag) {\r\n        // 拼接两个 tag。因为搜索页面可以无刷新切换搜索的 tag，所以从这里动态获取\r\n        const firstTag = pageInfo.getPageTag.split(' ')[0];\r\n        const fullTag = encodeURIComponent(firstTag + ' ' + secondTag);\r\n        // 用新的 tag 替换掉当前网址里的 tag\r\n        const newURL = location.href.replace(encodeURIComponent(pageInfo.getPageTag), fullTag);\r\n        // 添加 s_mode=s_tag 宽松匹配标签\r\n        const u = new URL(newURL);\r\n        u.searchParams.set('s_mode', 's_tag');\r\n        location.href = u.toString();\r\n    }\r\n    destroy() {\r\n        // 删除快速筛选元素\r\n        const fastScreen = document.querySelector('.fastScreenArea');\r\n        DOM.removeEl(fastScreen);\r\n    }\r\n}\r\nexport { FastScreen };\r\n","// 生成文件名\r\nimport { EVT } from './EVT';\r\nimport { API } from './API';\r\nimport { lang } from './Lang';\r\nimport { form } from './Settings';\r\nimport { store } from './Store';\r\nimport config from './Config';\r\nclass FileName {\r\n    constructor() {\r\n        window.addEventListener(EVT.events.previewFileName, () => {\r\n            this.previewFileName();\r\n        });\r\n    }\r\n    // 生成文件名\r\n    getFileName(data) {\r\n        // 为空时使用 {id}\r\n        let result = form.userSetName.value || '{id}';\r\n        const illustTypes = ['illustration', 'manga', 'ugoira', 'novel']; // 作品类型 0 插画 1 漫画 2 动图 3 小说\r\n        // 配置所有命名标记\r\n        const cfg = {\r\n            '{p_title}': {\r\n                value: store.pageInfo.pageTitle,\r\n                prefix: '',\r\n                safe: false,\r\n            },\r\n            '{p_tag}': {\r\n                value: store.pageInfo.pageTag,\r\n                prefix: '',\r\n                safe: false,\r\n            },\r\n            '{id}': {\r\n                value: data.id,\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n            '{id_num}': {\r\n                value: data.idNum || parseInt(data.id),\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n            '{p_num}': {\r\n                value: parseInt(/\\d*$/.exec(data.id)[0]),\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n            '{rank}': {\r\n                value: data.rank,\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n            '{title}': {\r\n                value: data.title,\r\n                prefix: 'title_',\r\n                safe: false,\r\n            },\r\n            '{user}': {\r\n                value: data.user,\r\n                prefix: 'user_',\r\n                safe: false,\r\n            },\r\n            '{userid}': {\r\n                value: data.userId,\r\n                prefix: 'uid_',\r\n                safe: true,\r\n            },\r\n            '{user_id}': {\r\n                value: data.userId,\r\n                prefix: 'uid_',\r\n                safe: true,\r\n            },\r\n            '{px}': {\r\n                value: (function () {\r\n                    if (result.includes('{px}') && data.fullWidth !== undefined) {\r\n                        return data.fullWidth + 'x' + data.fullHeight;\r\n                    }\r\n                    else {\r\n                        return '';\r\n                    }\r\n                })(),\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n            '{tags}': {\r\n                value: data.tags.join(','),\r\n                prefix: 'tags_',\r\n                safe: false,\r\n            },\r\n            '{tags_translate}': {\r\n                value: data.tagsTranslated.join(','),\r\n                prefix: 'tags_',\r\n                safe: false,\r\n            },\r\n            '{bmk}': {\r\n                value: data.bmk,\r\n                prefix: 'bmk_',\r\n                safe: true,\r\n            },\r\n            '{date}': {\r\n                value: data.date,\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n            '{type}': {\r\n                value: illustTypes[data.type],\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n            '{series_title}': {\r\n                value: data.seriesTitle || '',\r\n                prefix: '',\r\n                safe: false,\r\n            },\r\n            '{series_order}': {\r\n                value: data.seriesOrder || '',\r\n                prefix: '',\r\n                safe: true,\r\n            },\r\n        };\r\n        // 替换命名规则里的特殊字符\r\n        result = API.replaceUnsafeStr(result);\r\n        // 上一步会把斜线 / 替换成全角的斜线 ／，这里再替换回来，否则就不能建立文件夹了\r\n        result = result.replace(/／/g, '/');\r\n        // 判断这个作品是否要去掉序号\r\n        const noSerialNo = cfg['{p_num}'].value === 0 && form.noSerialNo.checked;\r\n        // 把命名规则的标记替换成实际值\r\n        for (const [key, val] of Object.entries(cfg)) {\r\n            if (result.includes(key)) {\r\n                // 处理去掉序号的情况\r\n                if (noSerialNo) {\r\n                    // 把 p_num 设为空字符串\r\n                    key === '{p_num}' && (val.value = '');\r\n                    // 去掉 id 后面的序号。因为 idNum 不带序号，所以直接拿来用了\r\n                    key === '{id}' && (val.value = cfg['{id_num}'].value);\r\n                }\r\n                let once = String(val.value);\r\n                // 处理标记值中的特殊字符\r\n                if (!val.safe) {\r\n                    once = API.replaceUnsafeStr(once);\r\n                }\r\n                // 添加标记名称\r\n                if (form.tagNameToFileName.checked) {\r\n                    once = val.prefix + once;\r\n                }\r\n                result = result.replace(new RegExp(key, 'g'), once); // 将标记替换成最终值，如果有重复的标记，全部替换\r\n            }\r\n        }\r\n        // 处理空值，连续的 '//'。 有时候两个斜线中间的字段是空值，最后就变成两个斜线挨在一起了\r\n        result = result.replace(/undefined/g, '').replace(/\\/{2,9}/, '/');\r\n        // 对每一层路径进行处理\r\n        let tempArr = result.split('/');\r\n        tempArr.forEach((str, index, arr) => {\r\n            // 替换路径首尾的空格\r\n            // 把每层路径头尾的 . 变成全角的．因为 Chrome 不允许头尾使用 .\r\n            arr[index] = str.trim().replace(/^\\./g, '．').replace(/\\.$/g, '．');\r\n        });\r\n        result = tempArr.join('/');\r\n        // 去掉头尾的 /\r\n        if (result.startsWith('/')) {\r\n            result = result.replace('/', '');\r\n        }\r\n        if (result.endsWith('/')) {\r\n            result = result.substr(0, result.length - 1);\r\n        }\r\n        // 如果快速下载时只有一个文件，根据“始终建立文件夹”选项，决定是否去掉文件夹部分\r\n        if (store.states.quickDownload &&\r\n            store.result.length === 1 &&\r\n            form.alwaysFolder.checked === false) {\r\n            const index = result.lastIndexOf('/');\r\n            result = result.substr(index + 1, result.length);\r\n        }\r\n        // 处理为多图作品自动建立文件夹的情况\r\n        // 多图作品如果只下载前 1 张，不会为它自动建立文件夹。大于 1 张才会自动建立文件夹\r\n        if (form.multipleImageDir.checked && data.dlCount > 1) {\r\n            // 操作路径中最后一项（即文件名），在它前面添加一层文件夹\r\n            const allPart = result.split('/');\r\n            const lastPartIndex = allPart.length - 1;\r\n            let lastPart = allPart[lastPartIndex];\r\n            let addString = '';\r\n            if (form.multipleImageFolderName.value === '1') {\r\n                // 使用作品 id 作为文件夹名\r\n                addString = data.idNum.toString();\r\n            }\r\n            else if (form.multipleImageFolderName.value === '2') {\r\n                // 遵从命名规则，使用文件名做文件夹名\r\n                // 这里进行了一个替换，因为多图每个图片的名字都不同，这主要是因为 id 后面的序号不同。这会导致文件夹名也不同，有多少个文件就会建立多少个文件夹，而不是统一建立一个文件夹。为了只建立一个文件夹，需要把 id 后面的序号部分去掉。\r\n                // 但是如果一些特殊的命名规则并没有包含 {id} 部分，文件名的区别得不到处理，依然会每个文件建立一个文件夹。\r\n                addString = lastPart.replace(data.id, data.idNum.toString());\r\n            }\r\n            lastPart = addString + '/' + lastPart;\r\n            allPart[lastPartIndex] = lastPart;\r\n            result = allPart.join('/');\r\n        }\r\n        // 添加后缀名\r\n        if ((data.ext === 'webm' || data.ext === 'gif') && data.ugoiraInfo) {\r\n            // 如果是动图，那么此时根据用户设置的动图保存格式，更新其后缀名\r\n            // 例如，抓取时动图保存格式是 webm，下载开始前，用户改成了 gif，在这里可以响应用户的修改\r\n            data.ext = form.ugoiraSaveAs.value;\r\n        }\r\n        result += '.' + data.ext;\r\n        return result;\r\n    }\r\n    // 预览文件名\r\n    previewFileName() {\r\n        if (store.result.length === 0) {\r\n            return alert(lang.transl('_没有数据可供使用'));\r\n        }\r\n        // 使用数组储存和拼接字符串，提高性能\r\n        const resultArr = [];\r\n        const length = store.result.length;\r\n        for (let i = 0; i < length; i++) {\r\n            const data = store.result[i];\r\n            // 为默认文件名添加颜色。默认文件名有两种处理方式，一种是取出用其他下载软件下载后的默认文件名，一种是取出本程序使用的默认文件名 data.id。这里使用前者，方便用户用其他下载软件下载后，再用生成的文件名重命名。\r\n            const defaultName = data.url.replace(/.*\\//, '');\r\n            const fullName = this.getFileName(data);\r\n            let nowResult = `${defaultName}: ${fullName}<br>`;\r\n            if (length < config.outputMax) {\r\n                // 为生成的文件名添加颜色。只有当文件数量少于一定数值时才添加颜色。这是因为添加颜色会导致生成的 HTML 元素数量增多，复制时资源占用增加。有些用户电脑配置差，如果生成的结果很多，还添加了颜色，可能复制时会导致这个页面卡死。\r\n                const defaultNameHtml = `<span class=\"color999\">${defaultName}</span>`;\r\n                const part = fullName.split('/');\r\n                const length = part.length;\r\n                for (let i = 0; i < length; i++) {\r\n                    const str = part[i];\r\n                    if (i < length - 1) {\r\n                        // 如果不是最后一项，说明是文件夹名，添加颜色\r\n                        part[i] = `<span class=\"color666\">${str}</span>`;\r\n                    }\r\n                    else {\r\n                        // 最后一项，是文件名，添加颜色\r\n                        part[i] = `<span class=\"color000\">${str}</span>`;\r\n                    }\r\n                }\r\n                const fullNameHtml = part.join('/');\r\n                nowResult = `<p class=\"result\">${defaultNameHtml}: ${fullNameHtml}</p>`;\r\n            }\r\n            // 保存本条结果\r\n            resultArr.push(nowResult);\r\n        }\r\n        // 拼接所有结果\r\n        const result = resultArr.join('');\r\n        EVT.fire(EVT.events.output, {\r\n            content: result,\r\n            title: lang.transl('_预览文件名'),\r\n        });\r\n    }\r\n}\r\nconst fileName = new FileName();\r\nexport { fileName };\r\n","import { form } from './Settings';\r\nimport { lang } from './Lang';\r\nimport { log } from './Log';\r\nimport { API } from './API';\r\nimport { EVT } from './EVT';\r\nimport { blackAndWhiteImage } from './BlackandWhiteImage';\r\n// 审查每个作品的数据，决定是否要存储它\r\n// 可以根据需要，随时进行审查\r\nclass Filter {\r\n    constructor() {\r\n        this.downType0 = true;\r\n        this.downType1 = true;\r\n        this.downType2 = true;\r\n        this.downType3 = true;\r\n        this.downSingleImg = true;\r\n        this.downMultiImg = true;\r\n        this.downColorImg = true;\r\n        this.downBlackWhiteImg = true;\r\n        this.filterBMKNum = false; // 是否要求收藏数量\r\n        this.BMKNumMinDef = 0;\r\n        this.BMKNumMaxDef = 999999;\r\n        this.BMKNumMin = this.BMKNumMinDef; // 最小收藏数量\r\n        this.BMKNumMax = this.BMKNumMaxDef; // 最大收藏数量\r\n        this.onlyBmk = false; // 是否只下载收藏的作品\r\n        this.MB = 1024 * 1024;\r\n        this.sizeMin = 0;\r\n        this.sizeMax = 100 * this.MB;\r\n        // 宽高条件\r\n        this.setWHSwitch = false;\r\n        this.filterWh = {\r\n            andOr: '&',\r\n            width: 0,\r\n            height: 0,\r\n        };\r\n        this.ratioType = '0'; // 宽高比例的类型\r\n        this.idRangeSwitch = false; // id 范围的开关\r\n        this.idRange = -1; // id 范围，默认不限制\r\n        this.postDate = false; // 是否设置投稿时间\r\n        this.postDateStart = new Date();\r\n        this.postDateEnd = new Date();\r\n        this.needTagSwitch = false; // 必须包含的 tag 开关\r\n        this.includeTag = ''; // 必须包含的 tag\r\n        this.notNeedTagSwitch = false; // 要排除的 tag 开关\r\n        this.excludeTag = ''; // 要排除的 tag\r\n        this.debut = false; // 只下载首次登场的作品\r\n        this.bindEvent();\r\n    }\r\n    // 从下载区域上获取过滤器的各个选项\r\n    init() {\r\n        // 获取排除作品类型的设置\r\n        this.getDownType();\r\n        this.getDownTypeByImgCount();\r\n        // 获取是否设置了过滤黑白图像\r\n        this.getDownTypeByColor();\r\n        // 获取是否设置了收藏数要求\r\n        this.filterBMKNum = form.BMKNumSwitch.checked;\r\n        this.filterBMKNum && this.getBMKNum();\r\n        // 获取是否设置了只下载书签作品\r\n        this.onlyBmk = this.getOnlyBmk();\r\n        // 获取是否设置了宽高条件\r\n        this.setWHSwitch = form.setWHSwitch.checked;\r\n        if (this.setWHSwitch) {\r\n            this.filterWh = this.getSetWh();\r\n        }\r\n        // 获取宽高比设置\r\n        if (form.ratioSwitch.checked) {\r\n            this.ratioType = this.getRatio();\r\n        }\r\n        // 获取 id 范围设置\r\n        this.idRangeSwitch = form.idRangeSwitch.checked;\r\n        if (this.idRangeSwitch) {\r\n            this.idRange = this.getIdRange();\r\n        }\r\n        // 获取投稿时间设置\r\n        this.postDate = this.getPostDateSetting();\r\n        // 获取必须包含的tag\r\n        this.needTagSwitch = form.needTagSwitch.checked;\r\n        if (this.needTagSwitch) {\r\n            this.includeTag = this.getIncludeTag();\r\n        }\r\n        // 获取要排除的tag\r\n        this.notNeedTagSwitch = form.notNeedTagSwitch.checked;\r\n        if (this.notNeedTagSwitch) {\r\n            this.excludeTag = this.getExcludeTag();\r\n        }\r\n        // 获取只下载首次登场设置\r\n        this.debut = this.getDebut();\r\n        this.getSize();\r\n    }\r\n    // 检查作品是否符合过滤器的要求\r\n    // 想要检查哪些数据就传递哪些数据，不需要传递 FilterOption 的所有选项\r\n    // 所有过滤器里，都必须要检查参数为 undefined 的情况\r\n    async check(option) {\r\n        // 检查下载的作品类型设置\r\n        if (!this.checkDownType(option.illustType)) {\r\n            return false;\r\n        }\r\n        // 检查图片张数是否允许下载\r\n        if (!this.checkPageCount(option.illustType, option.pageCount)) {\r\n            return false;\r\n        }\r\n        // 检查收藏数要求\r\n        if (!this.checkBMK(option.bookmarkCount)) {\r\n            return false;\r\n        }\r\n        // 检查只下载书签作品的要求\r\n        if (!this.checkOnlyBmk(option.bookmarkData)) {\r\n            return false;\r\n        }\r\n        // 检查要排除的 tag\r\n        if (!this.checkExcludeTag(option.tags)) {\r\n            return false;\r\n        }\r\n        // 检查必须包含的 tag\r\n        if (!this.checkIncludeTag(option.tags)) {\r\n            return false;\r\n        }\r\n        // 检查宽高设置\r\n        if (!this.checkSetWh(option.width, option.height)) {\r\n            return false;\r\n        }\r\n        // 检查宽高比设置\r\n        if (!this.checkRatio(option.width, option.height)) {\r\n            return false;\r\n        }\r\n        // 检查 id 范围设置\r\n        if (!this.checkIdRange(option.id)) {\r\n            return false;\r\n        }\r\n        // 检查投稿时间设置\r\n        if (!this.checkPostDate(option.createDate)) {\r\n            return false;\r\n        }\r\n        // 检查首次登场设置\r\n        if (!this.checkDebut(option.yes_rank)) {\r\n            return false;\r\n        }\r\n        // 检查文件体积设置\r\n        if (!this.checkSize(option.size)) {\r\n            return false;\r\n        }\r\n        // 检查黑白图片\r\n        // 这一步需要加载图片，需要较长的时间，较大的资源占用，放到最后检查，以避免无谓的执行\r\n        const blackAndWhiteResult = await this.checkBlackWhite(option.mini);\r\n        if (!blackAndWhiteResult) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    // 当需要时抛出错误\r\n    throwError(msg) {\r\n        EVT.fire(EVT.events.crawlError);\r\n        log.error(msg, 2);\r\n        window.alert(msg);\r\n        throw new Error(msg);\r\n    }\r\n    // 获取下载的作品类型设置\r\n    getDownType() {\r\n        this.downType0 = form.downType0.checked;\r\n        this.downType1 = form.downType1.checked;\r\n        this.downType2 = form.downType2.checked;\r\n        this.downType3 = form.downType3.checked;\r\n        // 如果全部排除则取消任务\r\n        if (!this.downType0 &&\r\n            !this.downType1 &&\r\n            !this.downType2 &&\r\n            !this.downType3) {\r\n            this.throwError(lang.transl('_checkNotdownTypeAll'));\r\n        }\r\n        let notDownTip = '';\r\n        notDownTip += this.downType0 ? '' : lang.transl('_插画');\r\n        notDownTip += this.downType1 ? '' : lang.transl('_漫画');\r\n        notDownTip += this.downType2 ? '' : lang.transl('_动图');\r\n        notDownTip += this.downType3 ? '' : lang.transl('_小说');\r\n        if (notDownTip) {\r\n            log.warning(lang.transl('_checkNotdownTypeResult') + notDownTip);\r\n        }\r\n    }\r\n    getDownTypeByImgCount() {\r\n        this.downSingleImg = form.downSingleImg.checked;\r\n        this.downMultiImg = form.downMultiImg.checked;\r\n        let notDownTip = '';\r\n        notDownTip += this.downSingleImg ? '' : lang.transl('_单图作品');\r\n        notDownTip += this.downMultiImg ? '' : lang.transl('_多图作品');\r\n        if (notDownTip) {\r\n            log.warning(lang.transl('_checkNotdownTypeResult') + notDownTip);\r\n        }\r\n    }\r\n    // 获取图像颜色设置\r\n    getDownTypeByColor() {\r\n        this.downColorImg = form.downColorImg.checked;\r\n        this.downBlackWhiteImg = form.downBlackWhiteImg.checked;\r\n        // 如果全部排除则取消任务\r\n        if (!this.downColorImg && !this.downBlackWhiteImg) {\r\n            this.throwError(lang.transl('_checkNotdownTypeAll'));\r\n        }\r\n        let notDownTip = '';\r\n        notDownTip += this.downColorImg ? '' : lang.transl('_彩色图片');\r\n        notDownTip += this.downBlackWhiteImg ? '' : lang.transl('_黑白图片');\r\n        if (notDownTip) {\r\n            log.warning(lang.transl('_checkNotdownTypeResult') + notDownTip);\r\n        }\r\n    }\r\n    // 获取用户输入的 tag 内容\r\n    getTagString(str) {\r\n        let result = '';\r\n        if (str) {\r\n            let tempArr = str.split(',');\r\n            // 如果用户在末尾也输入了逗号，则会产生一个空值，去掉它\r\n            if (tempArr[tempArr.length - 1] === '') {\r\n                tempArr.pop();\r\n            }\r\n            result = tempArr.join(',');\r\n        }\r\n        return result;\r\n    }\r\n    // 获取必须包含的tag\r\n    getIncludeTag() {\r\n        const result = '' || this.getTagString(form.needTag.value);\r\n        if (result) {\r\n            log.warning(lang.transl('_设置了必须tag之后的提示') + result);\r\n        }\r\n        return result;\r\n    }\r\n    // 获取要排除的tag\r\n    getExcludeTag() {\r\n        const result = '' || this.getTagString(form.notNeedTag.value);\r\n        if (result) {\r\n            log.warning(lang.transl('_设置了排除tag之后的提示') + result);\r\n        }\r\n        return result;\r\n    }\r\n    // 获取过滤宽高的设置\r\n    getSetWh() {\r\n        let result = {\r\n            andOr: '&',\r\n            width: 0,\r\n            height: 0,\r\n        };\r\n        const checkWidth = API.checkNumberGreater0(form.setWidth.value);\r\n        const checkHeight = API.checkNumberGreater0(form.setHeight.value);\r\n        // 宽高只要有一个条件大于 0 即可\r\n        if (checkWidth.value > 0 || checkHeight.value > 0) {\r\n            result = {\r\n                andOr: form.setWidthAndOr.value,\r\n                width: checkWidth ? checkWidth.value : 0,\r\n                height: checkHeight ? checkHeight.value : 0,\r\n            };\r\n            log.warning(lang.transl('_设置了筛选宽高之后的提示文字p1') +\r\n                result.width +\r\n                result.andOr\r\n                    .replace('|', lang.transl('_或者'))\r\n                    .replace('&', lang.transl('_并且')) +\r\n                lang.transl('_高度设置') +\r\n                result.height);\r\n        }\r\n        return result;\r\n    }\r\n    // 获取输入的收藏数\r\n    getBMKNum() {\r\n        this.BMKNumMin = this.BMKNumMinDef;\r\n        this.BMKNumMax = this.BMKNumMaxDef;\r\n        const min = API.checkNumberGreater0(form.BMKNumMin.value);\r\n        const max = API.checkNumberGreater0(form.BMKNumMax.value);\r\n        if (min.result) {\r\n            this.BMKNumMin = min.value;\r\n            log.warning(lang.transl('_收藏数大于') + min.value);\r\n        }\r\n        if (max.result) {\r\n            this.BMKNumMax = max.value;\r\n            log.warning(lang.transl('_收藏数小于') + max.value);\r\n        }\r\n    }\r\n    // 获取只下载书签作品的设置\r\n    getOnlyBmk() {\r\n        const result = form.setOnlyBmk.checked;\r\n        if (result) {\r\n            log.warning(lang.transl('_只下载已收藏的提示'));\r\n        }\r\n        return result;\r\n    }\r\n    // 获取宽高比设置\r\n    getRatio() {\r\n        let result = form.ratio.value;\r\n        if (result === '1') {\r\n            log.warning(lang.transl('_设置了宽高比之后的提示', lang.transl('_横图')));\r\n        }\r\n        else if (result === '2') {\r\n            log.warning(lang.transl('_设置了宽高比之后的提示', lang.transl('_竖图')));\r\n        }\r\n        else if (result === '3') {\r\n            // 由用户输入\r\n            const typeNum = parseFloat(form.userRatio.value);\r\n            if (isNaN(typeNum)) {\r\n                result = '0';\r\n                form.ratio.value = result;\r\n                window.alert(lang.transl('_宽高比必须是数字'));\r\n            }\r\n            else {\r\n                log.warning(lang.transl('_输入宽高比') + form.userRatio.value);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    // 获取 id 范围设置\r\n    getIdRange() {\r\n        const result = parseInt(form.idRange.value);\r\n        if (result === 1 || result === 2) {\r\n            let id = parseInt(form.idRangeInput.value);\r\n            if (isNaN(id)) {\r\n                EVT.fire(EVT.events.crawlError);\r\n                const msg = 'id is not a number!';\r\n                window.alert(msg);\r\n                log.error(msg);\r\n                throw new Error(msg);\r\n            }\r\n        }\r\n        if (result === 1) {\r\n            log.warning(`id > ${form.idRangeInput.value}`);\r\n        }\r\n        if (result === 2) {\r\n            log.warning(`id < ${form.idRangeInput.value}`);\r\n        }\r\n        return result;\r\n    }\r\n    // 获取投稿时间设置\r\n    getPostDateSetting() {\r\n        if (form.postDate.checked === false) {\r\n            return false;\r\n        }\r\n        else {\r\n            // 如果启用了此设置，需要判断是否是有效的时间格式\r\n            const postDateStart = new Date(form.postDateStart.value);\r\n            const postDateEnd = new Date(form.postDateEnd.value);\r\n            // 如果输入的时间可以被转换成有效的时间，则启用\r\n            // 转换时间失败时，值是 Invalid Date，不能转换成数字\r\n            if (isNaN(postDateStart.getTime()) || isNaN(postDateEnd.getTime())) {\r\n                EVT.fire(EVT.events.crawlError);\r\n                const msg = 'Date format error!';\r\n                log.error(msg);\r\n                window.alert(msg);\r\n                throw new Error(msg);\r\n            }\r\n            else {\r\n                // 转换时间成功\r\n                this.postDateStart = postDateStart;\r\n                this.postDateEnd = postDateEnd;\r\n                log.warning(`${lang.transl('_时间范围')}: ${form.postDateStart.value} - ${form.postDateEnd.value}`);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    // 获取首次登场设置\r\n    getDebut() {\r\n        const result = form.debut.value === '1';\r\n        if (result) {\r\n            log.warning(lang.transl('_抓取首次登场的作品Title'));\r\n        }\r\n        return result;\r\n    }\r\n    // 获取文件体积设置\r\n    getSize() {\r\n        if (form.sizeSwitch.checked) {\r\n            let min = parseFloat(form.sizeMin.value);\r\n            isNaN(min) && (min = 0);\r\n            let max = parseFloat(form.sizeMax.value);\r\n            isNaN(max) && (min = 100);\r\n            // 如果输入的最小值比最大值还要大，则交换它们的值\r\n            if (min > max) {\r\n                ;\r\n                [min, max] = [max, min];\r\n            }\r\n            this.sizeMin = min * this.MB;\r\n            this.sizeMax = max * this.MB;\r\n            log.warning(`Size: ${min}MB - ${max}MB`);\r\n        }\r\n    }\r\n    // 检查下载的作品类型设置\r\n    checkDownType(illustType) {\r\n        if (illustType === undefined) {\r\n            return true;\r\n        }\r\n        else {\r\n            switch (illustType) {\r\n                case 0:\r\n                    return this.downType0 ? true : false;\r\n                case 1:\r\n                    return this.downType1 ? true : false;\r\n                case 2:\r\n                    return this.downType2 ? true : false;\r\n                case 3:\r\n                    return this.downType3 ? true : false;\r\n                default:\r\n                    return true;\r\n            }\r\n        }\r\n    }\r\n    // 依据图片数量，检查下载的作品类型\r\n    checkPageCount(illustType, pageCount) {\r\n        // 判断单图、多图时，只对插画、漫画生效，否则跳过检查\r\n        if (illustType !== 0 && illustType !== 1) {\r\n            return true;\r\n        }\r\n        if (illustType === undefined || pageCount === undefined) {\r\n            return true;\r\n        }\r\n        if (pageCount === 1 && this.downSingleImg) {\r\n            return true;\r\n        }\r\n        if (pageCount > 1 && this.downMultiImg) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // 检查过滤黑白图像设置\r\n    async checkBlackWhite(imgUrl) {\r\n        // 如果没有图片网址，或者没有排除任何一个选项，则不检查\r\n        if (!imgUrl || (this.downColorImg && this.downBlackWhiteImg)) {\r\n            return true;\r\n        }\r\n        // result 为 true，表示它是黑白图片，false 是彩色图片\r\n        const result = await blackAndWhiteImage.check(imgUrl);\r\n        return (result && this.downBlackWhiteImg) || (!result && this.downColorImg);\r\n    }\r\n    // 检查收藏数要求\r\n    checkBMK(bmk) {\r\n        if (bmk === undefined || !this.filterBMKNum) {\r\n            return true;\r\n        }\r\n        else {\r\n            return bmk >= this.BMKNumMin && bmk <= this.BMKNumMax;\r\n        }\r\n    }\r\n    // 检查作品是否符合【只下载书签作品】的条件,返回值 true 表示包含这个作品\r\n    checkOnlyBmk(bookmarked) {\r\n        if (bookmarked === undefined || !this.onlyBmk) {\r\n            return true;\r\n        }\r\n        return !!bookmarked;\r\n    }\r\n    // 检查作品是否符合包含 tag 的条件, 如果设置了多个 tag，需要作品里全部包含。返回值表示是否保留这个作品。\r\n    checkIncludeTag(tags) {\r\n        if (!this.needTagSwitch || !this.includeTag || tags === undefined) {\r\n            return true;\r\n        }\r\n        let result = false;\r\n        let tempArr = this.includeTag.split(',');\r\n        // 如果设置了必须的 tag\r\n        if (tempArr.length > 0) {\r\n            let tagNeedMatched = 0;\r\n            const tempTags = new Set();\r\n            // 如果不区分大小写的话，Fate/grandorder 和 Fate/GrandOrder 会被算作符合两个 tag，所以用 Set 结构去重。测试 id 51811780\r\n            for (const tag of tags) {\r\n                tempTags.add(tag.toLowerCase());\r\n            }\r\n            for (const tag of tempTags) {\r\n                for (const need of tempArr) {\r\n                    if (tag === need.toLowerCase()) {\r\n                        tagNeedMatched++;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            // 如果全部匹配\r\n            if (tagNeedMatched >= tempArr.length) {\r\n                result = true;\r\n            }\r\n        }\r\n        else {\r\n            result = true;\r\n        }\r\n        return result;\r\n    }\r\n    // 检查作品是否符合排除 tag 的条件, 只要作品包含其中一个就排除。返回值表示是否保留这个作品。\r\n    checkExcludeTag(tags) {\r\n        if (!this.notNeedTagSwitch || !this.excludeTag || tags === undefined) {\r\n            return true;\r\n        }\r\n        let result = true;\r\n        let tempArr = this.excludeTag.split(',');\r\n        // 如果设置了排除 tag\r\n        if (tempArr.length > 0) {\r\n            for (const tag of tags) {\r\n                for (const notNeed of tempArr) {\r\n                    if (tag.toLowerCase() === notNeed.toLowerCase()) {\r\n                        result = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    // 检查作品是否符合过滤宽高的条件\r\n    checkSetWh(width, height) {\r\n        if (!this.setWHSwitch) {\r\n            return true;\r\n        }\r\n        if (width === undefined || height === undefined) {\r\n            return true;\r\n        }\r\n        if (this.filterWh.width > 0 || this.filterWh.height > 0) {\r\n            // 如果宽高都小于要求的宽高\r\n            if (width < this.filterWh.width && height < this.filterWh.height) {\r\n                return false;\r\n            }\r\n            else {\r\n                if (this.filterWh.andOr === '|') {\r\n                    // 判断or的情况\r\n                    if (width >= this.filterWh.width || height >= this.filterWh.height) {\r\n                        return true;\r\n                    }\r\n                    else {\r\n                        return false;\r\n                    }\r\n                }\r\n                else if (this.filterWh.andOr === '&') {\r\n                    // 判断and的情况\r\n                    if (width >= this.filterWh.width && height >= this.filterWh.height) {\r\n                        return true;\r\n                    }\r\n                    else {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    // 检查作品是否符合宽高比条件\r\n    checkRatio(width, height) {\r\n        if (!form.ratioSwitch.checked) {\r\n            return true;\r\n        }\r\n        if (width === undefined || height === undefined) {\r\n            return true;\r\n        }\r\n        if (this.ratioType === '1') {\r\n            return width / height > 1;\r\n        }\r\n        else if (this.ratioType === '2') {\r\n            return width / height < 1;\r\n        }\r\n        else {\r\n            return width / height >= parseFloat(form.userRatio.value);\r\n        }\r\n    }\r\n    // 检查 id 范围设置\r\n    checkIdRange(id) {\r\n        if (id === undefined || !this.idRangeSwitch) {\r\n            return true;\r\n        }\r\n        const nowId = parseInt(id.toString());\r\n        const setId = parseInt(form.idRangeInput.value);\r\n        if (this.idRange === 1) {\r\n            // 大于\r\n            return nowId > setId;\r\n        }\r\n        else if (this.idRange === 2) {\r\n            // 小于\r\n            return nowId < setId;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n    // 检查投稿时间设置\r\n    checkPostDate(date) {\r\n        if (!this.postDate || date === undefined) {\r\n            return true;\r\n        }\r\n        else {\r\n            const nowDate = new Date(date);\r\n            if (nowDate >= this.postDateStart && nowDate <= this.postDateEnd) {\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    // 检查首次登场设置\r\n    // yes_rank 是昨日排名，如果为 0，则此作品是“首次登场”的作品\r\n    checkDebut(yes_rank) {\r\n        if (!this.debut || yes_rank === undefined) {\r\n            return true;\r\n        }\r\n        else {\r\n            if (yes_rank === 0 || yes_rank === undefined) {\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    // 检查文件体积\r\n    checkSize(size) {\r\n        if (!form.sizeSwitch.checked || size === undefined) {\r\n            return true;\r\n        }\r\n        return size >= this.sizeMin && size <= this.sizeMax;\r\n    }\r\n    bindEvent() {\r\n        window.addEventListener(EVT.events.crawlFinish, async (ev) => {\r\n            if (ev.detail.data.initiator === EVT.InitiatorList.resume) {\r\n                // 当需要恢复下载时，初始化过滤器。否则过滤器不会实际上进行过滤\r\n                this.init();\r\n            }\r\n        });\r\n    }\r\n}\r\nconst filter = new Filter();\r\nexport { filter };\r\n","import { lang } from './Lang';\r\nconst formHtml = `<form class=\"settingForm\">\n  <div class=\"tabsTitle\">\n    <div class=\"title\">${lang.transl('_抓取')}</div>\n    <div class=\"title\">${lang.transl('_下载')}</div>\n    <div class=\"title\">${lang.transl('_其他')}</div>\n  </div>\n  <div class=\"tabsContnet\">\n    <div class=\"con\">\n      <p class=\"option\" data-no=\"1\">\n      <span class=\"setWantPageWrap\">\n      <span class=\"has_tip settingNameStyle1 setWantPageTip1\" data-tip=\"${lang.transl('_页数')}\" style=\"margin-right: 0px;\">${lang.transl('_页数')}</span>\n      <span class=\"gray1\" style=\"margin-right: 10px;\"> ? </span>\n      <input type=\"text\" name=\"setWantPage\" class=\"setinput_style1 blue setWantPage\"\n      value = '-1'>\n      &nbsp;&nbsp;&nbsp;\n      <span class=\"setWantPageTip2 gray1\">-1 或者大于 0 的数字</span>\n      </span>\n      </p>\n      <p class=\"option\" data-no=\"2\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_下载作品类型的提示')}\">${lang.transl('_下载作品类型')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"downType0\" id=\"setWorkType0\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setWorkType0\"> ${lang.transl('_插画')}&nbsp;</label>\n      <input type=\"checkbox\" name=\"downType1\" id=\"setWorkType1\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setWorkType1\"> ${lang.transl('_漫画')}&nbsp;</label>\n      <input type=\"checkbox\" name=\"downType2\" id=\"setWorkType2\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setWorkType2\"> ${lang.transl('_动图')}&nbsp;</label>\n      <input type=\"checkbox\" name=\"downType3\" id=\"setWorkType3\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setWorkType3\"> ${lang.transl('_小说')}&nbsp;</label>\n      </p>\n      <p class=\"option\" data-no=\"21\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_下载作品类型的提示')}\">${lang.transl('_下载作品类型')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"downSingleImg\" id=\"setDownSingleImg\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setDownSingleImg\"> ${lang.transl('_单图作品')}&nbsp;</label>\n      <input type=\"checkbox\" name=\"downMultiImg\" id=\"setDownMultiImg\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setDownMultiImg\"> ${lang.transl('_多图作品')}&nbsp;</label>\n      </p>\n      <p class=\"option\" data-no=\"23\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_下载作品类型的提示')}\">${lang.transl('_下载作品类型')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"downColorImg\" id=\"setDownColorImg\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setDownColorImg\"> ${lang.transl('_彩色图片')}&nbsp;</label>\n      <input type=\"checkbox\" name=\"downBlackWhiteImg\" id=\"setDownBlackWhiteImg\" class=\"need_beautify checkbox_common\" checked>\n      <span class=\"beautify_checkbox\"></span>\n      <label for=\"setDownBlackWhiteImg\"> ${lang.transl('_黑白图片')}&nbsp;</label>\n      </p>\n      <p class=\"option\" data-no=\"3\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_怎样下载多图作品')}\">${lang.transl('_多图下载设置')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"firstFewImagesSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"firstFewImagesSwitch\">\n      ${lang.transl('_下载前几张图片')}&nbsp;\n      <input type=\"text\" name=\"firstFewImages\" class=\"setinput_style1 blue\" value=\"1\">\n      </span>\n      </p>\n      <p class=\"option\" data-no=\"6\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_只下载已收藏的提示')}\">${lang.transl('_只下载已收藏')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"setOnlyBmk\" id=\"setOnlyBmk\" class=\"need_beautify checkbox_switch\"> \n      <span class=\"beautify_switch\"></span>\n      </p>\n      <p class=\"option\" data-no=\"5\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_设置收藏数量的提示')}\">${lang.transl('_设置收藏数量')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"BMKNumSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"BMKNumSwitch\">\n      <span>${lang.transl('_最小值')}&nbsp;</span>\n      <input type=\"text\" name=\"BMKNumMin\" class=\"setinput_style1 blue bmkNum\" value=\"0\">\n      <span>${lang.transl('_最大值')}&nbsp;</span>\n      <input type=\"text\" name=\"BMKNumMax\" class=\"setinput_style1 blue bmkNum\" value=\"0\">\n      </span>\n      </p>\n      <p class=\"option\" data-no=\"7\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_筛选宽高的按钮Title')} ${lang.transl('_筛选宽高的提示文字')}\">${lang.transl('_筛选宽高的按钮文字')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"setWHSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"setWHSwitch\">\n      <input type=\"text\" name=\"setWidth\" class=\"setinput_style1 blue\" value=\"0\">\n      <input type=\"radio\" name=\"setWidthAndOr\" id=\"setWidth_AndOr1\" class=\"need_beautify radio\" value=\"&\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"setWidth_AndOr1\">and&nbsp;</label>\n      <input type=\"radio\" name=\"setWidthAndOr\" id=\"setWidth_AndOr2\" class=\"need_beautify radio\" value=\"|\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"setWidth_AndOr2\">or&nbsp;</label>\n      <input type=\"text\" name=\"setHeight\" class=\"setinput_style1 blue\" value=\"0\">\n      </span>\n      </p>\n      <p class=\"option\" data-no=\"8\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_设置宽高比例Title')}\">${lang.transl('_设置宽高比例')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"ratioSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"ratioSwitch\">\n      <input type=\"radio\" name=\"ratio\" id=\"ratio1\" class=\"need_beautify radio\" value=\"1\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"ratio1\"> ${lang.transl('_横图')}&nbsp; </label>\n      <input type=\"radio\" name=\"ratio\" id=\"ratio2\" class=\"need_beautify radio\" value=\"2\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"ratio2\"> ${lang.transl('_竖图')}&nbsp; </label>\n      <input type=\"radio\" name=\"ratio\" id=\"ratio3\" class=\"need_beautify radio\" value=\"3\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"ratio3\"> ${lang.transl('_输入宽高比')}</label>\n      <input type=\"text\" name=\"userRatio\" class=\"setinput_style1 blue\" value=\"\">\n      </span>\n      </p>\n      <p class=\"option\" data-no=\"9\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_设置id范围提示')}\">${lang.transl('_设置id范围')}&nbsp;&nbsp; <span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"idRangeSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"idRangeSwitch\">\n      <input type=\"radio\" name=\"idRange\" id=\"idRange1\" class=\"need_beautify radio\" value=\"1\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"idRange1\">  ${lang.transl('_大于')}&nbsp; </label>\n      <input type=\"radio\" name=\"idRange\" id=\"idRange2\" class=\"need_beautify radio\" value=\"2\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"idRange2\">  ${lang.transl('_小于')}&nbsp; </label>\n      <input type=\"text\" name=\"idRangeInput\" class=\"setinput_style1 w100 blue\" value=\"\">\n      </span>\n      </p>\n      <p class=\"option\" data-no=\"10\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_设置投稿时间提示')}\">${lang.transl('_设置投稿时间')} <span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"postDate\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"postDate\">\n      <input type=\"datetime-local\" name=\"postDateStart\" placeholder=\"yyyy-MM-dd HH:mm\" class=\"setinput_style1 postDate blue\" value=\"\">\n      &nbsp;-&nbsp;\n      <input type=\"datetime-local\" name=\"postDateEnd\" placeholder=\"yyyy-MM-dd HH:mm\" class=\"setinput_style1 postDate blue\" value=\"\">\n      </span>\n      </p>\n      <p class=\"option\" data-no=\"11\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_必须tag的提示文字')}\">${lang.transl('_必须含有tag')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"needTagSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"needTagSwitch\">\n      <input type=\"text\" name=\"needTag\" class=\"setinput_style1 blue setinput_tag\">\n      </span>\n      </p>\n      <p class=\"option\" data-no=\"12\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_排除tag的提示文字')}\">${lang.transl('_不能含有tag')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"notNeedTagSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"notNeedTagSwitch\">\n      <input type=\"text\" name=\"notNeedTag\" class=\"setinput_style1 blue setinput_tag\">\n      </span>\n      </p>\n      <input type=\"hidden\" name=\"debut\" value=\"0\">\n\n      <slot data-name=\"crawlBtns\" class=\"centerWrap_btns\"></slot>\n    </div>\n    <div class=\"con\">\n    <p class=\"option\" data-no=\"13\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_设置文件夹名的提示')}\">${lang.transl('_设置文件名')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"text\" name=\"userSetName\" class=\"setinput_style1 blue fileNameRule\" value=\"{id}\">\n      &nbsp;\n      <select name=\"fileNameSelect\">\n        <option value=\"default\">…</option>\n        <option value=\"{id}\">{id}</option>\n        <option value=\"{user}\">{user}</option>\n        <option value=\"{user_id}\">{user_id}</option>\n        <option value=\"{title}\">{title}</option>\n        <option value=\"{p_title}\">{p_title}</option>\n        <option value=\"{tags}\">{tags}</option>\n        <option value=\"{tags_translate}\">{tags_translate}</option>\n        <option value=\"{p_tag}\">{p_tag}</option>\n        <option value=\"{type}\">{type}</option>\n        <option value=\"{bmk}\">{bmk}</option>\n        <option value=\"{rank}\">{rank}</option>\n        <option value=\"{date}\">{date}</option>\n        <option value=\"{px}\">{px}</option>\n        <option value=\"{series_title}\">{series_title}</option>\n        <option value=\"{series_order}\">{series_order}</option>\n        <option value=\"{id_num}\">{id_num}</option>\n        <option value=\"{p_num}\">{p_num}</option>\n        </select>\n      &nbsp;&nbsp;\n      <span class=\"showFileNameTip\">？</span>\n      </p>\n      <p class=\"fileNameTip tip\">\n      <strong>${lang\r\n    .transl('_设置文件夹名的提示')\r\n    .replace('<br>', '. ')}</strong>\n      <br>\n      <span class=\"blue\">{id}</span>\n      ${lang.transl('_命名标记id')}\n      <br>\n      <span class=\"blue\">{user}</span>\n      ${lang.transl('_命名标记user')}\n      <br>\n      <span class=\"blue\">{user_id}</span>\n      ${lang.transl('_命名标记userid')}\n      <br>\n      <span class=\"blue\">{title}</span>\n      ${lang.transl('_命名标记title')}\n      <br>\n      <span class=\"blue\">{p_title}</span>\n      ${lang.transl('_文件夹标记PTitle')}\n      <br>\n      <span class=\"blue\">{tags}</span>\n      ${lang.transl('_命名标记tags')}\n      <br>\n      <span class=\"blue\">{tags_translate}</span>\n      ${lang.transl('_命名标记tags_trans')}\n      <br>\n      <span class=\"blue\">{p_tag}</span>\n      ${lang.transl('_文件夹标记PTag')}\n      <br>\n      <span class=\"blue\">{type}</span>\n      ${lang.transl('_命名标记type')}\n      <br>\n      <span class=\"blue\">{bmk}</span>\n      ${lang.transl('_命名标记bmk')}\n      <br>\n      <span class=\"blue\">{rank}</span>\n      ${lang.transl('_命名标记rank')}\n      <br>\n      <span class=\"blue\">{date}</span>\n      ${lang.transl('_命名标记date')}\n      <br>\n      <span class=\"blue\">{px}</span>\n      ${lang.transl('_命名标记px')}\n      <br>\n      <span class=\"blue\">{series_title}</span>\n      ${lang.transl('_命名标记seriesTitle')}\n      <br>\n      <span class=\"blue\">{series_order}</span>\n      ${lang.transl('_命名标记seriesOrder')}\n      <br>\n      <span class=\"blue\">{id_num}</span>\n      ${lang.transl('_命名标记id_num')}\n      <br>\n      <span class=\"blue\">{p_num}</span>\n      ${lang.transl('_命名标记p_num')}\n      <br>\n      ${lang.transl('_命名标记提醒')}\n      </p>\n      <p class=\"option\" data-no=\"14\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_添加字段名称提示')}\">${lang.transl('_添加命名标记前缀')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"tagNameToFileName\" id=\"setTagNameToFileName\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      </p>\n      <p class=\"option\" data-no=\"22\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_第一张图不带序号说明')}\">${lang.transl('_第一张图不带序号')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"noSerialNo\" id=\"setNoSerialNo\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      </p>\n      <p class=\"option\" data-no=\"19\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_多图建立目录提示')}\">${lang.transl('_多图建立目录')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"multipleImageDir\" id=\"setMultipleImageDir\" class=\"need_beautify checkbox_switch\" >\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"multipleImageDir\">\n      <span>${lang.transl('_目录名使用')}</span>\n      <input type=\"radio\" name=\"multipleImageFolderName\" id=\"multipleImageFolderName1\" class=\"need_beautify radio\" value=\"1\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"multipleImageFolderName1\"> ID&nbsp; </label>\n      <input type=\"radio\" name=\"multipleImageFolderName\" id=\"multipleImageFolderName2\" class=\"need_beautify radio\" value=\"2\">\n      <span class=\"beautify_radio\"></span>\n      <label for=\"multipleImageFolderName2\"> ${lang.transl('_命名规则')}&nbsp; </label>\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"15\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_快速下载建立文件夹提示')}\">${lang.transl('_快速下载建立文件夹')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"alwaysFolder\" id=\"setAlwaysFolder\" class=\"need_beautify checkbox_switch\" >\n      <span class=\"beautify_switch\"></span>\n      </p>\n\n      <slot data-name=\"namingBtns\" class=\"centerWrap_btns\"></slot>\n\n      <p class=\"option\" data-no=\"25\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_不符合要求的文件不会被保存')}\">\n      ${lang.transl('_文件体积限制')} <span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"sizeSwitch\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"sizeSwitch\">\n      <input type=\"text\" name=\"sizeMin\" class=\"setinput_style1 blue\" value=\"0\">MB\n      &nbsp;-&nbsp;\n      <input type=\"text\" name=\"sizeMax\" class=\"setinput_style1 blue\" value=\"100\">MB\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"16\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_线程数字')}\">${lang.transl('_设置下载线程')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"text\" name=\"downloadThread\" class=\"setinput_style1 blue\" value=\"5\">\n      </p>\n\n      <p class=\"option\" data-no=\"17\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_快速下载的提示')}\">${lang.transl('_自动开始下载')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"quietDownload\" id=\"setQuietDownload\" class=\"need_beautify checkbox_switch\" checked>\n      <span class=\"beautify_switch\"></span>\n      </p>\n\n      <slot data-name=\"downloadArea\"></slot>\n      <slot data-name=\"progressBar\"></slot>\n    </div>\n    \n    <div class=\"con\">\n\n      <p class=\"option\" data-no=\"4\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_动图保存格式title')}\">${lang.transl('_动图保存格式')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"radio\" name=\"ugoiraSaveAs\" id=\"ugoiraSaveAs1\" class=\"need_beautify radio\" value=\"webm\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"ugoiraSaveAs1\"> ${lang.transl('_webmVideo')} &nbsp;</label>\n      <input type=\"radio\" name=\"ugoiraSaveAs\" id=\"ugoiraSaveAs3\" class=\"need_beautify radio\" value=\"gif\"> \n      <span class=\"beautify_radio\"></span>\n      <label for=\"ugoiraSaveAs3\">${lang.transl('_gif')} &nbsp;</label>\n      <input type=\"radio\" name=\"ugoiraSaveAs\" id=\"ugoiraSaveAs2\" class=\"need_beautify radio\" value=\"zip\"> \n      <span class=\"beautify_radio\"></span>\n      <label for=\"ugoiraSaveAs2\">${lang.transl('_zipFile')} &nbsp;</label>\n      </p>\n\n      <p class=\"option\" data-no=\"24\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_同时转换多少个动图警告')}\">${lang.transl('_同时转换多少个动图')}</span>\n      <input type=\"text\" name=\"convertUgoiraThread\" class=\"setinput_style1 blue\" value=\"1\">\n      <span class=\"has_tip gray1\" data-tip=\"${lang.transl('_同时转换多少个动图警告')}\"> ${lang.transl('_提示')} </span>\n      </p>\n\n      <p class=\"option\" data-no=\"26\">\n      <span class=\"settingNameStyle1\">${lang.transl('_小说保存格式')}<span class=\"gray1\"> &nbsp; </span></span>\n      <input type=\"radio\" name=\"novelSaveAs\" id=\"novelSaveAs1\" class=\"need_beautify radio\" value=\"txt\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label for=\"novelSaveAs1\"> txt &nbsp;</label>\n      <input type=\"radio\" name=\"novelSaveAs\" id=\"novelSaveAs2\" class=\"need_beautify radio\" value=\"epub\"> \n      <span class=\"beautify_radio\"></span>\n      <label for=\"novelSaveAs2\"> epub &nbsp;</label>\n      </p>\n      \n      <p class=\"option\" data-no=\"27\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_在小说里保存元数据提示')}\">${lang.transl('_在小说里保存元数据')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"saveNovelMeta\" class=\"need_beautify checkbox_switch\" >\n      <span class=\"beautify_switch\"></span>\n      </p>\n\n      <p class=\"option\" data-no=\"20\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_启用快速收藏说明')}\">${lang.transl('_启用快速收藏')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"quickBookmarks\" id=\"quickBookmarks\" class=\"need_beautify checkbox_switch\" checked> \n      <span class=\"beautify_switch\"></span>\n      </p>\n\n      <p class=\"option\" data-no=\"28\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_不下载重复文件的提示')}\">\n      ${lang.transl('_不下载重复文件')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"deduplication\" class=\"need_beautify checkbox_switch\">\n      <span class=\"beautify_switch\"></span>\n      <span class=\"subOptionWrap\" data-show=\"deduplication\">\n      <span>&nbsp; ${lang.transl('_策略')}</span>\n      <input type=\"radio\" name=\"dupliStrategy\" id=\"dupliStrategy1\" class=\"need_beautify radio\" value=\"strict\" checked>\n      <span class=\"beautify_radio\"></span>\n      <label class=\"has_tip\" for=\"dupliStrategy1\" data-tip=\"${lang.transl('_严格模式说明')}\">${lang.transl('_严格')}</label>\n      <input type=\"radio\" name=\"dupliStrategy\" id=\"dupliStrategy2\" class=\"need_beautify radio\" value=\"loose\">\n      <span class=\"beautify_radio\"></span>\n      <label class=\"has_tip\" for=\"dupliStrategy2\" data-tip=\"${lang.transl('_宽松模式说明')}\">${lang.transl('_宽松')}</label>\n      &nbsp;&nbsp;\n      <a class=\"gray1\" id=\"clearDownloadRecords\" href=\"javascript:void(0)\">${lang.transl('_清除下载记录')}</a>\n      </span>\n      </p>\n\n      <p class=\"option\" data-no=\"18\">\n      <span class=\"has_tip settingNameStyle1\" data-tip=\"${lang.transl('_预览搜索结果说明')}\">${lang.transl('_预览搜索结果')}<span class=\"gray1\"> ? </span></span>\n      <input type=\"checkbox\" name=\"previewResult\" id=\"setPreviewResult\" class=\"need_beautify checkbox_switch\" checked>\n      <span class=\"beautify_switch\"></span>\n      </p>\n\n      <slot data-name=\"otherBtns\" class=\"centerWrap_btns\"></slot>\n    </div>\n  </div>\n</form>`;\r\nexport default formHtml;\r\n","// 传入图片 url，转换成 icon 文件。这是给下载器使用的，所以功能比较简单。\r\n// icon 文件结构 https://www.cnblogs.com/cswuyg/p/3603707.html\r\n// 输入选项\r\n// source 可以传入一个图片的 url，或者一个已加载完成的 img 元素\r\n// size 指定图标尺寸。0 会让程序自行选择一个最接近的标准尺寸。例如图片宽度是 120 则会使用 96 的尺寸。\r\n// shape 指定图标的形状。square 正方形，circle 圆形，fillet 带有圆角的正方形\r\n// 输出\r\n// 转换成功后，返回 icon 文件的 Blob 对象\r\n// 生成的 icon 总是正方形。如果图片的长度和宽度不相等，则会以窄边作为宽度，从图片的起点裁剪出一个正方形\r\n// 生成的 icon 只会包含一个图标，而不是多个尺寸的多个图标。图标是 32 位 png 图像。\r\nclass ImageToIcon {\r\n    async convert(opt) {\r\n        return new Promise(async (resolve, reject) => {\r\n            // 加载图片\r\n            const img = await this.loadImage(opt.source);\r\n            // 创建画布\r\n            const canvas = this.createCanvas(opt.size, img);\r\n            // 绘制图像\r\n            const ctx = this.draw(canvas, img, opt.shape);\r\n            // 把图像转换为 png 图像\r\n            const pngBlob = await this.getPngBlob(canvas);\r\n            // 获取 png 图像的 buffer\r\n            const buffer = await pngBlob.arrayBuffer();\r\n            // 创建 ico 文件\r\n            const blob = this.createIco(canvas.width, canvas.height, buffer);\r\n            resolve(blob);\r\n        });\r\n    }\r\n    async loadImage(source) {\r\n        return new Promise(async (resolve, reject) => {\r\n            if (typeof source === 'string') {\r\n                // 请求图片，并为其生成 BlobURL，解决图片跨域导致 canvas 污染的问题\r\n                const res = await fetch(source, {\r\n                    method: 'get',\r\n                    credentials: 'include',\r\n                });\r\n                const blob = await res.blob();\r\n                const url = URL.createObjectURL(blob);\r\n                // 创建 img 元素\r\n                const i = document.createElement('img');\r\n                i.src = url;\r\n                i.onload = function () {\r\n                    resolve(i);\r\n                };\r\n            }\r\n            else if (source.nodeName === 'IMG') {\r\n                // 直接提供的 img 元素如果其图片是跨域的话，也会有  canvas 污染问题\r\n                resolve(source);\r\n            }\r\n            else {\r\n                reject('Unrecognized opt.source');\r\n            }\r\n        });\r\n    }\r\n    createCanvas(size, img) {\r\n        // 确定画布尺寸\r\n        if (size === 0) {\r\n            // 使用窄边的长度作为画布尺寸\r\n            if (img.naturalWidth < img.naturalHeight) {\r\n                size = img.naturalWidth;\r\n            }\r\n            else {\r\n                size = img.naturalHeight;\r\n            }\r\n            // 使用最接近窄边长度的标准尺寸\r\n            const sizeList = [16, 32, 48, 96, 128, 256, 512];\r\n            for (const num of sizeList) {\r\n                if (size >= num) {\r\n                    size = num;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const c = document.createElement('canvas');\r\n        c.width = size;\r\n        c.height = size;\r\n        return c;\r\n    }\r\n    draw(canvas, img, shape) {\r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) {\r\n            console.error('draw error: ctx is null');\r\n            return;\r\n        }\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        // 计算图像被绘制的宽高。比较短的一边占满画布，比较长的一边则根据比例计算绘制的部分\r\n        let dw = 0;\r\n        let dh = 0;\r\n        // 竖图\r\n        if (img.naturalWidth < img.naturalHeight) {\r\n            dw = canvas.width;\r\n            dh = dw / img.naturalWidth * img.naturalHeight;\r\n        }\r\n        else {\r\n            // 横图\r\n            dh = canvas.height;\r\n            dw = dh / img.naturalHeight * img.naturalWidth;\r\n        }\r\n        // 绘制方形\r\n        if (shape === 'square') {\r\n            ctx.drawImage(img, 0, 0, dw, dh);\r\n        }\r\n        // 绘制圆形\r\n        if (shape === 'circle') {\r\n            let circle = {\r\n                x: canvas.width / 2,\r\n                y: canvas.width / 2,\r\n                r: canvas.width / 2\r\n            };\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.arc(circle.x, circle.y, circle.r, 0, Math.PI * 2, false);\r\n            ctx.clip();\r\n            ctx.drawImage(img, 0, 0, dw, dh);\r\n            ctx.restore();\r\n        }\r\n        // 绘制圆角矩形\r\n        if (shape === 'fillet') {\r\n            let x = 0;\r\n            let y = 0;\r\n            // 当图标尺寸大于 16 时，设置留白距离\r\n            if (canvas.width > 16) {\r\n                let num = 10 / 256; // 规定留白的比例，即尺寸为 256 时四周留白均为 10 px\r\n                x = Math.ceil(num * canvas.width);\r\n                y = Math.ceil(num * canvas.width);\r\n            }\r\n            // 去掉留白后，最后要保存的图片区域的宽高\r\n            const w = canvas.width - x * 2;\r\n            const h = canvas.height - y * 2;\r\n            // 圆角的半径，设置为保留区域宽高的 1/8\r\n            const r = Math.floor(w / 8);\r\n            ctx.beginPath();\r\n            ctx.moveTo(x + r, y);\r\n            ctx.arcTo(x + w, y, x + w, y + h, r);\r\n            ctx.arcTo(x + w, y + h, x, y + h, r);\r\n            ctx.arcTo(x, y + h, x, y, r);\r\n            ctx.arcTo(x, y, x + w, y, r);\r\n            ctx.closePath();\r\n            ctx.clip();\r\n            ctx.drawImage(img, 0, 0, 256, 256);\r\n        }\r\n        return ctx;\r\n    }\r\n    async getPngBlob(canvas) {\r\n        return new Promise((resolve, reject) => {\r\n            canvas.toBlob(blob => {\r\n                if (!blob) {\r\n                    reject('blob is null');\r\n                }\r\n                else {\r\n                    resolve(blob);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    createIco(width, height, pngBuffer) {\r\n        // ico 文件头\r\n        const fileHead = new ArrayBuffer(6);\r\n        const v1 = new DataView(fileHead);\r\n        v1.setInt16(0, 0, true); // idReserved\r\n        v1.setInt16(2, 1, true); // idType\r\n        v1.setInt16(4, 1, true); // idCount  目前只保存 1 个图标资源\r\n        // 描述图标数据。因为只有 1 个图标资源所以只有 1 份数据\r\n        const imgDataHead = new ArrayBuffer(16);\r\n        const v2 = new DataView(imgDataHead);\r\n        v2.setInt8(0, width); // Width, in pixels, of the image\r\n        v2.setInt8(1, height); // Height, in pixels, of the image\r\n        v2.setInt8(2, 0); // Number of colors in image (0 if >=8bpp)\r\n        v2.setInt8(3, 0); // Reserved ( must be 0)\r\n        v2.setInt16(4, 1, true); // Color Planes\r\n        v2.setInt16(6, 32, true); // Bits per pixel\r\n        v2.setInt32(8, pngBuffer.byteLength, true); // How many bytes in this resource?\r\n        v2.setInt32(12, 22, true); // Where in the file is this image?\r\n        // 生成 blob 对象\r\n        return new Blob([fileHead, imgDataHead, pngBuffer], {\r\n            type: 'image/vnd.microsoft.icon'\r\n        });\r\n    }\r\n}\r\nconst img2ico = new ImageToIcon();\r\nexport { img2ico };\r\n","// 图片查看器\r\n/// <reference path = \"./Viewer.d.ts\" />\r\nimport { API } from './API';\r\nimport { themeColor } from './ThemeColor';\r\nclass ImgViewer {\r\n    constructor() {\r\n        this.viewerWarpper = document.createElement('div'); // 图片列表的容器\r\n        this.viewerUl = document.createElement('ul'); // 图片列表的 ul 元素\r\n        this.init();\r\n    }\r\n    // 初始化图片查看器\r\n    newViewer(pageCount, firsturl) {\r\n        // 因为选项里的 size 是枚举类型，所以在这里也要定义一个枚举\r\n        let ToolbarButtonSize;\r\n        (function (ToolbarButtonSize) {\r\n            ToolbarButtonSize[\"Small\"] = \"small\";\r\n            ToolbarButtonSize[\"Medium\"] = \"medium\";\r\n            ToolbarButtonSize[\"Large\"] = \"large\";\r\n        })(ToolbarButtonSize || (ToolbarButtonSize = {}));\r\n        this.myViewer = new Viewer(this.viewerUl, {\r\n            toolbar: {\r\n                zoomIn: 0,\r\n                zoomOut: 0,\r\n                oneToOne: 1,\r\n                reset: 0,\r\n                prev: 1,\r\n                play: {\r\n                    show: 0,\r\n                    size: ToolbarButtonSize.Large,\r\n                },\r\n                next: 1,\r\n                rotateLeft: 0,\r\n                rotateRight: 0,\r\n                flipHorizontal: 0,\r\n                flipVertical: 0,\r\n            },\r\n            url(image) {\r\n                return image.dataset.src;\r\n            },\r\n            viewed(ev) {\r\n                // 当图片显示完成（加载完成）后，预加载下一张图片\r\n                let index = ev.detail.index;\r\n                if (index < pageCount - 1) {\r\n                    index++;\r\n                }\r\n                const nextImg = firsturl.replace('p0', 'p' + index);\r\n                const img = new Image();\r\n                img.src = nextImg;\r\n            },\r\n            // 取消一些动画，比如切换图片时，图片从小变大出现的动画\r\n            transition: false,\r\n            // 取消键盘支持，主要是用键盘左右方向键切换的话，会和 pixiv 页面产生冲突。（pixiv 页面上，左右方向键会切换作品）\r\n            keyboard: false,\r\n            // 不显示 title（图片名和宽高信息）\r\n            title: false,\r\n            // 不显示缩放比例\r\n            tooltip: false,\r\n        });\r\n    }\r\n    init() {\r\n        // 如果之前已经存在图片查看器的元素，则删除重新创建\r\n        // 最好不要重复使用之前的元素。在页面无刷新切换之后，如果复用了之前的元素，只是修改一些内容，那么 Viewer 还是会使用之前的数据，导致出错。\r\n        const test = document.querySelector('main #viewerWarpper');\r\n        test && test.remove();\r\n        // 每次创建新的图片查看器时，删除之前查看器的元素，否则会存在多个\r\n        const test2 = document.querySelector('.viewer-container');\r\n        test2 && test2.remove();\r\n        this.createViewer();\r\n    }\r\n    // 创建图片查看器 html 元素，并绑定一些事件，这个函数只会在初始化时执行一次\r\n    createViewer() {\r\n        if (!document.querySelector('main figcaption')) {\r\n            // 等到作品主体部分的元素生成之后再创建查看器\r\n            setTimeout(() => {\r\n                this.createViewer();\r\n            }, 300);\r\n            return;\r\n        }\r\n        // 查看器图片列表元素的结构： div#viewerWarpper > ul > li > img\r\n        this.viewerWarpper = document.createElement('div');\r\n        this.viewerWarpper.id = 'viewerWarpper';\r\n        this.viewerUl = document.createElement('ul');\r\n        this.viewerWarpper.appendChild(this.viewerUl);\r\n        themeColor.register(this.viewerWarpper);\r\n        document\r\n            .querySelector('main figcaption')\r\n            .insertAdjacentElement('beforebegin', this.viewerWarpper);\r\n        // 图片查看器显示之后\r\n        this.viewerUl.addEventListener('shown', () => {\r\n            // 显示相关元素\r\n            this.showViewerOther();\r\n            // 点击 1：1 按钮时，全屏查看\r\n            document\r\n                .querySelector('.viewer-one-to-one')\r\n                .addEventListener('click', () => {\r\n                this.hideViewerOther(); // 隐藏查看器的其他元素\r\n                // 进入全屏\r\n                document.body.requestFullscreen();\r\n                // 使图片居中显示，必须加延迟\r\n                setTimeout(() => {\r\n                    this.setViewerCenter();\r\n                }, 100);\r\n                setInterval(() => {\r\n                    this.zoomToMax();\r\n                }, 100);\r\n            });\r\n        });\r\n        // 全屏状态下，查看和切换图片时，显示比例始终为 100%\r\n        this.viewerUl.addEventListener('view', () => {\r\n            if (this.isFullscreen()) {\r\n                setTimeout(() => {\r\n                    // 通过点击 1:1 按钮，调整为100%并居中。这里必须要加延时，否则点击的时候图片还是旧的\r\n                    ;\r\n                    document.querySelector('.viewer-one-to-one').click();\r\n                }, 50);\r\n            }\r\n        });\r\n        // 隐藏查看器时，如果还处于全屏，则退出全屏\r\n        this.viewerUl.addEventListener('hidden', () => {\r\n            if (this.isFullscreen()) {\r\n                document.exitFullscreen();\r\n            }\r\n        });\r\n        // esc 退出图片查看器\r\n        document.addEventListener('keyup', (event) => {\r\n            if (event.code === 'Escape') {\r\n                this.myViewer && this.myViewer.hide();\r\n            }\r\n        });\r\n        void [\r\n            'fullscreenchange',\r\n            'webkitfullscreenchange',\r\n            'mozfullscreenchange',\r\n        ].forEach((arg) => {\r\n            // 检测全屏状态变化，目前有兼容性问题（这里也相当于绑定了按 esc 退出的事件）\r\n            document.addEventListener(arg, () => {\r\n                // 退出全屏\r\n                if (!this.isFullscreen()) {\r\n                    this.showViewerOther();\r\n                }\r\n            });\r\n        });\r\n        this.updateViewer();\r\n    }\r\n    // 根据作品信息，更新图片查看器配置。每当页面更新时执行一次\r\n    async updateViewer() {\r\n        this.viewerWarpper.style.display = 'none'; // 先隐藏 viewerWarpper\r\n        // 获取作品信息\r\n        const data = await API.getArtworkData(API.getIllustId());\r\n        const body = data.body;\r\n        // 处理插画或漫画作品，不处理动图作品\r\n        if (body.illustType === 0 || body.illustType === 1) {\r\n            // 有多张图片时，创建缩略图\r\n            if (body.pageCount > 1) {\r\n                const { thumb, original } = body.urls;\r\n                // 生成缩略图列表\r\n                let html = [];\r\n                for (let index = 0; index < body.pageCount; index++) {\r\n                    const str = `<li><img src=\"${thumb.replace('p0', 'p' + index)}\" data-src=\"${original.replace('p0', 'p' + index)}\"></li>`;\r\n                    html.push(str);\r\n                }\r\n                this.viewerUl.innerHTML = html.join('');\r\n                // 数据更新后，显示 viewerWarpper\r\n                this.viewerWarpper.style.display = 'block';\r\n                // 销毁看图组件\r\n                if (this.myViewer) {\r\n                    this.myViewer.destroy();\r\n                }\r\n                // 配置看图组件\r\n                this.newViewer(body.pageCount, original);\r\n                // 预加载第一张图片\r\n                const img = new Image();\r\n                img.src = original;\r\n            }\r\n        }\r\n    }\r\n    // 隐藏查看器的其他元素\r\n    hideViewerOther() {\r\n        document\r\n            .querySelector('.viewer-container')\r\n            .classList.add('black-background');\r\n        // 隐藏底部的其他元素，仍然显示左右切换按钮\r\n        const close = document.querySelector('.viewer-close');\r\n        const oneToOne = document.querySelector('.viewer-one-to-one');\r\n        const navbar = document.querySelector('.viewer-navbar');\r\n        for (const element of [close, oneToOne, navbar]) {\r\n            element.style.display = 'none';\r\n        }\r\n    }\r\n    // 显示查看器的其他元素\r\n    showViewerOther() {\r\n        document\r\n            .querySelector('.viewer-container')\r\n            .classList.remove('black-background');\r\n        // 显示底部隐藏的元素\r\n        const close = document.querySelector('.viewer-close');\r\n        const oneToOne = document.querySelector('.viewer-one-to-one');\r\n        const navbar = document.querySelector('.viewer-navbar');\r\n        for (const element of [close, oneToOne, navbar]) {\r\n            element.style.display = 'block';\r\n        }\r\n    }\r\n    zoomToMax() {\r\n        const img = document.querySelector('.viewer-move');\r\n        if (this.isFullscreen() && parseInt(img.style.width) < img.naturalWidth) {\r\n            // img.style.width=img.naturalWidth+'px'\r\n            // img.style.height = img.naturalHeight+'px'\r\n            this.myViewer.zoomTo(1);\r\n        }\r\n    }\r\n    // 在图片100%显示时，使其居中\r\n    setViewerCenter() {\r\n        // 获取图片宽高\r\n        const imgInfo = document.querySelector('.viewer-title').textContent;\r\n        // 如果图片尚未加载出来的话，就没有内容，就过一会儿再执行\r\n        if (!imgInfo) {\r\n            setTimeout(() => {\r\n                this.setViewerCenter();\r\n            }, 200);\r\n            return;\r\n        }\r\n        const [imgWidth, imgHeight] = /\\d{1,5} × \\d{1,5}/\r\n            .exec(imgInfo)[0]\r\n            .split(' × ');\r\n        // > '66360324_p5_master1200.jpg (919 × 1300)'\r\n        // < [\"919\", \"1300\"]\r\n        // 获取网页宽高\r\n        const htmlWidth = document.documentElement.clientWidth;\r\n        const htmlHeight = document.documentElement.clientHeight;\r\n        // 设置边距\r\n        const setWidth = (htmlWidth - parseInt(imgWidth)) / 2;\r\n        let setHeight = (htmlHeight - parseInt(imgHeight)) / 2;\r\n        // 当图片高度大于浏览器窗口高度时，居顶显示而不是居中\r\n        // if (setHeight < 0) {\r\n        //   setHeight = 0\r\n        // }\r\n        this.myViewer.zoomTo(1);\r\n        this.myViewer.moveTo(setWidth, setHeight);\r\n    }\r\n    // 判断是否处于全屏状态\r\n    isFullscreen() {\r\n        return !!document.fullscreenElement;\r\n    }\r\n    // 判断看图器是否处于显示状态\r\n    viewerIsShow() {\r\n        const viewerContainer = document.querySelector('.viewer-container');\r\n        if (viewerContainer) {\r\n            return viewerContainer.classList.contains('viewer-in');\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\nexport { ImgViewer };\r\n","// 封装操作 IndexedDB 的一些公共方法，仅满足本程序使用，并不完善\r\nclass IndexedDB {\r\n    async open(DBName, DBVer, onUpgrade) {\r\n        return new Promise((resolve, reject) => {\r\n            const request = indexedDB.open(DBName, DBVer);\r\n            request.onupgradeneeded = (ev) => {\r\n                if (onUpgrade) {\r\n                    onUpgrade(request.result);\r\n                }\r\n            };\r\n            request.onsuccess = (ev) => {\r\n                this.db = request.result;\r\n                resolve(request.result);\r\n            };\r\n            request.onerror = (ev) => {\r\n                console.error('open indexDB failed');\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    async add(storeNames, data) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const r = this.db\r\n                .transaction(storeNames, 'readwrite')\r\n                .objectStore(storeNames)\r\n                .add(data);\r\n            r.onsuccess = (ev) => {\r\n                resolve(ev);\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('add failed');\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    async put(storeNames, data) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const r = this.db\r\n                .transaction(storeNames, 'readwrite')\r\n                .objectStore(storeNames)\r\n                .put(data);\r\n            r.onsuccess = (ev) => {\r\n                resolve(ev);\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('put failed');\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    // 如果没有找到对应的记录，则返回 null\r\n    async get(storeNames, key, index) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const store = this.db\r\n                .transaction(storeNames, 'readonly')\r\n                .objectStore(storeNames);\r\n            let r;\r\n            if (index !== undefined) {\r\n                const i = store.index(index);\r\n                r = i.get(key);\r\n            }\r\n            else {\r\n                r = store.get(key);\r\n            }\r\n            r.onsuccess = (ev) => {\r\n                const data = r.result;\r\n                if (data) {\r\n                    resolve(data);\r\n                }\r\n                resolve(null);\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('add failed');\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    async delete(storeNames, key) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const r = this.db\r\n                .transaction(storeNames, 'readwrite')\r\n                .objectStore(storeNames)\r\n                .delete(key);\r\n            r.onsuccess = (ev) => {\r\n                resolve(ev);\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('delete failed');\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    async clear(storeNames) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const r = this.db\r\n                .transaction(storeNames, 'readwrite')\r\n                .objectStore(storeNames)\r\n                .clear();\r\n            r.onsuccess = (ev) => {\r\n                resolve();\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('clear failed');\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n    async openCursor(storeNames, CB) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this.db === undefined) {\r\n                reject('Database is not defined');\r\n                return;\r\n            }\r\n            const r = this.db\r\n                .transaction(storeNames)\r\n                .objectStore(storeNames)\r\n                .openCursor();\r\n            r.onsuccess = (ev) => {\r\n                CB(r.result);\r\n                resolve(); // 这个 resolve 会在 cb 执行一次之后就触发\r\n            };\r\n            r.onerror = (ev) => {\r\n                console.error('openCursor failed');\r\n                reject(ev);\r\n            };\r\n        });\r\n    }\r\n}\r\nexport { IndexedDB };\r\n","// 初始化旧版收藏页面\r\nimport { InitPageBase } from './InitPageBase';\r\nimport { API } from './API';\r\nimport { Colors } from './Colors';\r\nimport { lang } from './Lang';\r\nimport { options } from './Options';\r\nimport { BookmarksAddTag } from './BookmarksAddTag';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nimport { DOM } from './DOM';\r\nimport { pageInfo } from './PageInfo';\r\nclass InitBookmarkLegacyPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.idList = []; // 储存从列表页获取到的 id\r\n        this.type = 'illusts'; // 页面是图片还是小说\r\n        this.tag = ''; // 储存当前页面带的 tag，不过有时并没有\r\n        this.isHide = false; // 当前页面是否显示的是非公开收藏\r\n        this.requsetNumber = 0; // 根据页数，计算要抓取的作品个数\r\n        this.onceRequest = 100; // 每次请求多少个数量\r\n        this.offset = 0; // 要去掉的作品数量\r\n        this.crawlRecommended = false; // 是否抓取推荐作品（收藏页面下方）\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n        // 添加下载推荐作品的按钮\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取推荐作品'), [\r\n            ['title', lang.transl('_抓取推荐作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            this.crawlRecommended = true;\r\n            this.readyCrawl();\r\n        }, false);\r\n        // 如果存在 token，则添加“添加 tag”按钮\r\n        if (API.getToken()) {\r\n            const btn = DOM.addBtn('otherBtns', Colors.green, lang.transl('_添加tag'), [['title', lang.transl('_添加tag')]]);\r\n            new BookmarksAddTag(btn);\r\n        }\r\n    }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        options.setWantPage({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n            value: '-1',\r\n        });\r\n        // 在书签页面隐藏只要书签选项\r\n        options.hideOption([6]);\r\n    }\r\n    getWantPage() {\r\n        let pageTip = '';\r\n        if (this.crawlRecommended) {\r\n            pageTip = lang.transl('_下载推荐作品');\r\n        }\r\n        else {\r\n            pageTip = lang.transl('_下载所有页面');\r\n        }\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x页'), pageTip);\r\n    }\r\n    nextStep() {\r\n        if (window.location.pathname.includes('/novel')) {\r\n            this.type = 'novels';\r\n        }\r\n        if (this.crawlRecommended) {\r\n            // 下载推荐作品\r\n            this.getRecommendedList();\r\n        }\r\n        else {\r\n            this.readyGetIdList();\r\n            // 获取 id 列表\r\n            this.getIdList();\r\n        }\r\n    }\r\n    readyGetIdList() {\r\n        // 每页个数\r\n        const onceNumber = 20;\r\n        // 如果前面有页数，就去掉前面页数的作品数量。即：从本页开始下载\r\n        const nowPage = API.getURLSearchField(location.href, 'p'); // 判断当前处于第几页，页码从 1 开始。也可能没有页码\r\n        if (nowPage) {\r\n            this.offset = (parseInt(nowPage) - 1) * onceNumber;\r\n        }\r\n        if (this.offset < 0) {\r\n            this.offset = 0;\r\n        }\r\n        // 根据页数设置，计算要下载的个数\r\n        this.requsetNumber = 0;\r\n        if (this.crawlNumber === -1) {\r\n            this.requsetNumber = 9999999;\r\n        }\r\n        else {\r\n            this.requsetNumber = onceNumber * this.crawlNumber;\r\n        }\r\n        this.tag = pageInfo.getPageTag;\r\n        // 判断是公开收藏还是非公开收藏\r\n        // 在新旧版 url 里，rest 都是在查询字符串里的\r\n        this.isHide = API.getURLSearchField(location.href, 'rest') === 'hide';\r\n        log.log(lang.transl('_正在抓取'));\r\n        if (this.crawlNumber === -1) {\r\n            log.log(lang.transl('_获取全部书签作品'));\r\n        }\r\n    }\r\n    // 获取用户的收藏作品列表\r\n    async getIdList() {\r\n        let data;\r\n        try {\r\n            data = await API.getBookmarkData(DOM.getUserId(), this.type, this.tag, this.offset, this.isHide);\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        if (data.body.works.length === 0 ||\r\n            this.idList.length >= this.requsetNumber) {\r\n            // 书签页获取完毕\r\n            return this.afterGetIdList();\r\n        }\r\n        else {\r\n            // 没有抓取完毕时，添加数据\r\n            const idType = this.type === 'illusts' ? 'unknown' : 'novels';\r\n            data.body.works.forEach((data) => this.idList.push({\r\n                type: idType,\r\n                id: data.id,\r\n            }));\r\n            this.offset += this.onceRequest; // 每次增加偏移量\r\n            // 重复抓取过程\r\n            this.getIdList();\r\n        }\r\n    }\r\n    // 获取作品 id 列表完毕之后\r\n    afterGetIdList() {\r\n        // 因为书签页面一次获取 100 个作品，大于一页的数量。所以可能会抓取多了，需要删除多余的作品\r\n        if (this.idList.length > this.requsetNumber) {\r\n            // 删除后面部分（较早收藏的），留下近期收藏的\r\n            this.idList.splice(this.requsetNumber, this.idList.length);\r\n            // 书签页面的 api 没有考虑页面上的排序顺序，获取到的 id 列表始终是按收藏顺序由近期到早期排列的\r\n        }\r\n        store.idList = store.idList.concat(this.idList);\r\n        this.getIdListFinished();\r\n    }\r\n    // 获取书签页面下方的推荐作品列表\r\n    getRecommendedList() {\r\n        const selector = this.type === 'illusts'\r\n            ? '#illust-recommend .image-item'\r\n            : '.novel-items>li';\r\n        const idType = this.type === 'illusts' ? 'unknown' : 'novels';\r\n        const getId = this.type === 'illusts' ? API.getIllustId : API.getNovelId;\r\n        // 获取下方已经加载出来的作品\r\n        const elements = document.querySelectorAll(selector);\r\n        if (elements.length === 0) {\r\n            this.crawlRecommended = false;\r\n            return this.noResult();\r\n        }\r\n        // 添加作品列表\r\n        for (const li of elements) {\r\n            const a = li.querySelector('a');\r\n            if (store.idList.length === this.crawlNumber) {\r\n                break;\r\n            }\r\n            store.idList.push({\r\n                type: idType,\r\n                id: getId(a.href),\r\n            });\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.type = 'illusts';\r\n        this.idList = [];\r\n        this.offset = 0;\r\n        this.tag = '';\r\n        this.listPageFinished = 0;\r\n        this.crawlRecommended = false; // 解除下载推荐作品的标记\r\n    }\r\n    sortResult() {\r\n        // 把作品数据反转，这样可以先下载收藏时间早的，后下载收藏时间近的\r\n        !this.crawlRecommended && store.result.reverse();\r\n    }\r\n}\r\nexport { InitBookmarkLegacyPage };\r\n","// 初始化新版收藏页面\r\nimport { InitPageBase } from './InitPageBase';\r\nimport { API } from './API';\r\nimport { Colors } from './Colors';\r\nimport { lang } from './Lang';\r\nimport { options } from './Options';\r\nimport { BookmarksAddTag } from './BookmarksAddTag';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nimport { DOM } from './DOM';\r\nimport { pageInfo } from './PageInfo';\r\nclass InitBookmarkPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.idList = []; // 储存从列表页获取到的 id\r\n        this.type = 'illusts'; // 页面是图片还是小说\r\n        this.tag = ''; // 储存当前页面带的 tag，不过有时并没有\r\n        this.isHide = false; // 当前页面是否显示的是非公开收藏\r\n        this.requsetNumber = 0; // 根据页数，计算要抓取的作品个数\r\n        this.onceRequest = 100; // 每次请求多少个数量\r\n        this.offset = 0; // 要去掉的作品数量\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n        // 如果存在 token，则添加“添加 tag”按钮\r\n        if (API.getToken()) {\r\n            const btn = DOM.addBtn('otherBtns', Colors.green, lang.transl('_添加tag'), [['title', lang.transl('_添加tag')]]);\r\n            new BookmarksAddTag(btn);\r\n        }\r\n    }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        options.setWantPage({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n            value: '-1',\r\n        });\r\n        // 在书签页面隐藏只要书签选项\r\n        options.hideOption([6]);\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x页'), lang.transl('_下载所有页面'));\r\n    }\r\n    nextStep() {\r\n        if (window.location.pathname.includes('/novel')) {\r\n            this.type = 'novels';\r\n        }\r\n        this.readyGetIdList();\r\n        this.getIdList();\r\n    }\r\n    readyGetIdList() {\r\n        // 每页个数\r\n        const onceNumber = 48;\r\n        // 如果前面有页数，就去掉前面页数的作品数量。即：从本页开始下载\r\n        const nowPage = API.getURLSearchField(location.href, 'p'); // 判断当前处于第几页，页码从 1 开始。也可能没有页码\r\n        if (nowPage) {\r\n            this.offset = (parseInt(nowPage) - 1) * onceNumber;\r\n        }\r\n        if (this.offset < 0) {\r\n            this.offset = 0;\r\n        }\r\n        // 根据页数设置，计算要下载的个数\r\n        this.requsetNumber = 0;\r\n        if (this.crawlNumber === -1) {\r\n            this.requsetNumber = 9999999;\r\n        }\r\n        else {\r\n            this.requsetNumber = onceNumber * this.crawlNumber;\r\n        }\r\n        this.tag = pageInfo.getPageTag;\r\n        // 判断是公开收藏还是非公开收藏\r\n        // 在新旧版 url 里，rest 都是在查询字符串里的\r\n        this.isHide = API.getURLSearchField(location.href, 'rest') === 'hide';\r\n        log.log(lang.transl('_正在抓取'));\r\n        if (this.crawlNumber === -1) {\r\n            log.log(lang.transl('_获取全部书签作品'));\r\n        }\r\n    }\r\n    // 获取用户的收藏作品列表\r\n    async getIdList() {\r\n        let data;\r\n        try {\r\n            data = await API.getBookmarkData(DOM.getUserId(), this.type, this.tag, this.offset, this.isHide);\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        if (data.body.works.length === 0 ||\r\n            this.idList.length >= this.requsetNumber) {\r\n            // 书签页获取完毕\r\n            return this.afterGetIdList();\r\n        }\r\n        else {\r\n            // 没有抓取完毕时，添加数据\r\n            const idType = this.type === 'illusts' ? 'unknown' : 'novels';\r\n            data.body.works.forEach((data) => this.idList.push({\r\n                type: idType,\r\n                id: data.id,\r\n            }));\r\n            this.offset += this.onceRequest; // 每次增加偏移量\r\n            // 重复抓取过程\r\n            this.getIdList();\r\n        }\r\n    }\r\n    // 获取作品 id 列表完毕之后\r\n    afterGetIdList() {\r\n        // 因为书签页面一次获取 100 个作品，大于一页的数量。所以可能会抓取多了，需要删除多余的作品\r\n        if (this.idList.length > this.requsetNumber) {\r\n            // 删除后面部分（较早收藏的），留下近期收藏的\r\n            this.idList.splice(this.requsetNumber, this.idList.length);\r\n            // 书签页面的 api 没有考虑页面上的排序顺序，获取到的 id 列表始终是按收藏顺序由近期到早期排列的\r\n        }\r\n        store.idList = store.idList.concat(this.idList);\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.type = 'illusts';\r\n        this.idList = [];\r\n        this.offset = 0;\r\n        this.tag = '';\r\n        this.listPageFinished = 0;\r\n    }\r\n}\r\nexport { InitBookmarkPage };\r\n","// 初始化关注列表页面\r\nimport { InitPageBase } from './InitPageBase';\r\nimport { Colors } from './Colors';\r\nimport { lang } from './Lang';\r\nimport { options } from './Options';\r\nimport { API } from './API';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nimport { DOM } from './DOM';\r\nclass InitFollowingPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.baseOffset = 0; // 开始抓取时，记录初始的偏移量\r\n        this.onceNumber = 24; // 每页 24 个画师\r\n        this.getUserListNo = 0; // 获取用户列表时，记录请求的次数\r\n        this.limit = 100; // 每次请求多少个画师的数据\r\n        this.totalNeed = Number.MAX_SAFE_INTEGER;\r\n        this.myId = '';\r\n        this.rest = 'show';\r\n        this.userList = [];\r\n        this.index = 0; // getIdList 时，对 userList 的索引\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        options.setWantPage({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n            value: '-1',\r\n        });\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x页'), lang.transl('_下载所有页面'));\r\n    }\r\n    nextStep() {\r\n        this.readyGet();\r\n        log.log(lang.transl('_正在抓取'));\r\n        this.getUserList();\r\n    }\r\n    readyGet() {\r\n        this.rest = location.href.includes('rest=hide') ? 'hide' : 'show';\r\n        // 获取抓取开始时的页码\r\n        const nowPage = API.getURLSearchField(location.href, 'p');\r\n        // 计算开始抓取时的偏移量\r\n        if (nowPage !== '') {\r\n            this.baseOffset = (parseInt(nowPage) - 1) * this.onceNumber;\r\n        }\r\n        else {\r\n            this.baseOffset = 0;\r\n        }\r\n        // 要抓取多少个用户\r\n        this.totalNeed = Number.MAX_SAFE_INTEGER;\r\n        if (this.crawlNumber !== -1) {\r\n            this.totalNeed = this.onceNumber * this.crawlNumber;\r\n        }\r\n        // 获取用户自己的 id\r\n        const test = /users\\/(\\d*)\\//.exec(location.href);\r\n        if (test && test.length > 1) {\r\n            this.myId = test[1];\r\n        }\r\n        else {\r\n            const msg = `Get the user's own id failed`;\r\n            log.error(msg, 2);\r\n            throw new Error(msg);\r\n        }\r\n    }\r\n    // 获取关注用户列表，保存用户 id\r\n    async getUserList() {\r\n        const offset = this.baseOffset + this.getUserListNo * this.limit;\r\n        let res;\r\n        try {\r\n            res = await API.getFollowingList(this.myId, this.rest, offset);\r\n        }\r\n        catch (_a) {\r\n            this.getUserList();\r\n            return;\r\n        }\r\n        const users = res.body.users;\r\n        if (users.length === 0) {\r\n            // 用户列表抓取完毕\r\n            return this.getUserListComplete();\r\n        }\r\n        for (const userData of users) {\r\n            this.userList.push(userData.userId);\r\n            if (this.userList.length >= this.totalNeed) {\r\n                // 抓取到了指定数量的用户\r\n                return this.getUserListComplete();\r\n            }\r\n        }\r\n        log.log(lang.transl('_当前有x个用户', this.userList.length.toString()), 1, false);\r\n        this.getUserListNo++;\r\n        this.getUserList();\r\n    }\r\n    getUserListComplete() {\r\n        log.log(lang.transl('_当前有x个用户', this.userList.length.toString()));\r\n        if (this.userList.length === 0) {\r\n            return this.getIdListFinished();\r\n        }\r\n        this.getIdList();\r\n    }\r\n    // 获取用户的 id 列表\r\n    async getIdList() {\r\n        let idList = [];\r\n        try {\r\n            idList = await API.getUserWorksByType(this.userList[this.index]);\r\n        }\r\n        catch (_a) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        store.idList = store.idList.concat(idList);\r\n        this.index++;\r\n        if (this.index >= this.userList.length) {\r\n            return this.getIdListFinished();\r\n        }\r\n        log.log(lang.transl('_当前作品个数', store.idList.length.toString()), 1, false);\r\n        this.getIdList();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listPageFinished = 0;\r\n        this.userList = [];\r\n        this.getUserListNo = 0;\r\n        this.index = 0;\r\n    }\r\n    sortResult() {\r\n        // 把作品数据按 id 倒序排列，id 大的在前面，这样可以先下载最新作品，后下载早期作品\r\n        store.result.sort(API.sortByProperty('id'));\r\n    }\r\n}\r\nexport { InitFollowingPage };\r\n","// 初始化首页\r\nimport { InitPageBase } from './InitPageBase';\r\nimport { Colors } from './Colors';\r\nimport { lang } from './Lang';\r\nimport { centerPanel } from './CenterPanel';\r\nimport { options } from './Options';\r\nimport { DOM } from './DOM';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nclass InitIndexPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.ready = false;\r\n        this.downIdButton = document.createElement('button');\r\n        this.downIdInput = document.createElement('textarea');\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        this.downIdButton = DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_输入id进行抓取'), [['id', 'down_id_button']]);\r\n    }\r\n    appendElseEl() {\r\n        // 用于输入id的输入框\r\n        this.downIdInput.id = 'down_id_input';\r\n        this.downIdInput.style.display = 'none';\r\n        this.downIdInput.setAttribute('placeholder', lang.transl('_输入id进行抓取的提示文字'));\r\n        DOM.insertToHead(this.downIdInput);\r\n    }\r\n    setFormOption() {\r\n        options.hideOption([1]);\r\n    }\r\n    initElse() {\r\n        this.downIdButton.addEventListener('click', () => {\r\n            if (!this.ready) {\r\n                // 还没准备好\r\n                centerPanel.close();\r\n                this.downIdInput.style.display = 'block';\r\n                this.downIdInput.focus();\r\n                document.documentElement.scrollTop = 0;\r\n            }\r\n            else {\r\n                this.readyCrawl();\r\n            }\r\n        }, false);\r\n        // 当输入框内容改变时检测，非空值时显示下载区域\r\n        this.downIdInput.addEventListener('change', () => {\r\n            if (this.downIdInput.value !== '') {\r\n                this.ready = true;\r\n                centerPanel.show();\r\n                this.downIdButton.textContent = lang.transl('_开始抓取');\r\n            }\r\n            else {\r\n                this.ready = false;\r\n                centerPanel.close();\r\n                this.downIdButton.textContent = lang.transl('_输入id进行抓取');\r\n            }\r\n        });\r\n    }\r\n    nextStep() {\r\n        // 在主页通过id抓取时，不需要获取列表页，直接完成\r\n        log.log(lang.transl('_开始获取作品页面'));\r\n        this.getIdList();\r\n    }\r\n    getWantPage() { }\r\n    getIdList() {\r\n        // 检查页面类型，设置输入的 id 的作品类型\r\n        const type = window.location.pathname === '/novel/' ? 'novels' : 'unknown';\r\n        // 检查 id\r\n        const tempSet = new Set(this.downIdInput.value.split('\\n'));\r\n        const idValue = Array.from(tempSet);\r\n        for (const id of idValue) {\r\n            // 如果有 id 不是数字，或者处于非法区间，中止任务\r\n            const nowId = parseInt(id);\r\n            if (isNaN(nowId) || nowId < 22 || nowId > 99999999) {\r\n                log.error(lang.transl('_id不合法'), 0, false);\r\n            }\r\n            else {\r\n                store.idList.push({\r\n                    type: type,\r\n                    id: nowId.toString(),\r\n                });\r\n            }\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() { }\r\n    destroy() {\r\n        DOM.clearSlot('crawlBtns');\r\n        DOM.clearSlot('otherBtns');\r\n        DOM.removeEl(this.downIdInput);\r\n    }\r\n}\r\nexport { InitIndexPage };\r\n","// 根据不同的页面，初始化下载器的功能\r\nimport { EVT } from './EVT';\r\nimport { pageType } from './PageType';\r\nimport { InitIndexPage } from './InitIndexPage';\r\nimport { InitArtworkPage } from './artwork/InitArtworkPage';\r\nimport { InitUserPage } from './InitUserPage';\r\nimport { InitBookmarkLegacyPage } from './InitBookmarkLegacyPage';\r\nimport { InitBookmarkPage } from './InitBookmarkPage';\r\nimport { InitSearchArtworkPage } from './artwork/InitSearchArtworkPage';\r\nimport { InitAreaRankingPage } from './artwork/InitAreaRankingPage';\r\nimport { InitRankingArtworkPage } from './artwork/InitRankingArtworkPage';\r\nimport { InitPixivisionPage } from './InitPixivisionPage';\r\nimport { InitBookmarkDetailPage } from './artwork/InitBookmarkDetailPage';\r\nimport { InitBookmarkNewArtworkPage } from './artwork/InitBookmarkNewArtworkPage';\r\nimport { InitDiscoverPage } from './artwork/InitDiscoverPage';\r\nimport { InitNewArtworkPage } from './artwork/InitNewArtworkPage';\r\nimport { InitNovelPage } from './novel/InitNovelPage';\r\nimport { InitNovelSeriesPage } from './novel/InitNovelSeriesPage';\r\nimport { InitSearchNovelPage } from './novel/InitSearchNovelPage';\r\nimport { InitRankingNovelPage } from './novel/InitRankingNovelPage';\r\nimport { InitBookmarkNewNovelPage } from './novel/InitBookmarkNewNovelPage';\r\nimport { InitNewNovelPage } from './novel/InitNewNovelPage';\r\nimport { InitSeriesPage } from './artwork/InitSeriesPage';\r\nimport { InitFollowingPage } from './InitFollowingPage';\r\nclass InitPage {\r\n    constructor() {\r\n        this.initPage();\r\n        // 页面类型变化时，初始化抓取流程\r\n        window.addEventListener(EVT.events.pageTypeChange, () => {\r\n            setTimeout(() => {\r\n                this.initPage();\r\n            }, 0);\r\n        });\r\n    }\r\n    initPage() {\r\n        switch (pageType.getPageType()) {\r\n            case 0:\r\n                return new InitIndexPage();\r\n            case 1:\r\n                return new InitArtworkPage();\r\n            case 2:\r\n                return new InitUserPage();\r\n            case 3:\r\n                return new InitBookmarkLegacyPage();\r\n            case 4:\r\n                return new InitBookmarkPage();\r\n            case 5:\r\n                return new InitSearchArtworkPage();\r\n            case 6:\r\n                return new InitAreaRankingPage();\r\n            case 7:\r\n                return new InitRankingArtworkPage();\r\n            case 8:\r\n                return new InitPixivisionPage();\r\n            case 9:\r\n                return new InitBookmarkDetailPage();\r\n            case 10:\r\n                return new InitBookmarkNewArtworkPage();\r\n            case 11:\r\n                return new InitDiscoverPage();\r\n            case 12:\r\n                return new InitNewArtworkPage();\r\n            case 13:\r\n                return new InitNovelPage();\r\n            case 14:\r\n                return new InitNovelSeriesPage();\r\n            case 15:\r\n                return new InitSearchNovelPage();\r\n            case 16:\r\n                return new InitRankingNovelPage();\r\n            case 17:\r\n                return new InitBookmarkNewNovelPage();\r\n            case 18:\r\n                return new InitNewNovelPage();\r\n            case 19:\r\n                return new InitSeriesPage();\r\n            case 20:\r\n                return new InitFollowingPage();\r\n            default:\r\n                throw new Error('InitPage error: Illegal pageType.');\r\n        }\r\n    }\r\n}\r\nnew InitPage();\r\n","// 初始化所有页面抓取流程的基类\r\nimport { lang } from './Lang';\r\nimport { Colors } from './Colors';\r\nimport { DOM } from './DOM';\r\nimport { options } from './Options';\r\nimport { saveArtworkData } from './artwork/SaveArtworkData';\r\nimport { saveNovelData } from './novel/SaveNovelData';\r\nimport { filter } from './Filter';\r\nimport { API } from './API';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nimport { EVT } from './EVT';\r\nimport { setting, form } from './Settings';\r\nimport { titleBar } from './TitleBar';\r\nimport { pageInfo } from './PageInfo';\r\nclass InitPageBase {\r\n    constructor() {\r\n        this.crawlNumber = 0; // 要抓取的个数/页数\r\n        this.firstFewImages = 0; // 每个作品下载几张图片。0为不限制，全部下载。改为1则只下载第一张。这是因为有时候多p作品会导致要下载的图片过多，此时可以设置只下载前几张，减少下载量\r\n        this.maxCount = 1000; // 当前页面类型最多有多少个页面/作品\r\n        this.startpageNo = 1; // 列表页开始抓取时的页码，只在 api 需要页码时使用。目前有搜索页、排行榜页、关注的新作品页使用。\r\n        this.listPageFinished = 0; // 记录一共抓取了多少个列表页。使用范围同上。\r\n        this.ajaxThreadsDefault = 10; // 抓取时的并发连接数默认值，也是最大值\r\n        this.ajaxThreads = this.ajaxThreadsDefault; // 抓取时的并发连接数\r\n        this.ajaxThreadsFinished = 0; // 统计有几个并发线程完成所有请求。统计的是并发线程（ ajaxThreads ）而非请求数\r\n    }\r\n    init() {\r\n        options.showAllOption();\r\n        this.setFormOption();\r\n        this.appendCenterBtns();\r\n        this.appendElseEl();\r\n        this.initElse();\r\n        window.addEventListener(EVT.events.pageTypeChange, () => {\r\n            this.destroy();\r\n        });\r\n    }\r\n    // 各个子类私有的初始化内容\r\n    initElse() { }\r\n    // 销毁初始化页面时添加的元素和事件，恢复设置项等\r\n    destroy() {\r\n        DOM.clearSlot('crawlBtns');\r\n        DOM.clearSlot('otherBtns');\r\n    }\r\n    // 添加中间按钮\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    // 添加其他元素（如果有）\r\n    appendElseEl() { }\r\n    // 设置表单里的选项。主要是设置页数，隐藏不需要的选项。\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        options.setWantPage({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n            value: '1',\r\n        });\r\n    }\r\n    // 作品个数/页数的输入不合法\r\n    getWantPageError() {\r\n        EVT.fire(EVT.events.crawlError);\r\n        const msg = lang.transl('_参数不合法');\r\n        window.alert(msg);\r\n        throw new Error(msg);\r\n    }\r\n    // 检查用户输入的页数/个数设置，并返回提示信息\r\n    // 可以为 -1，或者大于 0\r\n    checkWantPageInput(crawlPartTip, crawlAllTip) {\r\n        const temp = parseInt(form.setWantPage.value);\r\n        // 如果比 1 小，并且不是 -1，则不通过\r\n        if ((temp < 1 && temp !== -1) || isNaN(temp)) {\r\n            // 比 1 小的数里，只允许 -1 , 0 也不行\r\n            this.getWantPageError();\r\n        }\r\n        if (temp >= 1) {\r\n            log.warning(crawlPartTip.replace('-num-', temp.toString()));\r\n        }\r\n        else if (temp === -1) {\r\n            log.warning(crawlAllTip);\r\n        }\r\n        return temp;\r\n    }\r\n    // 检查用户输入的页数/个数设置\r\n    // 必须大于 0\r\n    checkWantPageInputGreater0() {\r\n        const result = API.checkNumberGreater0(form.setWantPage.value);\r\n        if (result.result) {\r\n            return result.value;\r\n        }\r\n        else {\r\n            this.getWantPageError();\r\n        }\r\n    }\r\n    // 获取作品张数设置\r\n    getFirstFewImages() {\r\n        const result = setting.getFirstFewImages();\r\n        if (result === undefined) {\r\n            EVT.fire(EVT.events.crawlError);\r\n            const msg = lang.transl('_下载前几张图片') + ' ' + lang.transl('_必须大于0');\r\n            log.error(msg);\r\n            window.alert(msg);\r\n            throw new Error(msg);\r\n        }\r\n        return result;\r\n    }\r\n    // 设置要获取的作品数或页数。有些页面使用，有些页面不使用。使用时再具体定义\r\n    getWantPage() { }\r\n    // 获取多图作品设置。因为这个不属于过滤器 filter，所以在这里直接获取\r\n    getMultipleSetting() {\r\n        // 获取作品张数设置\r\n        if (form.firstFewImagesSwitch.checked) {\r\n            this.firstFewImages = this.getFirstFewImages();\r\n            log.warning(lang.transl('_多图作品下载前n张图片', this.firstFewImages.toString()));\r\n        }\r\n    }\r\n    // 准备抓取，进行抓取之前的一些检查工作。必要时可以在子类中改写\r\n    async readyCrawl() {\r\n        // 检查是否可以开始抓取\r\n        if (!store.states.allowWork) {\r\n            window.alert(lang.transl('_当前任务尚未完成2'));\r\n            return;\r\n        }\r\n        EVT.fire(EVT.events.crawlStart);\r\n        log.clear();\r\n        log.success(lang.transl('_任务开始0'));\r\n        titleBar.change('↑');\r\n        this.getWantPage();\r\n        this.getMultipleSetting();\r\n        filter.init();\r\n        pageInfo.store();\r\n        // 进入第一个抓取方法\r\n        this.nextStep();\r\n    }\r\n    // 当可以开始抓取时，进入下一个流程。默认情况下，开始获取作品列表。如有不同，由子类具体定义\r\n    nextStep() {\r\n        this.getIdList();\r\n    }\r\n    // 作品列表获取完毕，开始抓取作品内容页\r\n    getIdListFinished() {\r\n        // 列表页获取完毕后，可以在这里重置一些变量\r\n        this.resetGetIdListStatus();\r\n        if (store.idList.length === 0) {\r\n            return this.noResult();\r\n        }\r\n        log.log(lang.transl('_当前作品个数', store.idList.length.toString()));\r\n        // 这个 return 在这里重置任务状态，不继续抓取作品的详情了，用于调试时反复进行抓取\r\n        // return store.resetStates()\r\n        if (store.idList.length <= this.ajaxThreadsDefault) {\r\n            this.ajaxThreads = store.idList.length;\r\n        }\r\n        else {\r\n            this.ajaxThreads = this.ajaxThreadsDefault;\r\n        }\r\n        for (let i = 0; i < this.ajaxThreads; i++) {\r\n            this.getWorksData();\r\n        }\r\n    }\r\n    // 获取作品的数据\r\n    async getWorksData(idData) {\r\n        idData = idData || store.idList.shift();\r\n        const id = idData.id;\r\n        try {\r\n            // 发起请求\r\n            if (idData.type === 'novels') {\r\n                const data = await API.getNovelData(id);\r\n                await saveNovelData.save(data);\r\n            }\r\n            else {\r\n                const data = await API.getArtworkData(id);\r\n                await saveArtworkData.save(data);\r\n            }\r\n            this.afterGetWorksData();\r\n        }\r\n        catch (error) {\r\n            //  请求成功，但 response.ok 错误。不重试请求，跳过该作品继续抓取\r\n            if (error.status) {\r\n                this.logErrorStatus(error.status, id);\r\n                this.afterGetWorksData();\r\n            }\r\n            else {\r\n                // 请求失败，会重试这个请求\r\n                console.log(error);\r\n                setTimeout(() => {\r\n                    this.getWorksData(idData);\r\n                }, 2000);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    // 每当获取完一个作品的信息\r\n    afterGetWorksData() {\r\n        this.logImagesNo();\r\n        if (store.idList.length > 0) {\r\n            // 如果存在下一个作品，则\r\n            this.getWorksData();\r\n        }\r\n        else {\r\n            // 没有剩余作品\r\n            this.ajaxThreadsFinished++;\r\n            if (this.ajaxThreadsFinished === this.ajaxThreads) {\r\n                // 如果所有并发请求都执行完毕，复位\r\n                this.ajaxThreadsFinished = 0;\r\n                this.crawlFinished();\r\n            }\r\n        }\r\n    }\r\n    // 抓取完毕\r\n    crawlFinished() {\r\n        if (store.result.length === 0) {\r\n            return this.noResult();\r\n        }\r\n        this.sortResult();\r\n        log.log(lang.transl('_抓取的文件数量', store.result.length.toString()));\r\n        log.log(lang.transl('_抓取完毕'), 2);\r\n        // 统计不同类型的文件数量\r\n        // 统计 blob 文件的体积\r\n        // const type = [0, 0, 0, 0]\r\n        // let blobSize = 0\r\n        // for (const result of store.result) {\r\n        //   type[result.type] = type[result.type] + 1\r\n        //   if(result.novelBlob){\r\n        //     blobSize += result.novelBlob.size\r\n        //   }\r\n        // }\r\n        // console.log(type)\r\n        // console.log(blobSize)\r\n        // 发出抓取完毕的信号\r\n        // 这里是正规流程的抓取完毕信号，其他地方也可能会发出这个信号。如有需要加以区别，可以在事件数据中标明数据的发起者 EVT.InitiatorList[string]\r\n        EVT.fire(EVT.events.crawlFinish);\r\n    }\r\n    // 网络请求状态异常时输出提示\r\n    logErrorStatus(status, id) {\r\n        log.error(lang.transl('_无权访问2', id), 1);\r\n        switch (status) {\r\n            case 0:\r\n                console.log(lang.transl('_作品页状态码0'));\r\n                break;\r\n            case 400:\r\n                console.log(lang.transl('_作品页状态码400'));\r\n                break;\r\n            case 403:\r\n                console.log(lang.transl('_作品页状态码403'));\r\n                break;\r\n            case 404:\r\n                console.log(lang.transl('_作品页状态码404') + ' ' + id);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    // 在抓取图片网址时，输出提示\r\n    logImagesNo() {\r\n        log.log(lang.transl('_抓取的文件数量', store.result.length.toString()), 1, false);\r\n    }\r\n    // 抓取结果为 0 时输出提示\r\n    noResult() {\r\n        EVT.fire(EVT.events.crawlEmpty);\r\n        titleBar.reset();\r\n        log.error(lang.transl('_抓取结果为零'), 2);\r\n        window.alert(lang.transl('_抓取结果为零'));\r\n    }\r\n    // 抓取完成后，对结果进行排序\r\n    sortResult() { }\r\n}\r\nexport { InitPageBase };\r\n","// 初始化 pixivision 页面\r\nimport { InitPageBase } from './InitPageBase';\r\nimport { Colors } from './Colors';\r\nimport { lang } from './Lang';\r\nimport { DOM } from './DOM';\r\nimport { options } from './Options';\r\nimport { form } from './Settings';\r\nimport { store } from './Store';\r\nclass InitPixivisionPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.tested = 0; // 检查图片后缀名时的计数\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        const typeA = document.querySelector('a[data-gtm-action=ClickCategory]');\r\n        const type = typeA.dataset.gtmLabel;\r\n        if (type === 'illustration' || type === 'manga' || type === 'cosplay') {\r\n            // 在插画、漫画、cosplay类型的页面上创建下载功能\r\n            DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取该页面的图片')).addEventListener('click', () => {\r\n                this.readyCrawl();\r\n            }, false);\r\n        }\r\n    }\r\n    setFormOption() {\r\n        options.hideOption([\r\n            1,\r\n            2,\r\n            3,\r\n            4,\r\n            5,\r\n            6,\r\n            7,\r\n            8,\r\n            9,\r\n            10,\r\n            11,\r\n            12,\r\n            14,\r\n            15,\r\n            16,\r\n            18,\r\n            19,\r\n            20,\r\n            21,\r\n            22,\r\n            23,\r\n            24,\r\n            26,\r\n            27,\r\n            28,\r\n        ]);\r\n        // pixivision 里，文件名只有 id 标记会生效，所以把文件名规则替换成 id\r\n        form.userSetName.value = '{p_title}/{id}';\r\n    }\r\n    nextStep() {\r\n        this.getPixivision();\r\n    }\r\n    getIdList() { }\r\n    resetGetIdListStatus() { }\r\n    // 保存要下载的图片的信息\r\n    addResult(id, url, ext) {\r\n        store.addResult({\r\n            id: id,\r\n            url: url,\r\n            ext: ext,\r\n        });\r\n    }\r\n    getPixivision() {\r\n        const a = document.querySelector('a[data-gtm-action=ClickCategory]');\r\n        const type = a.dataset.gtmLabel;\r\n        if (type === 'illustration') {\r\n            // 插画页面，需要对图片进行测试获取原图 url\r\n            const imageList = document.querySelectorAll('.am__work__main img');\r\n            const urls = Array.from(imageList).map((el) => {\r\n                return el.src\r\n                    .replace('c/768x1200_80/img-master', 'img-original')\r\n                    .replace('_master1200', '');\r\n            });\r\n            this.tested = 0;\r\n            urls.forEach((url) => {\r\n                let arr = url.split('/');\r\n                const id = arr[arr.length - 1].split('.')[0].split('_')[0]; // 作品id，尝试提取出数字部分\r\n                this.testExtName(url, urls.length, id);\r\n            });\r\n        }\r\n        else {\r\n            // 漫画和 cosplay ，直接保存页面上的图片\r\n            let selector = '';\r\n            if (type === 'manga') {\r\n                selector = '.am__work__illust';\r\n            }\r\n            else if (type === 'cosplay') {\r\n                selector = '.fab__image-block__image img';\r\n            }\r\n            // 把图片url添加进数组\r\n            const imageList = document.querySelectorAll(selector);\r\n            Array.from(imageList).forEach((el) => {\r\n                const url = el.src;\r\n                if (url !== 'https://i.pximg.net/imgaz/upload/20170407/256097898.jpg') {\r\n                    // 跳过Cure的logo图片\r\n                    // 漫画页面的图片 url 如：\r\n                    // https://i.pximg.net/c/768x1200_80/img-master/img/2017/06/19/01/08/28/63457814_p0_master1200.jpg\r\n                    // cosplay 页面的 ur 如：\r\n                    // https://i.pximg.net/imgaz/upload/20170808/670930758.jpg\r\n                    const arr = url.split('/');\r\n                    const id = arr[arr.length - 1].split('.')[0].split('_')[0]; // 作品id，尝试提取出数字部分\r\n                    const extTest = arr[arr.length - 1].match(/\\.(.*$)/); // 扩展名，不带点 .\r\n                    let ext = 'jpg';\r\n                    if (extTest && extTest.length > 1) {\r\n                        ext = extTest[1];\r\n                    }\r\n                    this.addResult(id, url, ext);\r\n                }\r\n            });\r\n            this.crawlFinished();\r\n        }\r\n    }\r\n    // 测试图片 url 是否正确的函数。pixivision 页面直接获取的图片 url，后缀都是jpg的，所以要测试实际上是jpg还是png\r\n    testExtName(url, imgNumber, id) {\r\n        let ext = '';\r\n        const testImg = new Image();\r\n        testImg.src = url;\r\n        testImg.onload = () => next(true);\r\n        testImg.onerror = () => next(false);\r\n        let next = (bool) => {\r\n            if (bool) {\r\n                ext = 'jpg';\r\n            }\r\n            else {\r\n                url = url.replace('.jpg', '.png');\r\n                ext = 'png';\r\n            }\r\n            this.addResult(id, url, ext);\r\n            this.logImagesNo();\r\n            if (imgNumber !== undefined) {\r\n                this.tested++;\r\n                if (this.tested === imgNumber) {\r\n                    // 如果所有请求都执行完毕\r\n                    this.crawlFinished();\r\n                }\r\n            }\r\n        };\r\n    }\r\n}\r\nexport { InitPixivisionPage };\r\n","// 初始化用户页面\r\nimport { InitPageBase } from './InitPageBase';\r\nimport { Colors } from './Colors';\r\nimport { lang } from './Lang';\r\nimport { options } from './Options';\r\nimport { API } from './API';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nimport { DOM } from './DOM';\r\nimport { pageInfo } from './PageInfo';\r\nimport { SaveAvatarIcon } from './SaveAvatarIcon';\r\nclass InitUserPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.tag = ''; // 储存当前页面的 tag，可能为空\r\n        this.listType = 0; // 细分的列表类型\r\n        this.onceNumber = 48; // 每页作品个数，插画是 48 个，小说是 24 个\r\n        this.init();\r\n    }\r\n    // 添加中间按钮\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n        const btn = DOM.addBtn('otherBtns', Colors.green, lang.transl('_保存用户头像为图标'), [\r\n            ['title', lang.transl('_保存用户头像为图标说明')],\r\n        ]);\r\n        new SaveAvatarIcon(btn);\r\n    }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        options.setWantPage({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n            value: '-1',\r\n        });\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x页'), lang.transl('_下载所有页面'));\r\n    }\r\n    nextStep() {\r\n        this.readyGetIdList();\r\n    }\r\n    readyGetIdList() {\r\n        // 判断页面类型\r\n        // 匹配 pathname 里用户 id 之后的字符\r\n        const test = location.pathname.match(/\\/users\\/\\d+(\\/.+)/);\r\n        if (test === null) {\r\n            // 用户主页\r\n            this.listType = 0;\r\n        }\r\n        else if (test.length === 2) {\r\n            const str = test[1]; //取出用户 id 之后的字符\r\n            if (str.includes('/artworks')) {\r\n                // 插画和漫画列表\r\n                this.listType = 1;\r\n            }\r\n            else if (str.includes('/illustrations')) {\r\n                // 插画列表\r\n                this.listType = 2;\r\n            }\r\n            else if (str.includes('/manga')) {\r\n                // 漫画列表\r\n                this.listType = 3;\r\n            }\r\n            else if (str.includes('/novels')) {\r\n                // 小说列表\r\n                this.listType = 4;\r\n                this.onceNumber = 24; // 如果是在小说列表页，一页只有 24 个作品\r\n            }\r\n        }\r\n        ;\r\n        (this.tag = pageInfo.getPageTag) ? this.getIdListByTag() : this.getIdList();\r\n        log.log(lang.transl('_正在抓取'));\r\n    }\r\n    getOffset() {\r\n        const nowPage = API.getURLSearchField(location.href, 'p'); // 判断当前处于第几页，页码从 1 开始。也可能没有页码\r\n        let offset = 0;\r\n        if (nowPage) {\r\n            offset = (parseInt(nowPage) - 1) * this.onceNumber;\r\n        }\r\n        if (offset < 0) {\r\n            offset = 0;\r\n        }\r\n        return offset;\r\n    }\r\n    // 根据页数设置，计算要下载的个数\r\n    getRequsetNumber() {\r\n        let requsetNumber = 9999999;\r\n        if (this.crawlNumber !== -1) {\r\n            requsetNumber = this.onceNumber * this.crawlNumber;\r\n        }\r\n        return requsetNumber;\r\n    }\r\n    // 获取用户某些类型的作品的 id 列表\r\n    async getIdList() {\r\n        let type = [];\r\n        switch (this.listType) {\r\n            case 0:\r\n                type = ['illusts', 'manga', 'novels'];\r\n                break;\r\n            case 1:\r\n                type = ['illusts', 'manga'];\r\n                break;\r\n            case 2:\r\n                type = ['illusts'];\r\n                break;\r\n            case 3:\r\n                type = ['manga'];\r\n                break;\r\n            case 4:\r\n                type = ['novels'];\r\n                break;\r\n        }\r\n        let idList = await API.getUserWorksByType(DOM.getUserId(), type);\r\n        // 判断是否全都是小说，如果是，把每页的作品个数设置为 24 个\r\n        const allWorkIsNovels = idList.every((val) => {\r\n            return val.type === 'novels';\r\n        });\r\n        allWorkIsNovels && (this.onceNumber = 24);\r\n        // 计算偏移量和需要保留的作品个数\r\n        const offset = this.getOffset();\r\n        const requsetNumber = this.getRequsetNumber();\r\n        // 按照 id 升序排列，之后会删除不需要的部分\r\n        idList.sort(API.sortByProperty('id')).reverse();\r\n        // 不带 tag 获取作品时，由于 API 是一次性返回用户的所有作品，可能大于要求的数量，所以需要去掉多余的作品。\r\n        // 删除 offset 需要去掉的部分。删除后面的 id，也就是近期作品\r\n        idList.splice(idList.length - offset, idList.length);\r\n        // 删除超过 requsetNumber 的作品。删除前面的 id，也就是早期作品\r\n        if (idList.length > requsetNumber) {\r\n            idList.splice(0, idList.length - requsetNumber);\r\n        }\r\n        // 储存\r\n        store.idList = store.idList.concat(idList);\r\n        this.getIdListFinished();\r\n    }\r\n    // 获取用户某些类型的作品的 id 列表（附带 tag）\r\n    async getIdListByTag() {\r\n        // 这里不用判断 0 也就是用户主页的情况，因为用户主页不会带 tag\r\n        let flag = 'illustmanga';\r\n        switch (this.listType) {\r\n            case 1:\r\n                flag = 'illustmanga';\r\n                break;\r\n            case 2:\r\n                flag = 'illusts';\r\n                break;\r\n            case 3:\r\n                flag = 'manga';\r\n                break;\r\n            case 4:\r\n                flag = 'novels';\r\n                break;\r\n        }\r\n        // 计算偏移量和需要保留的作品个数\r\n        const offset = this.getOffset();\r\n        const requsetNumber = this.getRequsetNumber();\r\n        let data = await API.getUserWorksByTypeWithTag(DOM.getUserId(), flag, this.tag, offset, requsetNumber);\r\n        // 图片和小说返回的数据是不同的，小说并没有 illustType 标记\r\n        if (this.listType === 4) {\r\n            const d = data;\r\n            d.body.works.forEach((data) => store.idList.push({\r\n                type: 'novels',\r\n                id: data.id,\r\n            }));\r\n        }\r\n        else {\r\n            const d = data;\r\n            d.body.works.forEach((data) => {\r\n                let type = 'illusts';\r\n                switch (data.illustType) {\r\n                    case 0:\r\n                        type = 'illusts';\r\n                        break;\r\n                    case 1:\r\n                        type = 'manga';\r\n                        break;\r\n                    case 2:\r\n                        type = 'ugoira';\r\n                        break;\r\n                }\r\n                store.idList.push({\r\n                    type,\r\n                    id: data.id,\r\n                });\r\n            });\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.tag = '';\r\n        this.listType = 0;\r\n        this.listPageFinished = 0;\r\n    }\r\n    sortResult() {\r\n        // 把作品数据按 id 倒序排列，id 大的在前面，这样可以先下载最新作品，后下载早期作品\r\n        store.result.sort(API.sortByProperty('id'));\r\n    }\r\n}\r\nexport { InitUserPage };\r\n","import { langText } from './langText';\r\n// 语言类\r\nclass Lang {\r\n    constructor() {\r\n        this.langType = 0;\r\n        this.getLangType();\r\n    }\r\n    // 设置语言类型\r\n    getLangType() {\r\n        const userLang = document.documentElement.lang; // 获取语言标识\r\n        switch (userLang) {\r\n            case 'zh':\r\n            case 'zh-CN':\r\n            case 'zh-Hans':\r\n                this.langType = 0; // 设置为简体中文\r\n                break;\r\n            case 'ja':\r\n                this.langType = 1; // 设置为日语\r\n                break;\r\n            case 'zh-Hant':\r\n            case 'zh-tw':\r\n            case 'zh-TW':\r\n                this.langType = 3; // 设置为繁体中文\r\n                break;\r\n            default:\r\n                this.langType = 2; // 设置为英语\r\n                break;\r\n        }\r\n    }\r\n    // translate 翻译\r\n    transl(name, ...arg) {\r\n        let content = langText[name][this.langType];\r\n        arg.forEach((val) => (content = content.replace('{}', val)));\r\n        return content;\r\n    }\r\n}\r\nconst lang = new Lang();\r\nexport { lang };\r\n","import { DOM } from './DOM';\r\nimport { EVT } from './EVT';\r\nimport { store } from './Store';\r\nimport { themeColor } from './ThemeColor';\r\n// 日志类\r\nclass Log {\r\n    constructor() {\r\n        this.logArea = document.createElement('div'); // 输出日志的区域\r\n        this.id = 'logWrap'; // 日志区域元素的 id\r\n        this.refresh = document.createElement('span'); // 刷新时使用的元素\r\n        this.colors = ['#00ca19', '#d27e00', '#f00'];\r\n        // 切换不同页面时，如果任务已经完成，则清空输出区域，避免日志一直堆积。\r\n        window.addEventListener(EVT.events.pageTypeChange, () => {\r\n            if (store.states.allowWork) {\r\n                this.clear();\r\n            }\r\n        });\r\n    }\r\n    // 如果日志元素没有添加到页面上，则添加上去\r\n    checkElement() {\r\n        let test = document.getElementById(this.id);\r\n        if (test === null) {\r\n            this.logArea.id = this.id;\r\n            DOM.insertToHead(this.logArea);\r\n            themeColor.register(this.logArea);\r\n        }\r\n    }\r\n    // 清空日志\r\n    clear() {\r\n        this.logArea.innerHTML = '';\r\n    }\r\n    // 添加日志\r\n    /*\r\n    str 日志文本\r\n    level 日志等级\r\n    br 换行标签的个数\r\n    keepShow 追加日志的模式，默认为 true，把这一条日志添加后不再修改。false 则是刷新显示这条消息。\r\n  \r\n    level 日志等级：\r\n    -1 auto 不设置颜色\r\n    0 success 绿色\r\n    1 warning 黄色\r\n    2 error 红色\r\n    */\r\n    add(str, level, br, keepShow) {\r\n        let span = document.createElement('span');\r\n        if (!keepShow) {\r\n            span = this.refresh;\r\n        }\r\n        span.innerHTML = str;\r\n        if (level > -1) {\r\n            span.style.color = this.colors[level];\r\n        }\r\n        while (br > 0) {\r\n            span.appendChild(document.createElement('br'));\r\n            br--;\r\n        }\r\n        this.logArea.appendChild(span);\r\n        // 因为日志区域限制了最大高度，可能会出现滚动条，这里使日志总是滚动到底部\r\n        this.logArea.scrollTop = this.logArea.scrollHeight;\r\n    }\r\n    log(str, br = 1, keepShow = true) {\r\n        this.checkElement();\r\n        this.add(str, -1, br, keepShow);\r\n    }\r\n    success(str, br = 1, keepShow = true) {\r\n        this.checkElement();\r\n        this.add(str, 0, br, keepShow);\r\n    }\r\n    warning(str, br = 1, keepShow = true) {\r\n        this.checkElement();\r\n        this.add(str, 1, br, keepShow);\r\n    }\r\n    error(str, br = 1, keepShow = true) {\r\n        this.checkElement();\r\n        this.add(str, 2, br, keepShow);\r\n    }\r\n}\r\nconst log = new Log();\r\nexport { log };\r\n","// 操作 Setting 表单的选项区域\r\nimport { form } from './Settings';\r\nclass Options {\r\n    constructor() {\r\n        this.allOption = form.querySelectorAll('.option');\r\n        // 获取“页数/个数”设置的元素\r\n        const wantPageOption = this.getOption(1);\r\n        this.wantPageEls = {\r\n            text: wantPageOption.querySelector('.setWantPageTip1'),\r\n            rangTip: wantPageOption.querySelector('.setWantPageTip2'),\r\n            input: wantPageOption.querySelector('.setWantPage'),\r\n        };\r\n    }\r\n    // 使用编号获取指定选项的元素\r\n    getOption(no) {\r\n        for (const option of this.allOption) {\r\n            if (option.dataset.no === no.toString()) {\r\n                return option;\r\n            }\r\n        }\r\n        throw `Not found this option: ${no}`;\r\n    }\r\n    // 显示或隐藏指定的选项\r\n    setOptionDisplay(no, display) {\r\n        for (const number of no) {\r\n            this.getOption(number).style.display = display;\r\n        }\r\n    }\r\n    // 显示所有选项\r\n    // 在切换不同页面时使用\r\n    showAllOption() {\r\n        for (const el of this.allOption) {\r\n            el.style.display = 'block';\r\n        }\r\n    }\r\n    // 隐藏指定的选项。参数是数组，传递设置项的编号。\r\n    hideOption(no) {\r\n        this.setOptionDisplay(no, 'none');\r\n    }\r\n    // 显示指定的选项。因为页面无刷新加载，所以一些选项被隐藏后，可能需要再次显示\r\n    showOption(no) {\r\n        this.setOptionDisplay(no, 'block');\r\n    }\r\n    // 设置 “设置页面/作品数量” 选项的提示和预设值\r\n    setWantPage(arg) {\r\n        this.wantPageEls.text.textContent = arg.text;\r\n        this.wantPageEls.text.dataset.tip = arg.tip;\r\n        this.wantPageEls.rangTip.textContent = arg.rangTip;\r\n        this.wantPageEls.input.value = arg.value;\r\n    }\r\n}\r\nconst options = new Options();\r\nexport { options };\r\n","// 输出面板\r\nimport { EVT } from './EVT';\r\nimport { lang } from './Lang';\r\nimport { store } from './Store';\r\nimport { DOM } from './DOM';\r\nimport config from './Config';\r\nimport { themeColor } from './ThemeColor';\r\nclass Output {\r\n    constructor() {\r\n        this.addOutPutPanel();\r\n        this.bindEvent();\r\n    }\r\n    addOutPutPanel() {\r\n        const outputPanelHTML = `\n    <div class=\"outputWrap\">\n    <div class=\"outputClose\" title=\"${lang.transl('_关闭')}\">X</div>\n    <div class=\"outputTitle\">${lang.transl('_输出信息')}</div>\n    <div class=\"outputContent\"></div>\n    <div class=\"outputFooter\">\n    <button class=\"outputCopy\" title=\"\">${lang.transl('_复制')}</button>\n    </div>\n    </div>\n    `;\r\n        document.body.insertAdjacentHTML('beforeend', outputPanelHTML);\r\n        this.outputPanel = document.querySelector('.outputWrap');\r\n        themeColor.register(this.outputPanel);\r\n        this.outputTitle = document.querySelector('.outputTitle');\r\n        this.outputContent = document.querySelector('.outputContent');\r\n        this.copyBtn = document.querySelector('.outputCopy');\r\n    }\r\n    close() {\r\n        this.outputPanel.style.display = 'none';\r\n        this.outputContent.innerHTML = '';\r\n    }\r\n    bindEvent() {\r\n        // 关闭输出面板\r\n        document.querySelector('.outputClose').addEventListener('click', () => {\r\n            this.close();\r\n        });\r\n        window.addEventListener(EVT.events.hideCenterPanel, () => {\r\n            this.close();\r\n        });\r\n        // 复制输出内容\r\n        this.copyBtn.addEventListener('click', () => {\r\n            const range = document.createRange();\r\n            range.selectNodeContents(this.outputContent);\r\n            window.getSelection().removeAllRanges();\r\n            window.getSelection().addRange(range);\r\n            document.execCommand('copy');\r\n            // 改变提示文字\r\n            this.copyBtn.textContent = lang.transl('_已复制到剪贴板');\r\n            setTimeout(() => {\r\n                window.getSelection().removeAllRanges();\r\n                this.copyBtn.textContent = lang.transl('_复制');\r\n            }, 1000);\r\n        });\r\n        window.addEventListener(EVT.events.output, (ev) => {\r\n            this.output(ev.detail.data.content, ev.detail.data.title);\r\n        });\r\n    }\r\n    // 输出内容\r\n    output(content, title = lang.transl('_输出信息')) {\r\n        // 如果结果较多，则不直接输出，改为保存 txt 文件\r\n        if (store.result.length > config.outputMax) {\r\n            const con = content.replace(/<br>/g, '\\n'); // 替换换行符\r\n            const file = new Blob([con], {\r\n                type: 'text/plain'\r\n            });\r\n            const url = URL.createObjectURL(file);\r\n            const fileName = new Date().toLocaleString() + '.txt';\r\n            DOM.downloadFile(url, fileName);\r\n            // 禁用复制按钮\r\n            this.copyBtn.disabled = true;\r\n            content = lang.transl('_输出内容太多已经为你保存到文件');\r\n        }\r\n        else {\r\n            this.copyBtn.disabled = false;\r\n        }\r\n        if (content) {\r\n            this.outputContent.innerHTML = content;\r\n            this.outputPanel.style.display = 'block';\r\n            this.outputTitle.textContent = title;\r\n        }\r\n    }\r\n}\r\nnew Output();\r\n","import { API } from './API';\r\nimport { EVT } from './EVT';\r\nimport { store } from './Store';\r\n// 获取页面标题和页面的 tag，在抓取开始时保存。用于命名规则里\r\nclass PageInfo {\r\n    constructor() {\r\n        this.pageTitle = '';\r\n        this.pageTag = '';\r\n        this.getPageInfo();\r\n        this.bindEvent();\r\n    }\r\n    get getPageTag() {\r\n        return this.pageTag;\r\n    }\r\n    // 重置\r\n    // 切换页面时可能旧页面的一些标记在新页面没有了，所以要先重置\r\n    reset() {\r\n        this.pageTitle = '';\r\n        this.pageTag = '';\r\n    }\r\n    // 储存信息\r\n    // 开始抓取时，把此时的页面信息保存到 store 里。这样即使下载时页面切换了，使用的还是刚开始抓取时的数据。\r\n    store() {\r\n        this.getPageInfo();\r\n        store.pageInfo.pageTitle = this.pageTitle;\r\n        store.pageInfo.pageTag = this.pageTag;\r\n    }\r\n    // 获取当前页面的一些信息，用于文件名中\r\n    getPageInfo() {\r\n        this.reset();\r\n        // 去掉标题上的下载状态、消息数量提示\r\n        this.pageTitle = document.title\r\n            .replace(/\\[(↑|→|▶|↓|║|■|✓| )\\] /, '')\r\n            .replace(/^\\(\\d.*\\) /, '');\r\n        // 获取当前页面的 tag\r\n        this.pageTag = decodeURIComponent(API.getTagFromURL(location.href));\r\n    }\r\n    bindEvent() {\r\n        // 页面切换时获取新的页面信息\r\n        window.addEventListener(EVT.events.pageSwitch, () => {\r\n            this.getPageInfo();\r\n        });\r\n        // 当需要恢复下载时，保存页面信息\r\n        window.addEventListener(EVT.events.crawlFinish, async (ev) => {\r\n            if (ev.detail.data.initiator === EVT.InitiatorList.resume) {\r\n                this.store();\r\n            }\r\n        });\r\n    }\r\n}\r\nconst pageInfo = new PageInfo();\r\nexport { pageInfo };\r\n","// 获取页面类型\r\nimport { EVT } from './EVT';\r\nclass PageType {\r\n    constructor() {\r\n        this.type = 0;\r\n        this.type = this.getPageType();\r\n        // 页面切换时检查新旧页面是否不同\r\n        window.addEventListener(EVT.events.pageSwitch, () => {\r\n            this.checkPageTypeIsNew();\r\n        });\r\n    }\r\n    // 判断页面类型\r\n    // 有些页面类型（如小说）虽然不支持，但它和支持的页面是无刷新切换的，所以视为支持的页面。等到开始抓取时再次判断是否可以抓取\r\n    getPageType() {\r\n        const url = window.location.href;\r\n        const pathname = window.location.pathname;\r\n        let type;\r\n        if (window.location.hostname === 'www.pixiv.net' &&\r\n            (pathname === '/' || pathname === '/novel/' || pathname === '/en/')) {\r\n            type = 0;\r\n        }\r\n        else if (/\\/artworks\\/\\d{1,10}/.test(url)) {\r\n            type = 1;\r\n        }\r\n        else if (/\\/users\\/\\d+/.test(url) && !url.includes('/bookmarks')) {\r\n            type = 2;\r\n            if (pathname.includes('/following')) {\r\n                type = 20;\r\n            }\r\n        }\r\n        else if (pathname.endsWith('bookmark.php')) {\r\n            type = 3;\r\n        }\r\n        else if (pathname.includes('/bookmarks/')) {\r\n            type = 4;\r\n        }\r\n        else if (url.includes('/tags/')) {\r\n            type = pathname.endsWith('/novels') ? 15 : 5;\r\n        }\r\n        else if (pathname === '/ranking_area.php' && location.search !== '') {\r\n            type = 6;\r\n        }\r\n        else if (pathname === '/ranking.php') {\r\n            type = 7;\r\n        }\r\n        else if (url.includes('https://www.pixivision.net') &&\r\n            url.includes('/a/')) {\r\n            type = 8;\r\n        }\r\n        else if (url.includes('/bookmark_add.php?id=') ||\r\n            url.includes('/bookmark_detail.php?illust_id=')) {\r\n            type = 9;\r\n        }\r\n        else if (url.includes('/bookmark_new_illust.php') ||\r\n            url.includes('/bookmark_new_illust_r18.php')) {\r\n            type = 10;\r\n        }\r\n        else if (pathname === '/discovery') {\r\n            type = 11;\r\n        }\r\n        else if (url.includes('/new_illust.php') ||\r\n            url.includes('/new_illust_r18.php')) {\r\n            type = 12;\r\n        }\r\n        else if (pathname === '/novel/show.php') {\r\n            type = 13;\r\n        }\r\n        else if (pathname.startsWith('/novel/series/')) {\r\n            type = 14;\r\n        }\r\n        else if (pathname === '/novel/ranking.php') {\r\n            type = 16;\r\n        }\r\n        else if (pathname.startsWith('/novel/bookmark_new')) {\r\n            type = 17;\r\n        }\r\n        else if (pathname.startsWith('/novel/new')) {\r\n            type = 18;\r\n        }\r\n        else if (pathname.startsWith('/user/') && pathname.includes('/series/')) {\r\n            type = 19;\r\n        }\r\n        else {\r\n            // 没有匹配到可用的页面类型\r\n            throw new Error('Page type matching failed');\r\n        }\r\n        return type;\r\n    }\r\n    // 检查是不是进入到了新的页面类型\r\n    checkPageTypeIsNew() {\r\n        let newType = this.getPageType();\r\n        if (this.type !== newType) {\r\n            EVT.fire(EVT.events.pageTypeChange, newType);\r\n        }\r\n        // 保存当前页面类型\r\n        this.type = newType;\r\n    }\r\n}\r\nconst pageType = new PageType();\r\nexport { pageType };\r\n","// 下载进度条\r\nimport { store } from './Store';\r\nimport { DOM } from './DOM';\r\nimport { lang } from './Lang';\r\n// 进度条\r\nclass ProgressBar {\r\n    constructor() {\r\n        this.wrapHTML = `\n  <div class=\"progressBarWrap\">\n  <div class=\"total\">\n  <span class=\"text\">${lang.transl('_下载进度')}</span>\n  <div class=\"right1\">\n  <div class=\"progressBar progressBar1\">\n  <div class=\"progress progress1\"></div>\n  </div>\n  <div class=\"progressTip progressTip1\">\n  <span class=\"downloaded\">0</span>\n  /\n  <span class=\"imgNum totalNumber\">0</span>\n  </div>\n  </div>\n  </div>\n\n  <ul class=\"progressBarList\"></ul>\n  </div>\n  `;\r\n        this.barHTML = `<li class=\"downloadBar\">\n  <div class=\"progressBar progressBar2\">\n  <div class=\"progress progress2\"></div>\n  </div>\n  <div class=\"progressTip progressTip2\">\n  <span class=\"fileName\"></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ${lang.transl('_已下载')}&nbsp;&nbsp;<span class=\"loaded\">0/0</span>KB\n  </div>\n  </li>`;\r\n        this.allProgressBar = [];\r\n        this.wrap = DOM.useSlot('progressBar', this.wrapHTML);\r\n        this.downloadedEl = this.wrap.querySelector('.downloaded');\r\n        this.progressColorEl = this.wrap.querySelector('.progress1');\r\n        this.listWrap = this.wrap.querySelector('.progressBarList');\r\n        this.totalNumberEl = this.wrap.querySelector('.totalNumber');\r\n    }\r\n    // 重设所有进度\r\n    reset(num, downloaded = 0) {\r\n        // 重置总进度条\r\n        this.setTotalProgress(downloaded);\r\n        this.totalNumberEl.textContent = store.result.length.toString();\r\n        // 重置子进度条\r\n        this.listWrap.innerHTML = this.barHTML.repeat(num);\r\n        this.wrap.style.display = 'block';\r\n        // 保存子进度条上需要使用到的元素\r\n        const allProgressBar = this.listWrap.querySelectorAll('.downloadBar');\r\n        this.allProgressBar = [];\r\n        for (const bar of allProgressBar) {\r\n            const data = {\r\n                name: bar.querySelector('.fileName'),\r\n                loaded: bar.querySelector('.loaded'),\r\n                progress: bar.querySelector('.progress'),\r\n            };\r\n            this.allProgressBar.push(data);\r\n        }\r\n    }\r\n    // 设置总进度条的进度\r\n    setTotalProgress(downloaded) {\r\n        this.downloadedEl.textContent = downloaded.toString();\r\n        const progress = (downloaded / store.result.length) * 100;\r\n        this.progressColorEl.style.width = progress + '%';\r\n    }\r\n    // 设置子进度条的进度\r\n    setProgress(index, data) {\r\n        const bar = this.allProgressBar[index];\r\n        bar.name.textContent = data.name;\r\n        bar.loaded.textContent = `${Math.floor(data.loaded / 1024)}/${Math.floor(data.total / 1024)}`;\r\n        const progress = data.loaded / data.total || 0; // 若结果为 NaN 则设为 0\r\n        bar.progress.style.width = progress * 100 + '%';\r\n    }\r\n    // 让某个子进度条显示警告色\r\n    showErrorColor(index, show) {\r\n        const bar = this.allProgressBar[index];\r\n        bar.name.classList[show ? 'add' : 'remove']('downloadError');\r\n    }\r\n}\r\nconst progressBar = new ProgressBar();\r\nexport { progressBar };\r\n","// 快速收藏\r\nimport { API } from './API';\r\nimport { lang } from './Lang';\r\nimport { form } from './Settings';\r\nclass QuickBookmark {\r\n    constructor() {\r\n        this.btn = document.createElement('a'); // 快速收藏按钮\r\n        this.btnId = 'quickBookmarkEl';\r\n        this.colorClass = 'bookmarkedColor';\r\n        this.likeBtnClass = '_35vRH4a';\r\n        this.isNovel = false;\r\n        this.isBookmarked = null;\r\n        this.timer = 0;\r\n        this.init();\r\n    }\r\n    async init() {\r\n        // 在某些条件下，不展开快速收藏功能\r\n        if (!API.getToken() || !form.quickBookmarks.checked) {\r\n            return;\r\n        }\r\n        window.clearInterval(this.timer);\r\n        this.isNovel = window.location.href.includes('/novel');\r\n        this.isBookmarked = !!(await this.getBookmarkData());\r\n        this.timer = window.setInterval(() => {\r\n            this.initBtn();\r\n        }, 300);\r\n    }\r\n    async getBookmarkData() {\r\n        let data;\r\n        if (this.isNovel) {\r\n            data = await API.getNovelData(API.getNovelId());\r\n        }\r\n        else {\r\n            data = await API.getArtworkData(API.getIllustId());\r\n        }\r\n        return data.body.bookmarkData;\r\n    }\r\n    // 插入快速收藏按钮\r\n    initBtn() {\r\n        // 从父元素查找作品下方的工具栏\r\n        const toolbarParent = document.querySelectorAll('main > section');\r\n        for (const el of toolbarParent) {\r\n            const test = el.querySelector('div>section');\r\n            if (test) {\r\n                this.toolbar = test;\r\n                break;\r\n            }\r\n        }\r\n        if (this.toolbar) {\r\n            // 获取原本的收藏按钮（其实是按钮外层的 div）\r\n            this.pixivBMKDiv = this.toolbar.childNodes[2];\r\n            // 当没有收藏按钮时，停止执行（如用户处于自己作品的页面时没有收藏按钮）\r\n            if (!this.pixivBMKDiv) {\r\n                return;\r\n            }\r\n            // 隐藏原来的收藏按钮\r\n            this.pixivBMKDiv.style.display = 'none';\r\n            // 如果没有快速收藏元素则添加\r\n            this.btn = this.toolbar.querySelector('#' + this.btnId);\r\n            if (!this.btn) {\r\n                this.btn = this.createBtn();\r\n                this.toolbar.insertBefore(this.btn, this.toolbar.childNodes[3]);\r\n            }\r\n            if (this.isBookmarked) {\r\n                this.bookmarked();\r\n            }\r\n            else {\r\n                this.readyBookmark();\r\n            }\r\n            window.clearInterval(this.timer);\r\n        }\r\n    }\r\n    createBtn() {\r\n        const btn = document.createElement('a');\r\n        btn.id = this.btnId;\r\n        btn.textContent = '✩';\r\n        btn.href = 'javascript:void(0)';\r\n        btn.title = lang.transl('_快速收藏');\r\n        return btn;\r\n    }\r\n    // 准备快速收藏\r\n    readyBookmark() {\r\n        this.btn.classList.remove(this.colorClass);\r\n        this.btn.href = 'javascript:void(0)';\r\n        this.btn.addEventListener('click', () => {\r\n            // 自动点赞\r\n            let likeBtn = document.querySelector(`.${this.likeBtnClass}`);\r\n            if (!likeBtn) {\r\n                // 上面尝试直接用 class 获取点赞按钮，考虑到 class 可能会变化，这里从工具栏的按钮里选择。\r\n                // 点赞按钮是工具栏里的最后一个 button 元素\r\n                console.error('likeBtn class is not available');\r\n                const btnList = this.toolbar.querySelectorAll('button');\r\n                likeBtn = btnList[btnList.length - 1];\r\n            }\r\n            likeBtn.click();\r\n            if (this.isBookmarked) {\r\n                return;\r\n            }\r\n            // 点击 p 站自带的收藏按钮，这是因为这一行为将会在作品下方显示推荐作品。如果不点击自带的按钮，只使用本程序添加的按钮，那么就不会出现推荐作品了。\r\n            const pixivBMKBtn = this.pixivBMKDiv && this.pixivBMKDiv.querySelector('button');\r\n            pixivBMKBtn && pixivBMKBtn.click();\r\n            // 如果设置了快速收藏，则获取 tag\r\n            let tags = [];\r\n            if (form.quickBookmarks.checked) {\r\n                const tagElements = document.querySelectorAll('._1LEXQ_3 li');\r\n                for (const el of tagElements) {\r\n                    const nowA = el.querySelector('a');\r\n                    if (nowA) {\r\n                        const nowTag = nowA.textContent.trim();\r\n                        if (nowTag) {\r\n                            tags.push(nowTag);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // 如果一个作品是原创作品，它的 tag 列表的最前面会显示“原创” tag。以前是统一显示日文的“オリジナル”，现在则会根据用户语言显示不同的文字。这里会把“オリジナル”添加到末尾，保持和以前的习惯一致。\r\n            if (tags.includes('原创') ||\r\n                tags.includes('Original') ||\r\n                tags.includes('창작')) {\r\n                tags.push('オリジナル');\r\n            }\r\n            const type = this.isNovel ? 'novels' : 'illusts';\r\n            const id = this.isNovel ? API.getNovelId() : API.getIllustId();\r\n            // 这里加了个延迟，因为上面先点击了 pixiv 自带的收藏按钮，但不加延迟的话， p 站自己的不带 tag 的请求反而是后发送的。所以这里通过延迟让 p 站不带 tag 的请求先发送，下载器的带 tag 的请求后发送。\r\n            setTimeout(() => {\r\n                // 调用添加收藏的 api\r\n                API.addBookmark(type, id, tags, false, API.getToken())\r\n                    .then((response) => response.json())\r\n                    .then((data) => {\r\n                    if (data.error === false) {\r\n                        this.isBookmarked = true;\r\n                        this.bookmarked();\r\n                    }\r\n                });\r\n            }, 400);\r\n        });\r\n    }\r\n    // 如果这个作品已收藏，则改变样式\r\n    bookmarked() {\r\n        this.btn.classList.add(this.colorClass);\r\n        if (this.isNovel) {\r\n            this.btn.href = `/novel/bookmark_add.php?id=${API.getNovelId()}`;\r\n        }\r\n        else {\r\n            this.btn.href = `/bookmark_add.php?type=illust&illust_id=${API.getIllustId()}`;\r\n        }\r\n    }\r\n}\r\nexport { QuickBookmark };\r\n","import { EVT } from './EVT';\r\nimport { store } from './Store';\r\nimport { log } from './Log';\r\nimport { lang } from './Lang';\r\nimport { downloadStates } from './DownloadStates';\r\nimport { IndexedDB } from './IndexedDB';\r\n// 断点续传。恢复未完成的下载\r\nclass Resume {\r\n    constructor() {\r\n        this.flag = false; // 指示是否处于恢复模式\r\n        this.DBName = 'PBD';\r\n        this.DBVer = 3;\r\n        this.metaName = 'taskMeta'; // 下载任务元数据的表名\r\n        this.dataName = 'taskData'; // 下载任务数据的表名\r\n        this.statesName = 'taskStates'; // 下载状态列表的表名\r\n        this.part = []; // 储存每个分段里的数据的数量\r\n        this.try = 0; // 任务结果是分批储存的，记录每批失败了几次。根据失败次数减少每批的数量\r\n        // 尝试存储抓取结果时，单次存储的数量不能超过这个数字。因为超过这个数字可能会碰到单次存储的上限\r\n        // 由于每个结果的体积可能不同，所以这只是一个预估值\r\n        // 这有助于减少尝试次数。因为存储的思路是存储失败时改为上次数量的 1/2。例如有 100 w 个结果，存储算法会依次尝试存入 100 w、50 w、25 w、12.5 w 以此类推，直到最后有一次能成功存储一批数据。这样的话就进行了 4 次尝试才成功存入一批数据。但通过直接指定一批数据的大小为 onceMax，理想情况下可以只尝试一次就成功存入一批数据。\r\n        // 非理想情况下，即这个数量的结果已经超过了单次存储上限（目前推测这可能会在大量抓取小说、动图时出现；如果抓取的作品大部分是插画、漫画，这个数量的结果应该不可能超出存储上限），那么这不会减少尝试数量，但因为每次尝试存储的数量不会超过这个数字，这依然有助于减少每次尝试时的资源占用、耗费时间。\r\n        this.onceMax = 150000;\r\n        this.putStatesTime = 2000; // 每隔指定时间存储一次最新的下载状态\r\n        this.needPutStates = false; // 指示是否需要更新存储的下载状态\r\n        this.testSave = false; // 调试存储状况的开关\r\n        this.IDB = new IndexedDB();\r\n        this.init();\r\n    }\r\n    async init() {\r\n        if (location.hostname.includes('pixivision.net')) {\r\n            return;\r\n        }\r\n        await this.initDB();\r\n        !this.testSave && this.restoreData();\r\n        this.bindEvent();\r\n        this.regularPutStates();\r\n        this.clearExired();\r\n        this.testSave && this.test(1000000);\r\n    }\r\n    // 初始化数据库，获取数据库对象\r\n    async initDB() {\r\n        // 在升级事件里创建表和索引\r\n        const onUpdate = (db) => {\r\n            if (!db.objectStoreNames.contains(this.metaName)) {\r\n                const metaStore = db.createObjectStore(this.metaName, {\r\n                    keyPath: 'id',\r\n                });\r\n                metaStore.createIndex('id', 'id', { unique: true });\r\n                metaStore.createIndex('url', 'url', { unique: true });\r\n            }\r\n            if (!db.objectStoreNames.contains(this.dataName)) {\r\n                const dataStore = db.createObjectStore(this.dataName, {\r\n                    keyPath: 'id',\r\n                });\r\n                dataStore.createIndex('id', 'id', { unique: true });\r\n            }\r\n            if (!db.objectStoreNames.contains(this.statesName)) {\r\n                const statesStore = db.createObjectStore(this.statesName, {\r\n                    keyPath: 'id',\r\n                });\r\n                statesStore.createIndex('id', 'id', { unique: true });\r\n            }\r\n        };\r\n        // 打开数据库\r\n        return new Promise(async (resolve, reject) => {\r\n            resolve(await this.IDB.open(this.DBName, this.DBVer, onUpdate));\r\n        });\r\n    }\r\n    // 恢复未完成任务的数据\r\n    async restoreData() {\r\n        // 如果当前不允许展开工作（也就是在抓取或者在下载），则不恢复数据\r\n        if (!store.states.allowWork) {\r\n            return;\r\n        }\r\n        // 1 获取任务的元数据\r\n        const meta = (await this.IDB.get(this.metaName, this.getURL(), 'url'));\r\n        if (!meta) {\r\n            this.flag = false;\r\n            return;\r\n        }\r\n        log.warning(lang.transl('_正在恢复抓取结果'));\r\n        this.taskId = meta.id;\r\n        // 2 恢复抓取结果\r\n        // 生成每批数据的 id 列表\r\n        const dataIdList = this.createIdList(meta.id, meta.part);\r\n        // 读取全部数据并恢复\r\n        const promiseList = [];\r\n        for (const id of dataIdList) {\r\n            promiseList.push(this.IDB.get(this.dataName, id));\r\n        }\r\n        await Promise.all(promiseList).then((res) => {\r\n            store.result = [];\r\n            const r = res;\r\n            for (const taskData of r) {\r\n                for (const data of taskData.data) {\r\n                    store.result.push(data);\r\n                }\r\n            }\r\n        });\r\n        // 3 恢复下载状态\r\n        const data = (await this.IDB.get(this.statesName, this.taskId));\r\n        if (data) {\r\n            downloadStates.replace(data.states);\r\n        }\r\n        // 恢复模式就绪\r\n        this.flag = true;\r\n        log.success(lang.transl('_已恢复抓取结果'), 2);\r\n        // 发出抓取完毕的信号\r\n        EVT.fire(EVT.events.crawlFinish, {\r\n            initiator: EVT.InitiatorList.resume,\r\n        });\r\n    }\r\n    bindEvent() {\r\n        // 抓取完成时，保存这次任务的数据\r\n        window.addEventListener(EVT.events.crawlFinish, async (ev) => {\r\n            if (ev.detail.data.initiator === EVT.InitiatorList.resume) {\r\n                // 如果这个事件是这个类自己发出的，则不进行处理\r\n                return;\r\n            }\r\n            // 首先检查这个网址下是否已经存在有数据，如果有数据，则清除之前的数据，保持每个网址只有一份数据\r\n            const taskData = (await this.IDB.get(this.metaName, this.getURL(), 'url'));\r\n            if (taskData) {\r\n                await this.IDB.delete(this.metaName, taskData.id);\r\n                await this.IDB.delete(this.statesName, taskData.id);\r\n            }\r\n            // 保存本次任务的数据\r\n            // 如果此时本次任务已经完成，就不进行保存了\r\n            if (downloadStates.downloadedCount() === store.result.length) {\r\n                return;\r\n            }\r\n            log.warning(lang.transl('_正在保存抓取结果'));\r\n            this.taskId = new Date().getTime();\r\n            this.part = [];\r\n            await this.saveTaskData();\r\n            // 保存 meta 数据\r\n            const metaData = {\r\n                id: this.taskId,\r\n                url: this.getURL(),\r\n                part: this.part.length,\r\n            };\r\n            this.IDB.add(this.metaName, metaData);\r\n            // 保存 states 数据\r\n            const statesData = {\r\n                id: this.taskId,\r\n                states: downloadStates.states,\r\n            };\r\n            this.IDB.add(this.statesName, statesData);\r\n            log.success(lang.transl('_已保存抓取结果'), 2);\r\n        });\r\n        // 当有文件下载完成时，更新下载状态\r\n        window.addEventListener(EVT.events.downloadSucccess, () => {\r\n            this.needPutStates = true;\r\n        });\r\n        // 任务下载完毕时，清除这次任务的数据\r\n        window.addEventListener(EVT.events.downloadComplete, async () => {\r\n            if (!this.taskId) {\r\n                return;\r\n            }\r\n            const meta = (await this.IDB.get(this.metaName, this.taskId));\r\n            if (!meta) {\r\n                return;\r\n            }\r\n            this.IDB.delete(this.metaName, this.taskId);\r\n            this.IDB.delete(this.statesName, this.taskId);\r\n            const dataIdList = this.createIdList(this.taskId, meta.part);\r\n            for (const id of dataIdList) {\r\n                this.IDB.delete(this.dataName, id);\r\n            }\r\n            this.flag = false;\r\n        });\r\n        // 开始新的抓取时，取消恢复模式\r\n        window.addEventListener(EVT.events.crawlStart, () => {\r\n            this.flag = false;\r\n        });\r\n        // 切换页面时，重新检查恢复数据\r\n        window.addEventListener(EVT.events.pageSwitch, () => {\r\n            this.flag = false;\r\n            this.restoreData();\r\n        });\r\n    }\r\n    // 定时 put 下载状态\r\n    async regularPutStates() {\r\n        setInterval(() => {\r\n            if (this.needPutStates) {\r\n                const statesData = {\r\n                    id: this.taskId,\r\n                    states: downloadStates.states,\r\n                };\r\n                this.needPutStates = false;\r\n                // 如果此时本次任务已经完成，就不进行保存了\r\n                if (downloadStates.downloadedCount() === store.result.length) {\r\n                    return;\r\n                }\r\n                this.IDB.put(this.statesName, statesData);\r\n            }\r\n        }, this.putStatesTime);\r\n    }\r\n    // 存储抓取结果\r\n    async saveTaskData() {\r\n        return new Promise(async (resolve, reject) => {\r\n            // 每一批任务的第一次执行会尝试保存所有剩余数据(0.5 的 0 次幂是 1)\r\n            // 如果出错了，则每次执行会尝试保存上一次数据量的一半，直到这次存储成功\r\n            // 之后继续进行下一批任务（如果有）\r\n            let tryNum = Math.floor(store.result.length * Math.pow(0.5, this.try));\r\n            // 如果这批尝试数据大于指定数量，则设置为指定数量\r\n            tryNum > this.onceMax && (tryNum = this.onceMax);\r\n            let data = {\r\n                id: this.numAppendNum(this.taskId, this.part.length),\r\n                data: store.result.slice(this.getPartTotal(), this.getPartTotal() + tryNum),\r\n            };\r\n            try {\r\n                // 当成功存储了一批数据时\r\n                await this.IDB.add(this.dataName, data);\r\n                this.part.push(data.data.length); // 记录这一次保存的结果数量\r\n                this.try = 0; // 重置已尝试次数\r\n                // 任务数据全部添加完毕\r\n                if (this.getPartTotal() >= store.result.length) {\r\n                    // console.log('add complete')\r\n                    resolve();\r\n                }\r\n                else {\r\n                    // 任务数据没有添加完毕，继续添加\r\n                    resolve(this.saveTaskData());\r\n                }\r\n            }\r\n            catch (error) {\r\n                // 当存储失败时\r\n                console.error(error);\r\n                if (error.target && error.target.error && error.target.error.message) {\r\n                    const msg = error.target.error.message;\r\n                    if (msg.includes('too large')) {\r\n                        // 体积超大\r\n                        // 尝试次数 + 1 ，进行下一次尝试\r\n                        this.try++;\r\n                        resolve(this.saveTaskData());\r\n                    }\r\n                    else {\r\n                        // 未知错误，不再进行尝试\r\n                        this.try = 0;\r\n                        log.error('IndexedDB: ' + msg);\r\n                        reject(error);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    // 清除过期的数据\r\n    async clearExired() {\r\n        // 数据的过期时间，设置为 30 天。30*24*60*60*1000\r\n        const expiryTime = 2592000000;\r\n        const nowTime = new Date().getTime();\r\n        const callback = (item) => {\r\n            if (item) {\r\n                const data = item.value;\r\n                // 检查数据是否过期\r\n                if (nowTime - data.id > expiryTime) {\r\n                    this.IDB.delete(this.metaName, data.id);\r\n                    this.IDB.delete(this.statesName, data.id);\r\n                    const dataIdList = this.createIdList(data.id, data.part);\r\n                    for (const id of dataIdList) {\r\n                        this.IDB.delete(this.dataName, id);\r\n                    }\r\n                }\r\n                item.continue();\r\n            }\r\n        };\r\n        this.IDB.openCursor(this.metaName, callback);\r\n    }\r\n    // 计算 part 数组里的数字之和\r\n    getPartTotal() {\r\n        if (this.part.length === 0) {\r\n            return 0;\r\n        }\r\n        return this.part.reduce((prev, curr) => {\r\n            return prev + curr;\r\n        });\r\n    }\r\n    // 处理本页面的 url\r\n    getURL() {\r\n        return window.location.href.split('#')[0];\r\n    }\r\n    // 在数字后面追加数字\r\n    // 用于在 task id  后面追加序号数字(part)\r\n    numAppendNum(id, num) {\r\n        return parseInt(id.toString() + num);\r\n    }\r\n    // 根据 taskMeta 里的 id 和 part 数量，生成 taskData 里对应的数据的 id 列表\r\n    createIdList(taskid, part) {\r\n        // part 记录数据分成了几部分，所以是从 1 开始的，而不是从 0 开始\r\n        // 生成的 id 的结尾是从 0 开始增加的\r\n        const arr = [];\r\n        let start = 0;\r\n        while (start < part) {\r\n            arr.push(this.numAppendNum(taskid, start));\r\n            start++;\r\n        }\r\n        return arr;\r\n    }\r\n    // 添加指定数量的测试数据，模拟抓取完毕事件，用于调试存储情况\r\n    // 这个数据由于 id 是重复的，所以不能正常下载\r\n    test(num) {\r\n        while (num > 0) {\r\n            store.result.push({\r\n                bmk: 1644,\r\n                bookmarked: false,\r\n                date: '2020-07-11',\r\n                dlCount: 1,\r\n                ext: 'jpg',\r\n                fullHeight: 1152,\r\n                fullWidth: 2048,\r\n                id: '82900613_p0',\r\n                idNum: 82900613,\r\n                novelBlob: null,\r\n                pageCount: 1,\r\n                rank: '',\r\n                seriesOrder: '',\r\n                seriesTitle: '',\r\n                tags: [\r\n                    '女の子',\r\n                    'バーチャルYouTuber',\r\n                    'にじさんじ',\r\n                    '本間ひまわり',\r\n                    'にじさんじ',\r\n                    '本間ひまわり',\r\n                ],\r\n                tagsTranslated: [\r\n                    '女の子',\r\n                    '女孩子',\r\n                    'バーチャルYouTuber',\r\n                    '虚拟YouTuber',\r\n                    'にじさんじ',\r\n                    '彩虹社',\r\n                    '本間ひまわり',\r\n                    '本间向日葵',\r\n                    'にじさんじ',\r\n                    '彩虹社',\r\n                    '本間ひまわり',\r\n                    '本间向日葵',\r\n                ],\r\n                thumb: 'https://i.pximg.net/c/250x250_80_a2/custom-thumb/img/2020/07/11/17/05/41/82900613_p0_custom1200.jpg',\r\n                title: '本間ひまわり',\r\n                type: 0,\r\n                ugoiraInfo: null,\r\n                url: 'https://i.pximg.net/img-original/img/2020/07/11/17/05/41/82900613_p0.jpg',\r\n                user: 'らっち。',\r\n                userId: '10852879',\r\n            });\r\n            num--;\r\n        }\r\n        EVT.fire(EVT.events.crawlFinish);\r\n    }\r\n}\r\nconst resume = new Resume();\r\nexport { resume };\r\n","import { EVT } from './EVT';\r\n// 右侧的下载图标\r\nclass RightIcon {\r\n    constructor() {\r\n        this.icon = document.createElement('div');\r\n        this.addIcon();\r\n        this.bindEvents();\r\n    }\r\n    // 添加右侧下载按钮\r\n    addIcon() {\r\n        this.icon = document.createElement('div');\r\n        this.icon.textContent = '↓';\r\n        this.icon.id = 'rightButton';\r\n        document.body.appendChild(this.icon);\r\n    }\r\n    bindEvents() {\r\n        this.icon.addEventListener('click', () => {\r\n            EVT.fire(EVT.events.clickRightIcon);\r\n        });\r\n        window.addEventListener(EVT.events.hideCenterPanel, () => {\r\n            this.show();\r\n        });\r\n        window.addEventListener(EVT.events.showCenterPanel, () => {\r\n            this.hide();\r\n        });\r\n    }\r\n    show() {\r\n        this.icon.style.display = 'block';\r\n    }\r\n    hide() {\r\n        this.icon.style.display = 'none';\r\n    }\r\n}\r\nnew RightIcon();\r\n","import { lang } from './Lang';\r\nimport { API } from './API';\r\nimport { log } from './Log';\r\nimport { DOM } from './DOM';\r\nimport { centerPanel } from './CenterPanel';\r\nimport { img2ico } from './ImageToIcon';\r\n// 保存用户头像为图标\r\nclass SaveAvatarIcon {\r\n    constructor(btn) {\r\n        this.btn = btn;\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        this.btn.addEventListener('click', () => {\r\n            this.saveAvatarIcon();\r\n        });\r\n    }\r\n    async saveAvatarIcon() {\r\n        const userId = DOM.getUserId();\r\n        const userProfile = await API.getUserProfile(userId);\r\n        const bigImg = userProfile.body.imageBig; // imageBig 并不是头像原图，而是裁剪成 170 px 的尺寸\r\n        const fullSizeImg = bigImg.replace('_170', ''); // 去掉 170 标记，获取头像图片的原图\r\n        // 生成 ico 文件\r\n        // 尺寸固定为 256，因为尺寸更小的图标如 128 会在 windows 资源管理器里被缩小到 48\r\n        const blob = await img2ico.convert({\r\n            size: 256,\r\n            source: fullSizeImg,\r\n            shape: 'fillet'\r\n        });\r\n        // 直接保存到下载文件夹\r\n        const url = URL.createObjectURL(blob);\r\n        const name = `ico_${userProfile.body.name}_${userId}.ico`;\r\n        DOM.downloadFile(url, name);\r\n        log.success('✓ ' + lang.transl('_保存用户头像为图标'));\r\n        centerPanel.close();\r\n    }\r\n}\r\nexport { SaveAvatarIcon };\r\n","// 保存和初始化设置项\r\n// 只有部分设置会被保存\r\nimport { EVT } from './EVT';\r\nclass SaveSettings {\r\n    constructor(form) {\r\n        // 本地存储中使用的 name\r\n        this.storeName = 'xzSetting';\r\n        // 需要持久化保存的设置的默认值\r\n        this.optionDefault = {\r\n            firstFewImagesSwitch: false,\r\n            firstFewImages: 1,\r\n            downType0: true,\r\n            downType1: true,\r\n            downType2: true,\r\n            downType3: true,\r\n            downSingleImg: true,\r\n            downMultiImg: true,\r\n            downColorImg: true,\r\n            downBlackWhiteImg: true,\r\n            ugoiraSaveAs: 'webm',\r\n            convertUgoiraThread: 1,\r\n            needTag: '',\r\n            notNeedTag: '',\r\n            quietDownload: true,\r\n            downloadThread: 5,\r\n            userSetName: '{id}',\r\n            tagNameToFileName: false,\r\n            alwaysFolder: true,\r\n            multipleImageDir: false,\r\n            multipleImageFolderName: '1',\r\n            showOptions: true,\r\n            postDate: false,\r\n            postDateStart: '',\r\n            postDateEnd: '',\r\n            previewResult: true,\r\n            BMKNumSwitch: false,\r\n            BMKNumMin: '0',\r\n            BMKNumMax: '999999',\r\n            setWHSwitch: false,\r\n            setWidthAndOr: '&',\r\n            setWidth: '0',\r\n            setHeight: '0',\r\n            ratioSwitch: false,\r\n            ratio: '1',\r\n            userRatio: '1.4',\r\n            idRangeSwitch: false,\r\n            idRangeInput: '0',\r\n            needTagSwitch: false,\r\n            notNeedTagSwitch: false,\r\n            quickBookmarks: true,\r\n            noSerialNo: false,\r\n            filterBlackWhite: false,\r\n            sizeSwitch: false,\r\n            sizeMin: '0',\r\n            sizeMax: '100',\r\n            novelSaveAs: 'txt',\r\n            saveNovelMeta: false,\r\n            deduplication: false,\r\n            dupliStrategy: 'strict',\r\n        };\r\n        // 需要持久化保存的设置\r\n        this.options = this.optionDefault;\r\n        this.form = form;\r\n        this.bindOptionEvent();\r\n        // 设置发生改变时，保存设置到本地存储\r\n        window.addEventListener(EVT.events.settingChange, (event) => {\r\n            const data = event.detail.data;\r\n            if (Reflect.has(this.optionDefault, data.name)) {\r\n                if (this.options[data.name] !== data.value) {\r\n                    ;\r\n                    this.options[data.name] = data.value;\r\n                    localStorage.setItem(this.storeName, JSON.stringify(this.options));\r\n                }\r\n            }\r\n        });\r\n        this.restoreOption();\r\n    }\r\n    // 恢复值是 Boolean 的设置项\r\n    // 给复选框使用\r\n    restoreBoolean(name) {\r\n        // 优先使用用户设置的值\r\n        if (this.options[name] !== undefined) {\r\n            this.form[name].checked = this.options[name];\r\n        }\r\n        else {\r\n            // 否则使用默认值\r\n            this.form[name].checked = this.optionDefault[name];\r\n        }\r\n        // 这里不能简单的使用 || 符号来处理，考虑如下情况：\r\n        // this.options[name] || this.optionDefault[name]\r\n        // 用户设置为 false，默认值为 true，使用 || 的话就恒为 true 了\r\n    }\r\n    // 恢复值是 string 的设置项\r\n    // 给单选按钮和文本框使用\r\n    restoreString(name) {\r\n        // 优先使用用户设置的值\r\n        if (this.options[name] !== undefined) {\r\n            this.form[name].value = this.options[name].toString();\r\n        }\r\n        else {\r\n            // 否则使用默认值\r\n            this.form[name].value = this.optionDefault[name].toString();\r\n        }\r\n    }\r\n    // 从持久化设置，缺省使用默认值，恢复下载区域的设置\r\n    restoreOption() {\r\n        const savedOption = localStorage.getItem(this.storeName);\r\n        // 读取保存的设置\r\n        if (savedOption) {\r\n            this.options = JSON.parse(savedOption);\r\n        }\r\n        else {\r\n            // 如果没有保存过，则不做处理\r\n            return;\r\n        }\r\n        // 设置下载的作品类型\r\n        this.restoreBoolean('downType0');\r\n        this.restoreBoolean('downType1');\r\n        this.restoreBoolean('downType2');\r\n        this.restoreBoolean('downType3');\r\n        this.restoreBoolean('downSingleImg');\r\n        this.restoreBoolean('downMultiImg');\r\n        this.restoreBoolean('downColorImg');\r\n        this.restoreBoolean('downBlackWhiteImg');\r\n        // 多图下载前几张图作品设置\r\n        this.restoreBoolean('firstFewImagesSwitch');\r\n        this.restoreString('firstFewImages');\r\n        // 设置动图格式选项\r\n        this.restoreString('ugoiraSaveAs');\r\n        // 设置动图转换线程数\r\n        this.restoreString('convertUgoiraThread');\r\n        this.restoreString('novelSaveAs');\r\n        this.restoreBoolean('saveNovelMeta');\r\n        // 设置收藏数量选项\r\n        this.restoreBoolean('BMKNumSwitch');\r\n        // 设置收藏数量数值\r\n        this.restoreString('BMKNumMin');\r\n        this.restoreString('BMKNumMax');\r\n        // 设置启用快速收藏\r\n        this.restoreBoolean('quickBookmarks');\r\n        // 设置宽高条件\r\n        this.restoreBoolean('setWHSwitch');\r\n        this.restoreString('setWidthAndOr');\r\n        this.restoreString('setWidth');\r\n        this.restoreString('setHeight');\r\n        // 设置宽高比例\r\n        this.restoreBoolean('ratioSwitch');\r\n        this.restoreString('ratio');\r\n        this.restoreString('userRatio');\r\n        // 设置 id 范围\r\n        this.restoreBoolean('idRangeSwitch');\r\n        this.restoreString('idRangeInput');\r\n        // 设置必须的 tag\r\n        this.restoreBoolean('needTagSwitch');\r\n        this.restoreString('needTag');\r\n        // 设置排除的 tag\r\n        this.restoreBoolean('notNeedTagSwitch');\r\n        this.restoreString('notNeedTag');\r\n        // 设置投稿时间\r\n        this.restoreBoolean('postDate');\r\n        this.restoreString('postDateStart');\r\n        this.restoreString('postDateEnd');\r\n        // 设置自动下载\r\n        this.restoreBoolean('quietDownload');\r\n        // 设置下载线程\r\n        this.restoreString('downloadThread');\r\n        // 设置文件命名规则\r\n        this.restoreString('userSetName');\r\n        // 设置是否添加标记名称\r\n        this.restoreBoolean('tagNameToFileName');\r\n        // 设置第一张图不带序号\r\n        this.restoreBoolean('noSerialNo');\r\n        // 设置是否始终建立文件夹\r\n        this.restoreBoolean('alwaysFolder');\r\n        // 设置是否为多图作品自动建立文件夹\r\n        this.restoreBoolean('multipleImageDir');\r\n        // 设置多图作品建立文件夹时的文件名规则\r\n        this.restoreString('multipleImageFolderName');\r\n        // 设置预览搜索结果\r\n        this.restoreBoolean('previewResult');\r\n        // 设置文件体积限制\r\n        this.restoreBoolean('sizeSwitch');\r\n        this.restoreString('sizeMin');\r\n        this.restoreString('sizeMax');\r\n        // 恢复去重设置\r\n        this.restoreBoolean('deduplication');\r\n        this.restoreString('dupliStrategy');\r\n    }\r\n    // 处理输入框： change 时直接保存 value\r\n    saveTextInput(name) {\r\n        const el = this.form[name];\r\n        el.addEventListener('change', () => {\r\n            this.emitChange(name, el.value);\r\n        });\r\n    }\r\n    // 处理复选框： click 时直接保存 checked\r\n    saveCheckBox(name) {\r\n        const el = this.form[name];\r\n        el.addEventListener('click', () => {\r\n            this.emitChange(name, el.checked);\r\n        });\r\n    }\r\n    // 处理单选框： click 时直接保存 value\r\n    saveRadio(name) {\r\n        const radios = this.form[name];\r\n        for (const radio of radios) {\r\n            radio.addEventListener('click', () => {\r\n                this.emitChange(name, radio.value);\r\n            });\r\n        }\r\n    }\r\n    // 绑定所有选项的事件，当选项变动触发 settingChange 事件\r\n    // 只可执行一次，否则事件会重复绑定\r\n    bindOptionEvent() {\r\n        // 保存下载的作品类型\r\n        this.saveCheckBox('downType0');\r\n        this.saveCheckBox('downType1');\r\n        this.saveCheckBox('downType2');\r\n        this.saveCheckBox('downType3');\r\n        this.saveCheckBox('downSingleImg');\r\n        this.saveCheckBox('downMultiImg');\r\n        this.saveCheckBox('downColorImg');\r\n        this.saveCheckBox('downBlackWhiteImg');\r\n        // 保存多图作品设置\r\n        this.saveCheckBox('firstFewImagesSwitch');\r\n        this.saveTextInput('firstFewImages');\r\n        // 保存动图格式选项\r\n        this.saveRadio('ugoiraSaveAs');\r\n        // 保存动图转换线程数\r\n        this.saveTextInput('convertUgoiraThread');\r\n        this.saveRadio('novelSaveAs');\r\n        this.saveCheckBox('saveNovelMeta');\r\n        // 保存收藏数量选项\r\n        this.saveCheckBox('BMKNumSwitch');\r\n        // 保存收藏数量数值\r\n        this.saveTextInput('BMKNumMin');\r\n        this.saveTextInput('BMKNumMax');\r\n        // 保存启用快速收藏\r\n        this.saveCheckBox('quickBookmarks');\r\n        // 保存宽高条件\r\n        this.saveCheckBox('setWHSwitch');\r\n        this.saveRadio('setWidthAndOr');\r\n        this.saveTextInput('setWidth');\r\n        this.saveTextInput('setHeight');\r\n        // 保存宽高比例\r\n        this.saveCheckBox('ratioSwitch');\r\n        this.saveRadio('ratio');\r\n        this.saveTextInput('userRatio');\r\n        // 保存投稿时间\r\n        this.saveCheckBox('postDate');\r\n        this.saveTextInput('postDateStart');\r\n        this.saveTextInput('postDateEnd');\r\n        // 保存 id 范围\r\n        this.saveCheckBox('idRangeSwitch');\r\n        this.saveTextInput('idRangeInput');\r\n        // 保存 id 范围\r\n        this.saveRadio('idRange');\r\n        // 保存必须的 tag 设置\r\n        this.saveCheckBox('needTagSwitch');\r\n        this.saveTextInput('needTag');\r\n        // 保存排除的 tag 设置\r\n        this.saveCheckBox('notNeedTagSwitch');\r\n        this.saveTextInput('notNeedTag');\r\n        // 保存命名规则\r\n        const userSetNameInput = this.form.userSetName;\r\n        ['change', 'focus'].forEach((ev) => {\r\n            userSetNameInput.addEventListener(ev, () => {\r\n                this.emitChange('userSetName', userSetNameInput.value);\r\n            });\r\n        });\r\n        // 保存是否添加标记名称\r\n        this.saveCheckBox('tagNameToFileName');\r\n        // 保存第一张图不带序号\r\n        this.saveCheckBox('noSerialNo');\r\n        // 保存是否始终建立文件夹\r\n        this.saveCheckBox('alwaysFolder');\r\n        // 保存是否为多图作品自动建立文件夹\r\n        this.saveCheckBox('multipleImageDir');\r\n        // 保存多图建立文件夹时的命名规则\r\n        this.saveRadio('multipleImageFolderName');\r\n        // 保存文件体积限制\r\n        this.saveCheckBox('sizeSwitch');\r\n        this.saveTextInput('sizeMin');\r\n        this.saveTextInput('sizeMax');\r\n        // 保存自动下载\r\n        this.saveCheckBox('quietDownload');\r\n        // 保存下载线程\r\n        this.saveTextInput('downloadThread');\r\n        // 保存预览搜索结果\r\n        this.saveCheckBox('previewResult');\r\n        // 保存去重设置\r\n        this.saveCheckBox('deduplication');\r\n        this.saveRadio('dupliStrategy');\r\n        window.addEventListener(EVT.events.resetOption, () => {\r\n            this.form.reset();\r\n            this.reset();\r\n        });\r\n    }\r\n    emitChange(name, value) {\r\n        EVT.fire(EVT.events.settingChange, { name: name, value: value });\r\n    }\r\n    // 重设选项\r\n    reset() {\r\n        // 将保存的选项恢复为默认值\r\n        this.options = this.optionDefault;\r\n        // 覆写本地存储里的设置为默认值\r\n        localStorage.setItem(this.storeName, JSON.stringify(this.options));\r\n        // 重设选项\r\n        this.restoreOption();\r\n        // 触发设置改变事件\r\n        EVT.fire(EVT.events.settingChange);\r\n    }\r\n}\r\nexport { SaveSettings };\r\n","import { API } from './API';\r\nimport { EVT } from './EVT';\r\nimport { DOM } from './DOM';\r\nimport { Colors } from './Colors';\r\nimport { lang } from './Lang';\r\nimport { store } from './Store';\r\nimport { SaveSettings } from './SaveSettings';\r\nimport formHtml from './FormHTML';\r\n// 设置表单\r\nclass Settings {\r\n    constructor() {\r\n        this.firstFewImages = 0;\r\n        this.activeClass = 'active';\r\n        this.chooseKeys = ['Enter', 'NumpadEnter']; // 让回车键可以控制复选框（浏览器默认只支持空格键）\r\n        this.form = DOM.useSlot('form', formHtml);\r\n        this.allCheckBox = this.form.querySelectorAll('input[type=\"checkbox\"]');\r\n        this.allRadio = this.form.querySelectorAll('input[type=\"radio\"]');\r\n        this.allSwitch = this.form.querySelectorAll('.checkbox_switch');\r\n        this.allLabel = this.form.querySelectorAll('label');\r\n        this.allTabTitle = this.form.querySelectorAll('.tabsTitle .title');\r\n        this.allTabCon = this.form.querySelectorAll('.tabsContnet .con');\r\n        this.bindEvents();\r\n        new SaveSettings(this.form);\r\n        // new SaveSettings 会初始化选项，但可能会有一些选项的值在初始化过程中没有发生改变，也就不会被监听到变化。所以这里需要直接初始化以下状态。\r\n        this.initFormBueatiful();\r\n        // 激活第一个选项卡\r\n        this.activeTab(0);\r\n    }\r\n    // 设置表单上美化元素的状态\r\n    initFormBueatiful() {\r\n        // 设置改变时，重设 label 激活状态\r\n        this.resetLabelActive();\r\n        // 重设该选项的子选项的显示/隐藏\r\n        this.resetSubOptionDisplay();\r\n    }\r\n    // 设置激活的选项卡\r\n    activeTab(no = 0) {\r\n        for (const title of this.allTabTitle) {\r\n            title.classList.remove(this.activeClass);\r\n        }\r\n        this.allTabTitle[no].classList.add(this.activeClass);\r\n        for (const con of this.allTabCon) {\r\n            con.style.display = 'none';\r\n        }\r\n        this.allTabCon[no].style.display = 'block';\r\n    }\r\n    bindEvents() {\r\n        // 给美化的复选框绑定功能\r\n        for (const checkbox of this.allCheckBox) {\r\n            this.bindCheckboxEvent(checkbox);\r\n        }\r\n        // 给美化的单选按钮绑定功能\r\n        for (const radio of this.allRadio) {\r\n            this.bindRadioEvent(radio);\r\n        }\r\n        // 处理 label 状态\r\n        window.addEventListener(EVT.events.settingChange, () => {\r\n            this.initFormBueatiful();\r\n        });\r\n        // 在选项卡的标题上触发事件时，激活对应的选项卡\r\n        for (let index = 0; index < this.allTabTitle.length; index++) {\r\n            ;\r\n            ['click', 'mouseenter'].forEach((name) => {\r\n                this.allTabTitle[index].addEventListener(name, () => {\r\n                    this.activeTab(index);\r\n                });\r\n            });\r\n        }\r\n        // 当抓取完毕可以开始下载时，切换到“下载”选项卡\r\n        window.addEventListener(EVT.events.crawlFinish, () => {\r\n            if (!store.states.notAutoDownload) {\r\n                this.activeTab(1);\r\n            }\r\n        });\r\n        // 预览文件名\r\n        DOM.addBtn('namingBtns', Colors.green, lang.transl('_预览文件名')).addEventListener('click', () => {\r\n            EVT.fire(EVT.events.previewFileName);\r\n        }, false);\r\n        // 显示命名字段提示\r\n        this.form\r\n            .querySelector('.showFileNameTip')\r\n            .addEventListener('click', () => DOM.toggleEl(document.querySelector('.fileNameTip')));\r\n        // 输入框获得焦点时自动选择文本（文件名输入框例外）\r\n        const centerInputs = this.form.querySelectorAll('input[type=text]');\r\n        for (const el of centerInputs) {\r\n            if (el.name !== 'userSetName') {\r\n                el.addEventListener('focus', function () {\r\n                    this.select();\r\n                });\r\n            }\r\n        }\r\n        // 把下拉框的选择项插入到文本框里\r\n        this.insertValueToInput(this.form.fileNameSelect, this.form.userSetName);\r\n    }\r\n    // 把下拉框的选择项插入到文本框里\r\n    insertValueToInput(from, to) {\r\n        from.addEventListener('change', () => {\r\n            if (from.value !== 'default') {\r\n                // 把选择项插入到光标位置,并设置新的光标位置\r\n                const position = to.selectionStart;\r\n                to.value =\r\n                    to.value.substr(0, position) +\r\n                        from.value +\r\n                        to.value.substr(position, to.value.length);\r\n                to.selectionStart = position + from.value.length;\r\n                to.selectionEnd = position + from.value.length;\r\n                to.focus();\r\n            }\r\n        });\r\n    }\r\n    // 设置复选框的事件\r\n    bindCheckboxEvent(el) {\r\n        // 让复选框支持用回车键选择\r\n        el.addEventListener('keydown', (event) => {\r\n            if (this.chooseKeys.includes(event.code)) {\r\n                el.checked = !el.checked;\r\n                this.emitChange(el.name, el.checked);\r\n            }\r\n        });\r\n        // 点击美化按钮，反转复选框的值\r\n        el.nextElementSibling.addEventListener('click', () => {\r\n            el.checked = !el.checked;\r\n            this.emitChange(el.name, el.checked);\r\n        });\r\n        // 点击它的 label 时，传递它的值\r\n        const label = this.form.querySelector(`label[for=\"${el.id}\"]`);\r\n        if (label) {\r\n            label.addEventListener('click', () => {\r\n                // 点击复选框的 label 不要手动修改 checked ，因为浏览器会自动处理\r\n                this.emitChange(el.name, el.checked);\r\n            });\r\n        }\r\n    }\r\n    // 设置单选控件的事件\r\n    bindRadioEvent(el) {\r\n        // 点击美化按钮，选择当前单选控件\r\n        el.nextElementSibling.addEventListener('click', () => {\r\n            el.checked = true;\r\n            // 对于单选按钮，它的值是 value，不是 checked\r\n            this.emitChange(el.name, this.form[el.name].value);\r\n        });\r\n        // 点击它的 label 时，传递它的值\r\n        const label = this.form.querySelector(`label[for=\"${el.id}\"]`);\r\n        if (label) {\r\n            label.addEventListener('click', () => {\r\n                this.emitChange(el.name, this.form[el.name].value);\r\n            });\r\n        }\r\n    }\r\n    // 当选项的值被改变时，触发 settingChange 事件\r\n    emitChange(name, value) {\r\n        EVT.fire(EVT.events.settingChange, { name: name, value: value });\r\n    }\r\n    // 重设 label 的激活状态\r\n    resetLabelActive() {\r\n        // 设置复选框的 label 的激活状态\r\n        for (const checkbox of this.allCheckBox) {\r\n            this.setLabelActive(checkbox);\r\n        }\r\n        // 设置单选按钮的 label 的激活状态\r\n        for (const radio of this.allRadio) {\r\n            this.setLabelActive(radio);\r\n        }\r\n    }\r\n    // 设置 input 元素对应的 label 的激活状态\r\n    setLabelActive(input) {\r\n        const label = this.form.querySelector(`label[for=\"${input.id}\"]`);\r\n        if (label) {\r\n            const method = input.checked ? 'add' : 'remove';\r\n            label.classList[method]('active');\r\n        }\r\n    }\r\n    // 重设子选项的显示/隐藏\r\n    resetSubOptionDisplay() {\r\n        for (const _switch of this.allSwitch) {\r\n            const subOption = this.form.querySelector(`.subOptionWrap[data-show=\"${_switch.name}\"]`);\r\n            if (subOption) {\r\n                subOption.style.display = _switch.checked ? 'inline' : 'none';\r\n            }\r\n        }\r\n    }\r\n    // 获取作品张数设置\r\n    getFirstFewImages() {\r\n        const check = API.checkNumberGreater0(form.firstFewImages.value);\r\n        if (check.result) {\r\n            this.firstFewImages = check.value;\r\n            return check.value;\r\n        }\r\n    }\r\n    // 计算要从这个作品里下载几张图片\r\n    getDLCount(pageCount) {\r\n        if (form.firstFewImagesSwitch.checked && this.firstFewImages <= pageCount) {\r\n            return this.firstFewImages;\r\n        }\r\n        return pageCount;\r\n    }\r\n}\r\nconst setting = new Settings();\r\nconst form = setting.form;\r\nexport { setting, form };\r\n","// 仓库\r\nimport { EVT } from './EVT';\r\n// 存储抓取结果和状态\r\nclass Store {\r\n    constructor() {\r\n        this.idList = []; // 储存从列表中抓取到的作品的 id\r\n        this.resultMeta = []; // 储存抓取结果的元数据。\r\n        // 当用于图片作品时，它可以根据每个作品需要下载多少张，生成每一张图片的信息\r\n        this.resultIDList = []; // 储存抓取结果的元数据的 id 列表，用来判断该作品是否已经添加过了，避免重复添加\r\n        // resultIDList 可能会有隐患，因为没有区分图片和小说。如果一次抓取任务里，有图片和小说使用了相同的 id，那么只会保留先抓取到的那个。不过目前看来这种情况几乎不会发生。\r\n        this.result = []; // 储存抓取结果\r\n        this.rankList = {}; // 储存作品在排行榜中的排名\r\n        // 储存和下载有关的状态\r\n        this.states = {\r\n            allowWork: true,\r\n            quickDownload: false,\r\n            notAutoDownload: false,\r\n        };\r\n        // 储存页面信息，用来生成文件名\r\n        this.pageInfo = {\r\n            pageTitle: '',\r\n            pageTag: '',\r\n        };\r\n        const allowWorkTrue = [\r\n            EVT.events.crawlFinish,\r\n            EVT.events.crawlEmpty,\r\n            EVT.events.crawlError,\r\n            EVT.events.downloadPause,\r\n            EVT.events.downloadStop,\r\n        ];\r\n        allowWorkTrue.forEach((type) => {\r\n            window.addEventListener(type, () => {\r\n                this.states.allowWork = true;\r\n            });\r\n        });\r\n        const allowWorkFalse = [EVT.events.crawlStart, EVT.events.downloadStart];\r\n        allowWorkFalse.forEach((type) => {\r\n            window.addEventListener(type, () => {\r\n                this.states.allowWork = false;\r\n            });\r\n        });\r\n        window.addEventListener(EVT.events.crawlStart, () => {\r\n            this.resetResult();\r\n        });\r\n        window.addEventListener(EVT.events.downloadComplete, () => {\r\n            this.resetStates();\r\n        });\r\n    }\r\n    /*\r\n     id - 其实是默认名，包含两部分：id + 序号，如 44920385_p0。动图只有 id 没有序号\r\n     url - 图片大图的 url\r\n     title - 作品的标题\r\n     tags - 作品的 tag 列表\r\n     tagsTranslated - 作品的 tag 列表，附带翻译后的 tag（如果有）\r\n     user - 作品的画师名字\r\n     userid - 作品的画师id\r\n     fullWidth - 第一张图片的宽度\r\n     fullHeight - 第一张图片的高度\r\n     ext - 图片下载时使用的后缀名\r\n     bmk - 作品的收藏数量\r\n     date - 作品的创建日期，格式为 yyyy-MM-dd。如 2019-08-29\r\n     type - 作品的类型，分为 illustration、manga、ugoira\r\n     rank - 作品在排行榜中的排名\r\n     ugoiraInfo - 当作品是动图时才有值，包含 frames（数组）和 mimeType（string）属性\r\n     */\r\n    assignResult(data) {\r\n        // 图片详细信息的默认值\r\n        const dataDefault = {\r\n            idNum: 0,\r\n            id: '',\r\n            url: '',\r\n            thumb: '',\r\n            title: '',\r\n            pageCount: 1,\r\n            dlCount: 1,\r\n            tags: [],\r\n            tagsTranslated: [],\r\n            user: '',\r\n            userId: '',\r\n            fullWidth: 0,\r\n            fullHeight: 0,\r\n            ext: '',\r\n            bmk: 0,\r\n            bookmarked: false,\r\n            date: '',\r\n            type: 0,\r\n            rank: '',\r\n            ugoiraInfo: null,\r\n            seriesTitle: null,\r\n            seriesOrder: null,\r\n            novelBlob: null,\r\n        };\r\n        return Object.assign(dataDefault, data);\r\n    }\r\n    // 添加每个作品的信息。只需要传递有值的属性\r\n    addResult(data) {\r\n        // 检查该作品数据是否已存在，已存在则不添加\r\n        if (data.idNum !== undefined && this.resultIDList.includes(data.idNum)) {\r\n            return;\r\n        }\r\n        if (data.idNum !== undefined) {\r\n            this.resultIDList.push(data.idNum);\r\n        }\r\n        // 添加该作品的元数据\r\n        const result = this.assignResult(data);\r\n        this.resultMeta.push(result);\r\n        EVT.fire(EVT.events.addResult, result);\r\n        if (result.type === 3) {\r\n            this.result.push(result);\r\n        }\r\n        else {\r\n            // 添加该作品里每一张图片的数据\r\n            for (let i = 0; i < result.dlCount; i++) {\r\n                const result = this.assignResult(data);\r\n                result.idNum = parseInt(result.id);\r\n                result.id = result.id + `_p${i}`;\r\n                result.url = result.url.replace('p0', 'p' + i);\r\n                this.result.push(result);\r\n            }\r\n        }\r\n    }\r\n    getRankList(index) {\r\n        return this.rankList[index];\r\n    }\r\n    setRankList(id, rank) {\r\n        this.rankList[id] = rank;\r\n    }\r\n    resetResult() {\r\n        this.resultMeta = [];\r\n        this.resultIDList = [];\r\n        this.result = [];\r\n        this.idList = [];\r\n        this.rankList = {};\r\n    }\r\n    resetStates() {\r\n        this.states.allowWork = true;\r\n        this.states.quickDownload = false;\r\n    }\r\n}\r\nconst store = new Store();\r\nexport { store };\r\n","import { lang } from './Lang';\r\nimport { EVT } from './EVT';\r\nimport { API } from './API';\r\nimport config from './Config';\r\n// 辅助功能\r\nclass Support {\r\n    constructor() {\r\n        this.newTag = '_xzNew660';\r\n        this.checkConflict();\r\n        this.supportListenHistory();\r\n        this.listenPageSwitch();\r\n        this.checkNew();\r\n        this.showNew();\r\n        API.updateToken();\r\n        window.addEventListener(EVT.events.resetOption, () => {\r\n            localStorage.removeItem('xzToken');\r\n            API.updateToken();\r\n        });\r\n    }\r\n    // 处理和脚本版的冲突\r\n    checkConflict() {\r\n        // 标注自己\r\n        window.sessionStorage.setItem('xz_pixiv_extension', '1');\r\n        // 把脚本版的标记设置为 0，这样脚本版就不会运行\r\n        window.sessionStorage.setItem('xz_pixiv_userscript', '0');\r\n    }\r\n    // 检查新版本\r\n    async checkNew() {\r\n        // 读取上一次检查的时间，如果超过指定的时间，则检查 GitHub 上的信息\r\n        const lastTime = localStorage.getItem('xzUpdateTime');\r\n        if (!lastTime ||\r\n            new Date().getTime() - parseInt(lastTime) > 60 * 30 * 1000) {\r\n            // 获取最新的 releases 信息\r\n            const latest = await fetch(config.latestReleaseAPI);\r\n            const latestJson = await latest.json();\r\n            const latestVer = latestJson.name;\r\n            // 保存 GitHub 上的版本信息\r\n            localStorage.setItem('xzGithubVer', latestVer);\r\n            // 保存本次检查的时间戳\r\n            localStorage.setItem('xzUpdateTime', new Date().getTime().toString());\r\n        }\r\n        // 获取本地扩展的版本号\r\n        const manifest = await fetch(chrome.extension.getURL('manifest.json'));\r\n        const manifestJson = await manifest.json();\r\n        const manifestVer = manifestJson.version;\r\n        // 比较大小\r\n        const latestVer = localStorage.getItem('xzGithubVer');\r\n        if (latestVer && manifestVer < latestVer) {\r\n            EVT.fire('hasNewVer');\r\n        }\r\n    }\r\n    // 显示最近更新内容\r\n    showNew() {\r\n        if (window.location.host.includes('pixiv.net') &&\r\n            !localStorage.getItem(this.newTag)) {\r\n            const whatIsNewHtml = `\n      <div class=\"xz_new\">\n        <p class=\"title\">Powerful Pixiv Downloader ${lang.transl('_最近更新')}</p>\n        <p class=\"content\">${lang.transl(this.newTag)}</p>\n        <button class=\"btn\">${lang.transl('_确定')}</button>\n      </div>`;\r\n            document.body.insertAdjacentHTML('afterbegin', whatIsNewHtml);\r\n            const whatIsNewEl = document.querySelector('.xz_new');\r\n            whatIsNewEl.querySelector('.btn').addEventListener('click', () => {\r\n                localStorage.setItem(this.newTag, '1');\r\n                whatIsNewEl.parentNode.removeChild(whatIsNewEl);\r\n            });\r\n        }\r\n    }\r\n    // 使用无刷新加载的页面需要监听 url 的改变，这里为这些事件添加监听支持\r\n    supportListenHistory() {\r\n        const element = document.createElement('script');\r\n        element.setAttribute('type', 'text/javascript');\r\n        element.innerHTML = `\n    let _wr = function (type) {\n      let orig = history[type];\n      return function () {\n        let rv = orig.apply(this, arguments);\n        let e = new Event(type);\n        e.arguments = arguments;\n        window.dispatchEvent(e);\n        return rv;\n      };\n    };\n    history.pushState = _wr('pushState');\n    history.replaceState = _wr('replaceState');\n    `;\r\n        document.head.appendChild(element);\r\n    }\r\n    // 监听页面的无刷新切换。某些页面可以无刷新切换，这时需要进行一些处理\r\n    listenPageSwitch() {\r\n        // 绑定无刷新切换页面的事件，只绑定一次\r\n        // pixiv 的后退使用 replaceState\r\n        // pushState 判断从列表页进入作品页的情况，popstate 判断从作品页退回列表页的情况\r\n        ;\r\n        ['pushState', 'popstate', 'replaceState'].forEach((item) => {\r\n            window.addEventListener(item, () => {\r\n                EVT.fire(EVT.events.pageSwitch);\r\n            });\r\n        });\r\n    }\r\n}\r\nnew Support();\r\n","// 检查 pixiv 的颜色模式，并给下载器设置对应的样式。目前只有普通模式和夜间模式。\r\n// 把需要响应主题变化的元素注册到这个组件里，元素会被添加当前主题的 className\r\n// 默认主题是没有 className 的，其他主题通过对应的 className，在默认主题的基础上更改样式。\r\nclass ThemeColor {\r\n    constructor() {\r\n        this.selector = '#gtm-var-theme-kind'; // 通过这个选择器查找含有主题标记的元素\r\n        this.timer = 0;\r\n        this._theme = ''; // 保存当前获取到的主题标记\r\n        // 主题标记以及对应的 className\r\n        this.colorMap = new Map([['dark', 'theme-dark']]);\r\n        this.elList = []; // 保存已注册的元素\r\n        // 初始化时使用定时器查找标记元素\r\n        this.timer = window.setTimeout(() => {\r\n            this.findFlag();\r\n        }, 300);\r\n    }\r\n    // 含有主题标记的元素，并监听其变化\r\n    findFlag() {\r\n        const el = document.querySelector(this.selector);\r\n        if (el) {\r\n            window.clearTimeout(this.timer);\r\n            this.theme = el.textContent;\r\n            // 监听标记元素的 textContent 变化\r\n            const ob = new MutationObserver((mutationsList) => {\r\n                for (const item of mutationsList) {\r\n                    if (item.type === 'characterData') {\r\n                        this.theme = item.target.nodeValue;\r\n                        break;\r\n                    }\r\n                }\r\n            });\r\n            ob.observe(el, {\r\n                characterData: true,\r\n                subtree: true,\r\n            });\r\n        }\r\n    }\r\n    set theme(flag) {\r\n        if (!flag) {\r\n            return;\r\n        }\r\n        this._theme = flag;\r\n        for (const el of this.elList) {\r\n            this.setClass(el);\r\n        }\r\n    }\r\n    get theme() {\r\n        return this._theme;\r\n    }\r\n    // 把元素注册到本组件里\r\n    register(el) {\r\n        this.elList.push(el);\r\n        this.setClass(el);\r\n    }\r\n    // 给元素设置主题对应的 className\r\n    setClass(el) {\r\n        // 先清除所有主题颜色的 className\r\n        for (const className of this.colorMap.values()) {\r\n            if (el.classList.contains(className)) {\r\n                el.classList.remove(className);\r\n            }\r\n        }\r\n        // 添加当前主题对应的 className\r\n        const name = this.colorMap.get(this._theme);\r\n        name && el.classList.add(name);\r\n    }\r\n}\r\nconst themeColor = new ThemeColor();\r\nexport { themeColor };\r\n","// 显示自定义的提示\r\nclass Tip {\r\n    constructor() {\r\n        this.tipEl = document.createElement('div'); // tip 元素\r\n        this.addTipEl();\r\n    }\r\n    // 显示提示\r\n    addTipEl() {\r\n        const tipHTML = `<div id=\"tip\"></div>`;\r\n        document.body.insertAdjacentHTML('beforeend', tipHTML);\r\n        this.tipEl = document.getElementById('tip');\r\n        const tips = document.querySelectorAll('.has_tip');\r\n        for (const el of tips) {\r\n            for (const ev of ['mouseenter', 'mouseleave']) {\r\n                el.addEventListener(ev, (event) => {\r\n                    const e = (event || window.event);\r\n                    const text = el.dataset.tip;\r\n                    this.showTip(text, {\r\n                        type: ev === 'mouseenter' ? 1 : 0,\r\n                        x: e.clientX,\r\n                        y: e.clientY,\r\n                    });\r\n                });\r\n            }\r\n        }\r\n    }\r\n    // 显示中间面板上的提示。参数 arg 指示鼠标是移入还是移出，并包含鼠标位置\r\n    showTip(text, arg) {\r\n        if (!text) {\r\n            throw new Error('No tip text.');\r\n        }\r\n        if (arg.type === 1) {\r\n            this.tipEl.innerHTML = text;\r\n            this.tipEl.style.left = arg.x + 30 + 'px';\r\n            this.tipEl.style.top = arg.y - 30 + 'px';\r\n            this.tipEl.style.display = 'block';\r\n        }\r\n        else if (arg.type === 0) {\r\n            this.tipEl.style.display = 'none';\r\n        }\r\n    }\r\n}\r\nnew Tip();\r\n","// 在标题栏上显示下载器工作状态\r\nimport { pageType } from './PageType';\r\nclass TitleBar {\r\n    constructor() {\r\n        /*\r\n        本程序的状态会以 [string] 形式添加到 title 最前面，并闪烁提醒\r\n        string 及其含义如下：\r\n        ↑ 抓取中\r\n        → 等待下一步操作（搜索页）\r\n        ▶ 可以开始下载\r\n        ↓ 下载中\r\n        ║ 下载暂停\r\n        ■ 下载停止\r\n        ✓ 下载完毕\r\n          空格，当需要闪烁标题时使用\r\n        */\r\n        this.status = ['↑', '→', '▶', '↓', '║', '■', '✓', ' '];\r\n        this.timer = 0; // 修改 title 的定时器\r\n    }\r\n    // 检查标题里有没有本程序定义的状态字符\r\n    haveStatus(status = '') {\r\n        if (!status) {\r\n            // 没有传递 status，则检查所有标记\r\n            for (const status of this.status) {\r\n                const str = `[${status}]`;\r\n                if (document.title.includes(str)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // 检查指定标记\r\n            const str = `[${status}]`;\r\n            return document.title.includes(str);\r\n        }\r\n        return false;\r\n    }\r\n    // 重设 title\r\n    reset() {\r\n        const type = pageType.getPageType();\r\n        clearInterval(this.timer);\r\n        // 储存标题的 mete 元素。在某些页面不存在，有时也与实际上的标题不一致。\r\n        const ogTitle = document.querySelector('meta[property=\"og:title\"]');\r\n        // 无刷新自动加载的页面里，og:title 标签是最早更新标题的，内容也一致。\r\n        if (ogTitle && (type == 1 || type === 2)) {\r\n            document.title = ogTitle.content;\r\n        }\r\n        else {\r\n            // 如果当前 title 里有状态提醒，则设置为状态后面的文字\r\n            if (this.haveStatus()) {\r\n                const index = document.title.indexOf(']');\r\n                document.title = document.title.substr(index + 1, document.title.length);\r\n            }\r\n        }\r\n    }\r\n    // 修改title\r\n    change(string) {\r\n        const state = `[${string}]`;\r\n        // 如果 title 里没有状态，就添加状态\r\n        if (!this.haveStatus()) {\r\n            document.title = `${state} ${document.title}`;\r\n        }\r\n        else {\r\n            // 如果已经有状态了，则替换为新当前传入的状态\r\n            document.title = document.title.replace(/\\[.?\\]/, state);\r\n        }\r\n        // 闪烁提醒，其实是把 [▶] 或 [→] 与空白 [ ] 来回切换\r\n        if (string === '▶' || string === '→') {\r\n            this.timer = window.setInterval(() => {\r\n                if (this.haveStatus(string)) {\r\n                    // 如果含有状态，就替换成空白\r\n                    document.title = document.title.replace(state, '[ ]');\r\n                }\r\n                else {\r\n                    if (this.haveStatus(' ')) {\r\n                        // 如果含有空白，就替换成状态\r\n                        document.title = document.title.replace('[ ]', state);\r\n                    }\r\n                    else {\r\n                        // 如果都没有，一般是页面切换了，标题被重置了，取消执行闪烁（此时也根本无法形成闪烁效果了）\r\n                        clearInterval(this.timer);\r\n                    }\r\n                }\r\n            }, 500);\r\n        }\r\n        else {\r\n            clearInterval(this.timer);\r\n        }\r\n    }\r\n}\r\nconst titleBar = new TitleBar();\r\nexport { titleBar };\r\n","// 初始化地区排行榜页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../Options';\r\nimport { filter } from '../Filter';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nclass InitAreaRankingPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取本页作品'), [\r\n            ['title', lang.transl('_抓取本页作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        options.hideOption([1]);\r\n    }\r\n    async getIdList() {\r\n        const allPicArea = document.querySelectorAll('.ranking-item>.work_wrapper');\r\n        for (const el of allPicArea) {\r\n            const img = el.querySelector('._thumbnail');\r\n            // img.dataset.type 全都是 \"illust\"，因此不能用来区分作品类型\r\n            // 提取出 tag 列表\r\n            const id = img.dataset.id;\r\n            const tags = img.dataset.tags.split(' ');\r\n            // 有的作品没有收藏按钮，点进去之后发现这个作品已经被删除了，只是排行榜里没有及时更新。这样的作品没有收藏按钮。\r\n            const bookmarkBtn = el.querySelector('._one-click-bookmark');\r\n            const bookmarked = bookmarkBtn\r\n                ? bookmarkBtn.classList.contains('on')\r\n                : false;\r\n            const filterOpt = {\r\n                id: id,\r\n                tags: tags,\r\n                bookmarkData: bookmarked,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                const id = API.getIllustId(el.querySelector('a').href);\r\n                store.idList.push({\r\n                    type: 'unknown',\r\n                    id,\r\n                });\r\n            }\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() { }\r\n}\r\nexport { InitAreaRankingPage };\r\n","//初始化 artwork 作品页\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { EVT } from '../EVT';\r\nimport { lang } from '../Lang';\r\nimport { options } from '../Options';\r\nimport { store } from '../Store';\r\nimport { QuickBookmark } from '../QuickBookmark';\r\nimport { ImgViewer } from '../ImgViewer';\r\nimport { DOM } from '../DOM';\r\nimport { API } from '../API';\r\nimport { log } from '../Log';\r\nimport { SaveAvatarIcon } from '../SaveAvatarIcon';\r\nclass InitArtworkPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.crawlDirection = 0; // 抓取方向，在作品页内指示抓取新作品还是旧作品\r\n        /*\r\n        -1 抓取新作品\r\n        0 不设置抓取方向\r\n        1 抓取旧作品\r\n        */\r\n        this.crawlRelated = false; // 是否下载相关作品（作品页内的）\r\n        this.quickDownBtn = document.createElement('div');\r\n        this.init();\r\n    }\r\n    initElse() {\r\n        // 初始化快速收藏功能和图片查看器\r\n        this.initQuickBookmark();\r\n        this.initImgViewer();\r\n        // 页面切换再次初始化\r\n        window.addEventListener(EVT.events.pageSwitch, this.initQuickBookmark);\r\n        window.addEventListener(EVT.events.pageSwitch, this.initImgViewer);\r\n    }\r\n    initImgViewer() {\r\n        new ImgViewer();\r\n    }\r\n    initQuickBookmark() {\r\n        new QuickBookmark();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_从本页开始抓取new')).addEventListener('click', () => {\r\n            this.crawlDirection = -1;\r\n            this.readyCrawl();\r\n        });\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_从本页开始抓取old')).addEventListener('click', () => {\r\n            this.crawlDirection = 1;\r\n            this.readyCrawl();\r\n        });\r\n        const downRelatedBtn = DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取相关作品'));\r\n        downRelatedBtn.addEventListener('click', () => {\r\n            this.crawlRelated = true;\r\n            this.readyCrawl();\r\n        }, false);\r\n        const btn = DOM.addBtn('otherBtns', Colors.green, lang.transl('_保存用户头像为图标'), [\r\n            ['title', lang.transl('_保存用户头像为图标说明')],\r\n        ]);\r\n        new SaveAvatarIcon(btn);\r\n    }\r\n    appendElseEl() {\r\n        // 在右侧创建快速下载按钮\r\n        this.quickDownBtn.id = 'quick_down_btn';\r\n        this.quickDownBtn.textContent = '↓';\r\n        this.quickDownBtn.setAttribute('title', lang.transl('_快速下载本页'));\r\n        document.body.appendChild(this.quickDownBtn);\r\n        this.quickDownBtn.addEventListener('click', () => {\r\n            store.states.quickDownload = true;\r\n            this.readyCrawl();\r\n        }, false);\r\n    }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        options.setWantPage({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_从本页开始下载提示') +\r\n                '<br>' +\r\n                lang.transl('_相关作品大于0'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n            value: '-1',\r\n        });\r\n    }\r\n    destroy() {\r\n        DOM.clearSlot('crawlBtns');\r\n        DOM.clearSlot('otherBtns');\r\n        // 删除快速下载按钮\r\n        DOM.removeEl(this.quickDownBtn);\r\n        // 解除切换页面时绑定的事件\r\n        window.removeEventListener(EVT.events.pageSwitch, this.initQuickBookmark);\r\n        window.removeEventListener(EVT.events.pageSwitch, this.initImgViewer);\r\n    }\r\n    getWantPage() {\r\n        if (store.states.quickDownload) {\r\n            // 快速下载\r\n            this.crawlNumber = 1;\r\n        }\r\n        else {\r\n            // 检查下载页数的设置\r\n            if (!this.crawlRelated) {\r\n                const crawlAllTip = this.crawlDirection === -1\r\n                    ? lang.transl('_从本页开始抓取new')\r\n                    : lang.transl('_从本页开始抓取old');\r\n                this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x个作品'), crawlAllTip);\r\n            }\r\n            else {\r\n                // 相关作品的提示\r\n                this.crawlNumber = this.checkWantPageInput(lang.transl('_下载x个相关作品'), lang.transl('_下载所有相关作品'));\r\n            }\r\n        }\r\n    }\r\n    nextStep() {\r\n        // 下载相关作品\r\n        if (this.crawlRelated) {\r\n            this.getRelatedList();\r\n        }\r\n        else if (store.states.quickDownload) {\r\n            // 快速下载\r\n            store.idList.push({\r\n                type: 'unknown',\r\n                id: API.getIllustId(window.location.href),\r\n            });\r\n            log.log(lang.transl('_开始获取作品页面'));\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 向前向后下载\r\n            this.getIdList();\r\n        }\r\n    }\r\n    async getIdList() {\r\n        let type = ['illusts', 'manga'];\r\n        let idList = await API.getUserWorksByType(DOM.getUserId(), type);\r\n        // 储存符合条件的 id\r\n        let nowId = parseInt(API.getIllustId(window.location.href));\r\n        idList.forEach((id) => {\r\n            let idNum = parseInt(id.id);\r\n            // 新作品\r\n            if (idNum >= nowId && this.crawlDirection === -1) {\r\n                store.idList.push(id);\r\n            }\r\n            else if (idNum <= nowId && this.crawlDirection === 1) {\r\n                // 旧作品\r\n                store.idList.push(id);\r\n            }\r\n        });\r\n        // 当设置了下载个数时，进行裁剪\r\n        if (this.crawlNumber !== -1) {\r\n            // 新作品 升序排列\r\n            if (this.crawlDirection === -1) {\r\n                store.idList.sort(API.sortByProperty('id')).reverse();\r\n            }\r\n            else {\r\n                // 旧作品 降序排列\r\n                store.idList.sort(API.sortByProperty('id'));\r\n            }\r\n            store.idList = store.idList.splice(0, this.crawlNumber);\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    // 下载相关作品时使用\r\n    async getRelatedList() {\r\n        let data = await API.getRelatedData(API.getIllustId());\r\n        const recommendData = data.body.recommendMethods;\r\n        // 取出相关作品的 id 列表\r\n        let recommendIdList = Object.keys(recommendData);\r\n        // 当设置了下载个数时，进行裁剪\r\n        if (this.crawlNumber !== -1) {\r\n            recommendIdList = recommendIdList.reverse().slice(0, this.crawlNumber);\r\n        }\r\n        for (const id of recommendIdList) {\r\n            store.idList.push({\r\n                type: 'unknown',\r\n                id,\r\n            });\r\n        }\r\n        log.log(lang.transl('_相关作品抓取完毕', store.idList.length.toString()));\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.crawlDirection = 0; // 解除下载方向的标记\r\n        this.crawlRelated = false; // 解除下载相关作品的标记\r\n    }\r\n}\r\nexport { InitArtworkPage };\r\n","// 初始化 bookmark_detail 页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../Options';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nclass InitBookmarkDetailPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取相似图片'), [\r\n            ['title', lang.transl('_抓取相似图片')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        }, false);\r\n    }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        options.setWantPage({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_想要获取多少个作品'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n            value: this.maxCount.toString(),\r\n        });\r\n    }\r\n    getWantPage() {\r\n        const check = this.checkWantPageInputGreater0();\r\n        if (check == undefined) {\r\n            return;\r\n        }\r\n        this.crawlNumber = check;\r\n        if (this.crawlNumber > this.maxCount) {\r\n            this.crawlNumber = this.maxCount;\r\n        }\r\n    }\r\n    // 获取相似的作品列表\r\n    async getIdList() {\r\n        let data = await API.getRecommenderData(API.getIllustId(), this.crawlNumber);\r\n        for (const id of data.recommendations) {\r\n            store.idList.push({\r\n                type: 'unknown',\r\n                id: id.toString(),\r\n            });\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() { }\r\n}\r\nexport { InitBookmarkDetailPage };\r\n","// 初始化 关注的新作品 artwork 页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../Options';\r\nimport { filter } from '../Filter';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nclass InitBookmarkNewArtworkPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.r18 = false;\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    appendElseEl() { }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        this.maxCount = 100;\r\n        options.setWantPage({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n            value: this.maxCount.toString(),\r\n        });\r\n    }\r\n    getWantPage() {\r\n        const check = this.checkWantPageInputGreater0();\r\n        if (check == undefined) {\r\n            return;\r\n        }\r\n        this.crawlNumber = check;\r\n        if (this.crawlNumber > this.maxCount) {\r\n            this.crawlNumber = this.maxCount;\r\n        }\r\n        log.warning(lang.transl('_任务开始1', this.crawlNumber.toString()));\r\n    }\r\n    nextStep() {\r\n        this.r18 = location.pathname.includes('r18');\r\n        const p = API.getURLSearchField(location.href, 'p');\r\n        this.startpageNo = parseInt(p) || 1;\r\n        this.getIdList();\r\n    }\r\n    async getIdList() {\r\n        let p = this.startpageNo + this.listPageFinished;\r\n        // 发起请求，获取列表页\r\n        let worksData;\r\n        try {\r\n            worksData = await API.getBookmarkNewIllustData(p, this.r18);\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        // 检查一些此时可以进行检查的设置项\r\n        for (const data of worksData) {\r\n            const filterOpt = {\r\n                id: data.illustId,\r\n                width: data.width,\r\n                height: data.height,\r\n                pageCount: data.pageCount,\r\n                bookmarkData: data.isBookmarked,\r\n                illustType: parseInt(data.illustType),\r\n                tags: data.tags,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: API.getWorkType(data.illustType),\r\n                    id: data.illustId,\r\n                });\r\n            }\r\n        }\r\n        this.listPageFinished++;\r\n        log.log(lang.transl('_列表页抓取进度', this.listPageFinished.toString()), 1, false);\r\n        // 判断任务状态\r\n        // 如果抓取了所有页面，或者抓取完指定页面\r\n        if (p >= this.maxCount || this.listPageFinished === this.crawlNumber) {\r\n            log.log(lang.transl('_列表页抓取完成'));\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 继续抓取\r\n            this.getIdList();\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listPageFinished = 0;\r\n    }\r\n}\r\nexport { InitBookmarkNewArtworkPage };\r\n","// 初始化发现页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../Options';\r\nimport { DeleteWorks } from '../DeleteWorks';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nclass InitDiscoverPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取当前作品'), [\r\n            ['title', lang.transl('_抓取当前作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        options.hideOption([1]);\r\n    }\r\n    appendElseEl() {\r\n        const deleteWorks = new DeleteWorks('._2RNjBox');\r\n        deleteWorks.addClearMultipleBtn('._3b8AXEx');\r\n        deleteWorks.addClearUgoiraBtn('.AGgsUWZ');\r\n        deleteWorks.addManuallyDeleteBtn();\r\n    }\r\n    getWantPage() { }\r\n    getIdList() {\r\n        // 在发现页面，仅下载已有部分，所以不需要去获取列表页\r\n        const nowIllust = document.querySelectorAll('figure>div>a');\r\n        // 获取已有作品的 id\r\n        Array.from(nowIllust).forEach((el) => {\r\n            // discovery 列表的 url 是有额外后缀的，需要去掉\r\n            const id = API.getIllustId(el.href.split('&uarea')[0]);\r\n            store.idList.push({\r\n                type: 'unknown',\r\n                id,\r\n            });\r\n        });\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() { }\r\n}\r\nexport { InitDiscoverPage };\r\n","// 初始化 大家的新作品 artwork 页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { options } from '../Options';\r\nimport { filter } from '../Filter';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nimport { DOM } from '../DOM';\r\nclass InitNewArtworkPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.option = this.resetOption();\r\n        this.limitMax = 20; // 每次请求的数量最大是 20\r\n        this.fetchCount = 0; // 已请求的作品数量\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_下载大家的新作品')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    appendElseEl() { }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        options.setWantPage({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_想要获取多少个作品'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n            value: '100',\r\n        });\r\n    }\r\n    getWantPage() {\r\n        const check = this.checkWantPageInputGreater0();\r\n        if (check == undefined) {\r\n            return;\r\n        }\r\n        this.crawlNumber = check;\r\n        if (this.crawlNumber > this.maxCount) {\r\n            this.crawlNumber = this.maxCount;\r\n        }\r\n        log.warning(lang.transl('_抓取多少个作品', this.crawlNumber.toString()));\r\n    }\r\n    nextStep() {\r\n        this.initFetchURL();\r\n        this.getIdList();\r\n    }\r\n    resetOption() {\r\n        return {\r\n            lastId: '0',\r\n            limit: '20',\r\n            type: '',\r\n            r18: '',\r\n        };\r\n    }\r\n    // 组织要请求的 url\r\n    initFetchURL() {\r\n        this.option = this.resetOption();\r\n        if (this.crawlNumber < this.limitMax) {\r\n            this.option.limit = this.crawlNumber.toString();\r\n        }\r\n        else {\r\n            this.option.limit = this.limitMax.toString();\r\n        }\r\n        // 当前页面的作品类型，默认是 illust\r\n        this.option.type = API.getURLSearchField(location.href, 'type') || 'illust';\r\n        // 是否是 R18 模式\r\n        this.option.r18 = (location.href.includes('_r18.php') || false).toString();\r\n    }\r\n    async getIdList() {\r\n        let data;\r\n        try {\r\n            data = await API.getNewIllustData(this.option);\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        let useData = data.body.illusts;\r\n        for (const nowData of useData) {\r\n            // 抓取够了指定的数量\r\n            if (this.fetchCount + 1 > this.crawlNumber) {\r\n                break;\r\n            }\r\n            else {\r\n                this.fetchCount++;\r\n            }\r\n            // 排除广告信息\r\n            if (nowData.isAdContainer) {\r\n                continue;\r\n            }\r\n            const filterOpt = {\r\n                id: nowData.illustId,\r\n                width: nowData.width,\r\n                height: nowData.height,\r\n                pageCount: nowData.pageCount,\r\n                bookmarkData: nowData.bookmarkData,\r\n                illustType: nowData.illustType,\r\n                tags: nowData.tags,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: API.getWorkType(nowData.illustType),\r\n                    id: nowData.illustId,\r\n                });\r\n            }\r\n        }\r\n        log.log(lang.transl('_新作品进度', this.fetchCount.toString()), 1, false);\r\n        // 抓取完毕\r\n        if (this.fetchCount >= this.crawlNumber ||\r\n            this.fetchCount >= this.maxCount) {\r\n            log.log(lang.transl('_开始获取作品页面'));\r\n            this.getIdListFinished();\r\n            return;\r\n        }\r\n        // 继续抓取\r\n        this.option.lastId = data.body.lastId;\r\n        this.getIdList();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.fetchCount = 0;\r\n    }\r\n}\r\nexport { InitNewArtworkPage };\r\n","// 初始化 artwork 排行榜页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { API } from '../API';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../Options';\r\nimport { form } from '../Settings';\r\nimport { filter } from '../Filter';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nclass InitRankingArtworkPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.pageCount = 10; // 排行榜的页数\r\n        this.option = this.resetOption();\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取本排行榜作品'), [\r\n            ['title', lang.transl('_抓取本排行榜作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            form.debut.value = '0';\r\n            this.readyCrawl();\r\n        });\r\n        // 判断当前页面是否有“首次登场”标记\r\n        let debutModes = ['daily', 'daily_r18', 'rookie', ''];\r\n        let mode = API.getURLSearchField(location.href, 'mode');\r\n        if (debutModes.includes(mode)) {\r\n            DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取首次登场的作品'), [\r\n                ['title', lang.transl('_抓取首次登场的作品Title')],\r\n            ]).addEventListener('click', () => {\r\n                form.debut.value = '1';\r\n                this.readyCrawl();\r\n            });\r\n        }\r\n    }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        this.maxCount = 500;\r\n        options.setWantPage({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_想要获取多少个作品'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n            value: this.maxCount.toString(),\r\n        });\r\n    }\r\n    resetOption() {\r\n        return { mode: 'daily', p: 1, worksType: '', date: '' };\r\n    }\r\n    setPartNum() {\r\n        // 设置页数。排行榜页面一页有50张作品，当页面到达底部时会加载下一页\r\n        if (location.pathname.includes('r18g')) {\r\n            // r18g 只有1个榜单，固定1页\r\n            this.pageCount = 1;\r\n        }\r\n        else if (location.pathname.includes('_r18')) {\r\n            // r18 模式，这里的6是最大值，有的排行榜并没有6页\r\n            this.pageCount = 6;\r\n        }\r\n        else {\r\n            // 普通模式，这里的10也是最大值。如果实际没有10页，则在检测到404页面的时候停止抓取下一页\r\n            this.pageCount = 10;\r\n        }\r\n    }\r\n    getWantPage() {\r\n        this.listPageFinished = 0;\r\n        // 检查下载页数的设置\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_下载排行榜前x个作品'), lang.transl('_向下获取所有作品'));\r\n        // 如果设置的作品个数是 -1，则设置为下载所有作品\r\n        if (this.crawlNumber === -1) {\r\n            this.crawlNumber = 500;\r\n        }\r\n    }\r\n    nextStep() {\r\n        // 设置 option 信息\r\n        // mode 一定要有值，其他选项不需要\r\n        this.option = this.resetOption();\r\n        this.option.mode = API.getURLSearchField(location.href, 'mode') || 'daily';\r\n        this.option.worksType = API.getURLSearchField(location.href, 'content');\r\n        this.option.date = API.getURLSearchField(location.href, 'date');\r\n        this.startpageNo = 1;\r\n        this.setPartNum();\r\n        this.getIdList();\r\n    }\r\n    async getIdList() {\r\n        this.option.p = this.startpageNo + this.listPageFinished;\r\n        // 发起请求，获取作品列表\r\n        let data;\r\n        try {\r\n            data = await API.getRankingData(this.option);\r\n        }\r\n        catch (error) {\r\n            if (error.status === 404) {\r\n                // 如果发生了404错误，则中断抓取，直接下载已有部分。因为可能确实没有下一部分了\r\n                console.log('404错误，直接下载已有部分');\r\n                this.getIdListFinished();\r\n            }\r\n            return;\r\n        }\r\n        this.listPageFinished++;\r\n        const contents = data.contents; // 取出作品信息列表\r\n        for (const data of contents) {\r\n            // 检查是否已经抓取到了指定数量的作品\r\n            if (data.rank > this.crawlNumber) {\r\n                return this.getIdListFinished();\r\n            }\r\n            // 目前，数据里并没有包含收藏数量，所以在这里没办法检查收藏数量要求\r\n            const filterOpt = {\r\n                id: data.illust_id,\r\n                illustType: parseInt(data.illust_type),\r\n                tags: data.tags,\r\n                pageCount: parseInt(data.illust_page_count),\r\n                bookmarkData: data.is_bookmarked,\r\n                width: data.width,\r\n                height: data.height,\r\n                yes_rank: data.yes_rank,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.setRankList(data.illust_id.toString(), data.rank.toString());\r\n                store.idList.push({\r\n                    type: API.getWorkType(data.illust_type),\r\n                    id: data.illust_id.toString(),\r\n                });\r\n            }\r\n        }\r\n        log.log(lang.transl('_排行榜进度', this.listPageFinished.toString()), 1, false);\r\n        // 抓取完毕\r\n        if (this.listPageFinished === this.pageCount) {\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 继续抓取\r\n            this.getIdList();\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listPageFinished = 0;\r\n    }\r\n}\r\nexport { InitRankingArtworkPage };\r\n","var __asyncValues = (this && this.__asyncValues) || function (o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n};\r\n// 初始化 artwork 搜索页\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { options } from '../Options';\r\nimport { pageInfo } from '../PageInfo';\r\nimport { DeleteWorks } from '../DeleteWorks';\r\nimport { EVT } from '../EVT';\r\nimport { filter } from '../Filter';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nimport { centerPanel } from '../CenterPanel';\r\nimport { titleBar } from '../TitleBar';\r\nimport { setting, form } from '../Settings';\r\nimport { FastScreen } from '../FastScreen';\r\nimport { DOM } from '../DOM';\r\nimport { BookmarkAllWorks } from '../BookmarkAllWorks';\r\nclass InitSearchArtworkPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.worksWrapSelector = '#root section ul';\r\n        this.listClass = 'searchList';\r\n        this.multipleClass = 'multiplePart';\r\n        this.ugoiraClass = 'ugoiraPart';\r\n        this.addBMKBtnClass = 'bmkBtn';\r\n        this.bookmarkedClass = 'bookmarked';\r\n        this.countSelector = 'section h3+div span';\r\n        this.hotWorkAsideSelector = 'section aside';\r\n        this.worksType = '';\r\n        this.option = {};\r\n        this.worksNoPerPage = 60; // 每个页面有多少个作品\r\n        this.needCrawlPageCount = 0; // 一共有有多少个列表页面\r\n        this.sendCrawlTaskCount = 0; // 已经抓取了多少个列表页面\r\n        this.allOption = [\r\n            'order',\r\n            'type',\r\n            'wlt',\r\n            'wgt',\r\n            'hlt',\r\n            'hgt',\r\n            'ratio',\r\n            'tool',\r\n            's_mode',\r\n            'mode',\r\n            'scd',\r\n            'ecd',\r\n            'blt',\r\n            'bgt',\r\n        ];\r\n        this.resultMeta = []; // 每次“开始筛选”完成后，储存当时所有结果，以备“在结果中筛选”使用\r\n        this.worksWrap = null;\r\n        this.deleteId = 0; // 手动删除时，要删除的作品的 id\r\n        this.crawlWorks = false; // 是否在抓取作品数据（“开始筛选”时改为 true）\r\n        this.crawled = false; // 是否已经进行过抓取\r\n        this.previewResult = true; // 是否预览结果\r\n        this.optionsCauseResultChange = ['firstFewImagesSwitch', 'firstFewImages']; // 这些选项变更时，需要重新添加结果。例如多图作品“只下载前几张” firstFewImages 会影响生成的结果，但是过滤器 filter 不会检查，所以需要单独检测它的变更\r\n        this.needReAdd = false; // 是否需要重新添加结果（并且会重新渲染）\r\n        this.showCount = () => {\r\n            let count;\r\n            if (this.resultMeta.length > 0) {\r\n                count = this.resultMeta.length.toString();\r\n            }\r\n            else {\r\n                // 当处于恢复模式时，resultMeta 里没有数据，所以直接使用 result 的数据\r\n                count = store.result.length.toString();\r\n            }\r\n            log.success(lang.transl('_调整完毕', count));\r\n            const countEl = document.querySelector(this.countSelector);\r\n            if (countEl) {\r\n                countEl.textContent = count;\r\n            }\r\n        };\r\n        // 在页面显示作品\r\n        this.addWork = (event) => {\r\n            if (!this.previewResult || !this.worksWrap) {\r\n                return;\r\n            }\r\n            const data = event.detail.data;\r\n            let r18Text = '';\r\n            if (data.tags.includes('R-18')) {\r\n                r18Text = 'R-18';\r\n            }\r\n            if (data.tags.includes('R-18G')) {\r\n                r18Text = 'R-18G';\r\n            }\r\n            let r18HTML = r18Text\r\n                ? `\n      <div class=\"r18Part\">\n        <div class=\"child\">\n          <div class=\"text\">${r18Text}</div>\n        </div>\n      </div>`\r\n                : '';\r\n            let multipleHTML = '';\r\n            if (data.pageCount > 1) {\r\n                multipleHTML = `\n        <div class=\"${this.multipleClass}\">\n          <div class=\"child\">\n            <span class=\"span1\">\n              <span class=\"span2\">\n              <svg viewBox=\"0 0 9 10\" size=\"9\" class=\"multipleSvg\">\n                <path d=\"M8,3 C8.55228475,3 9,3.44771525 9,4 L9,9 C9,9.55228475 8.55228475,10 8,10 L3,10\n                C2.44771525,10 2,9.55228475 2,9 L6,9 C7.1045695,9 8,8.1045695 8,7 L8,3 Z M1,1 L6,1\n                C6.55228475,1 7,1.44771525 7,2 L7,7 C7,7.55228475 6.55228475,8 6,8 L1,8 C0.44771525,8\n                0,7.55228475 0,7 L0,2 C0,1.44771525 0.44771525,1 1,1 Z\" transform=\"\"></path>\n                </svg>\n              </span>\n            </span>\n            <span>${data.pageCount}</span>\n          </div>  \n        </div>\n                    `;\r\n            }\r\n            let ugoiraHTML = '';\r\n            if (data.ugoiraInfo) {\r\n                ugoiraHTML = `\n        <svg viewBox=\"0 0 24 24\" class=\"${this.ugoiraClass}\" style=\"width: 48px; height: 48px;\">\n        <circle cx=\"12\" cy=\"12\" r=\"10\" class=\"ugoiraCircle\"></circle>\n          <path d=\"M9,8.74841664 L9,15.2515834 C9,15.8038681 9.44771525,16.2515834 10,16.2515834\n              C10.1782928,16.2515834 10.3533435,16.2039156 10.5070201,16.1135176 L16.0347118,12.8619342\n              C16.510745,12.5819147 16.6696454,11.969013 16.3896259,11.4929799\n              C16.3034179,11.3464262 16.1812655,11.2242738 16.0347118,11.1380658 L10.5070201,7.88648243\n              C10.030987,7.60646294 9.41808527,7.76536339 9.13806578,8.24139652\n              C9.04766776,8.39507316 9,8.57012386 9,8.74841664 Z\"></path>\n        </svg>`;\r\n            }\r\n            // 添加收藏的作品，让收藏图标变红\r\n            const bookmarkedFlag = data.bookmarked ? this.bookmarkedClass : '';\r\n            const html = `\n    <li class=\"${this.listClass}\" data-id=\"${data.idNum}\">\n    <div class=\"searchContent\">\n      <div class=\"searchImgArea\">\n        <div width=\"184\" height=\"184\" class=\"searchImgAreaContent\">\n          <a target=\"_blank\" class=\"imgAreaLink\" href=\"/artworks/${data.idNum}\">\n            <!--顶部横幅-->\n            <div class=\"topbar\">\n\n            <!--R-18 标记-->\n            ${r18HTML}\n\n            <!--多图作品标记-->\n            ${multipleHTML}\n              \n            </div>\n            <!--图片部分-->\n            <div class=\"imgWrap\">\n            <img src=\"${data.thumb}\" alt=\"${data.title}\" style=\"object-fit: cover; object-position: center center;\">\n              <!-- 动图 svg -->\n              ${ugoiraHTML}\n              </div>\n          </a>\n          <!--添加显示收藏数-->\n          <div class=\"bmkCount\">${data.bmk}</div>\n          <!--收藏按钮-->\n          <div class=\"bmkBtnWrap\">\n            <div class=\"\">\n            <button type=\"button\" class=\"${this.addBMKBtnClass}\">\n            <svg viewBox=\"0 0 1024 1024\" width=\"32\" height=\"32\" class=\"bmkBtnSvg ${bookmarkedFlag}\">\n            <path d=\"M958.733019 411.348626 659.258367 353.59527 511.998465 85.535095 364.741633 353.59527 65.265958 411.348626 273.72878 634.744555 235.88794 938.463881 511.998465 808.479435 788.091594 938.463881 750.250754 634.744555Z\" p-id=\"1106\" class=\"path2\"></path>\n            <path d=\"M959.008 406.016l-308-47.008L512 64 372.992 359.008l-308 47.008 223.008 228-52.992 324L512 805.024l276.992 152.992-52.992-324zM512 740L304 856.992l40-235.008-179.008-182.016 242.016-32 104.992-224 104 224 240.992 34.016L680 622.976l36.992 235.008z\" p-id=\"919\"></path>\n            </svg>\n            </button>\n            </div>\n          </div>\n        <!--收藏按钮结束-->\n        </div>\n      </div>\n      <!--标题名-->\n      <a target=\"_blank\" class=\"titleLink\" href=\"/artworks/${data.idNum}\">${data.title}</a>\n      <!--底部-->\n      <div class=\"bottomBar\">\n      <!--作者信息-->\n      <div class=\"userInfo\">\n      <!--相比原代码，这里去掉了作者头像的 html 代码。因为抓取到的数据里没有作者头像。-->\n          <a target=\"_blank\" href=\"/member.php?id=${data.userId}\">\n            <div class=\"userName\">${data.user}</div>\n          </a>\n        </div>\n      </div>\n    </div>\n  </li>\n    `;\r\n            // 添加作品\r\n            const li2 = document.createElement('li');\r\n            li2.innerHTML = html;\r\n            const li = li2.children[0];\r\n            this.worksWrap.appendChild(li);\r\n            // 绑定收藏按钮的事件\r\n            const addBMKBtn = li.querySelector(`.${this.addBMKBtnClass}`);\r\n            const bookmarkedClass = this.bookmarkedClass;\r\n            addBMKBtn.addEventListener('click', function () {\r\n                const e = new CustomEvent('addBMK', {\r\n                    detail: { data: { id: data.idNum, tags: data.tags } },\r\n                });\r\n                window.dispatchEvent(e);\r\n                this.classList.add(bookmarkedClass);\r\n            });\r\n        };\r\n        this.addBookmark = (event) => {\r\n            const data = event.detail.data;\r\n            // 如果设置了不启用快速收藏，则把 tag 设置为空\r\n            if (form.quickBookmarks.checked === false) {\r\n                data.tags = [];\r\n            }\r\n            API.addBookmark('illusts', data.id.toString(), data.tags, false, API.getToken());\r\n            this.resultMeta.forEach((result) => {\r\n                if (result.idNum === data.id) {\r\n                    result.bookmarked = true;\r\n                }\r\n            });\r\n        };\r\n        // “开始筛选”完成后，保存筛选结果的元数据，并重排结果\r\n        this.onCrawlFinish = () => {\r\n            if (this.crawlWorks) {\r\n                this.crawled = true;\r\n                this.resultMeta = [...store.resultMeta];\r\n                this.reAddResult();\r\n            }\r\n        };\r\n        // 清除多图作品\r\n        this.clearMultiple = () => {\r\n            this.filterResult((data) => {\r\n                return data.pageCount <= 1;\r\n            });\r\n        };\r\n        // 清除动图作品\r\n        this.clearUgoira = () => {\r\n            this.filterResult((data) => {\r\n                return !data.ugoiraInfo;\r\n            });\r\n        };\r\n        // 手动删除作品\r\n        this.deleteWork = (event) => {\r\n            const el = event.detail.data;\r\n            this.deleteId = parseInt(el.dataset.id);\r\n            this.filterResult((data) => {\r\n                return data.idNum !== this.deleteId;\r\n            });\r\n        };\r\n        this.onSettingChange = (event) => {\r\n            const data = event.detail.data;\r\n            if (data.name === 'previewResult') {\r\n                this.setPreviewResult(data.value);\r\n            }\r\n            if (this.optionsCauseResultChange.includes(data.name)) {\r\n                this.needReAdd = true;\r\n            }\r\n        };\r\n        this.init();\r\n        new FastScreen();\r\n    }\r\n    initElse() {\r\n        this.hotBar();\r\n        this.setPreviewResult(form.previewResult.checked);\r\n        window.addEventListener(EVT.events.addResult, this.addWork);\r\n        window.addEventListener('addBMK', this.addBookmark);\r\n        window.addEventListener(EVT.events.crawlFinish, this.onCrawlFinish);\r\n        window.addEventListener(EVT.events.crawlFinish, this.showCount);\r\n        window.addEventListener(EVT.events.clearMultiple, this.clearMultiple);\r\n        window.addEventListener(EVT.events.clearUgoira, this.clearUgoira);\r\n        window.addEventListener(EVT.events.deleteWork, this.deleteWork);\r\n        window.addEventListener(EVT.events.settingChange, this.onSettingChange);\r\n    }\r\n    // 去除热门作品上面的遮挡\r\n    hotBar() {\r\n        // 因为热门作品里的元素是延迟加载的，所以使用定时器检查\r\n        const timer = window.setInterval(() => {\r\n            const hotWorkAside = document.querySelector(this.hotWorkAsideSelector);\r\n            if (hotWorkAside) {\r\n                window.clearInterval(timer);\r\n                // 去掉遮挡作品的购买链接\r\n                const premiumLink = hotWorkAside.nextSibling;\r\n                premiumLink && premiumLink.remove();\r\n                // 去掉遮挡后两个作品的 after。因为是伪元素，所以要通过 css 控制\r\n                const style = `\n        section aside ul::after{\n          display:none !important;\n        }\n        `;\r\n                DOM.addStyle(style);\r\n            }\r\n        }, 500);\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.green, lang.transl('_开始筛选'), [\r\n            ['title', lang.transl('_开始筛选Title')],\r\n        ]).addEventListener('click', () => {\r\n            this.startScreen();\r\n        });\r\n        DOM.addBtn('crawlBtns', Colors.red, lang.transl('_在结果中筛选'), [\r\n            ['title', lang.transl('_在结果中筛选Title')],\r\n        ]).addEventListener('click', () => {\r\n            this.screenInResult();\r\n        });\r\n        // 添加收藏本页所有作品的功能\r\n        const bookmarkAll = new BookmarkAllWorks();\r\n        bookmarkAll.btn.addEventListener('click', () => {\r\n            const listWrap = this.getWorksWrap();\r\n            if (listWrap) {\r\n                const list = listWrap.querySelectorAll('li');\r\n                bookmarkAll.setWorkList(list);\r\n            }\r\n        });\r\n    }\r\n    appendElseEl() {\r\n        const deleteWorks = new DeleteWorks(`.${this.listClass}`);\r\n        deleteWorks.addClearMultipleBtn(`.${this.multipleClass}`, () => {\r\n            EVT.fire(EVT.events.clearMultiple);\r\n        });\r\n        deleteWorks.addClearUgoiraBtn(`.${this.ugoiraClass}`, () => {\r\n            EVT.fire(EVT.events.clearUgoira);\r\n        });\r\n        deleteWorks.addManuallyDeleteBtn((el) => {\r\n            EVT.fire(EVT.events.deleteWork, el);\r\n        });\r\n    }\r\n    setFormOption() {\r\n        this.maxCount = 1000;\r\n        // 设置“个数/页数”选项\r\n        options.setWantPage({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n            value: this.maxCount.toString(),\r\n        });\r\n    }\r\n    destroy() {\r\n        DOM.clearSlot('crawlBtns');\r\n        DOM.clearSlot('otherBtns');\r\n        window.removeEventListener(EVT.events.addResult, this.addWork);\r\n        window.removeEventListener(EVT.events.crawlFinish, this.onCrawlFinish);\r\n        window.removeEventListener(EVT.events.crawlFinish, this.showCount);\r\n        // 离开下载页面时，取消设置“不自动下载”\r\n        store.states.notAutoDownload = false;\r\n    }\r\n    startScreen() {\r\n        if (!store.states.allowWork) {\r\n            return alert(lang.transl('_当前任务尚未完成'));\r\n        }\r\n        this.crawlWorks = true;\r\n        this.readyCrawl();\r\n    }\r\n    async nextStep() {\r\n        this.initFetchURL();\r\n        this.needCrawlPageCount = await this.calcNeedCrawlPageCount();\r\n        if (this.needCrawlPageCount === 0) {\r\n            return this.noResult();\r\n        }\r\n        this.startGetIdList();\r\n        this.clearWorks();\r\n    }\r\n    // 返回包含作品列表的 ul 元素\r\n    getWorksWrap() {\r\n        const test = document.querySelectorAll(this.worksWrapSelector);\r\n        if (test.length > 0) {\r\n            if (test.length > 2) {\r\n                // 大于 2 的情况是在搜索页的首页，或者小说页面\r\n                return test[2];\r\n            }\r\n            // 在插画、漫画、artworks 页面只有两个 ul 或者一个\r\n            return test[test.length - 1];\r\n        }\r\n        return null;\r\n    }\r\n    clearWorks() {\r\n        this.worksWrap = this.getWorksWrap();\r\n        if (!this.previewResult || !this.worksWrap) {\r\n            return;\r\n        }\r\n        this.worksWrap.innerHTML = '';\r\n    }\r\n    // 传入函数，过滤符合条件的结果\r\n    async filterResult(callback) {\r\n        var e_1, _a;\r\n        if (!this.crawled) {\r\n            return alert(lang.transl('_尚未开始筛选'));\r\n        }\r\n        if (this.resultMeta.length === 0) {\r\n            return alert(lang.transl('_没有数据可供使用'));\r\n        }\r\n        centerPanel.close();\r\n        log.clear();\r\n        const nowLength = this.resultMeta.length; // 储存过滤前的结果数量\r\n        const resultMetaTemp = [];\r\n        try {\r\n            for (var _b = __asyncValues(this.resultMeta), _c; _c = await _b.next(), !_c.done;) {\r\n                const meta = _c.value;\r\n                if (await callback(meta)) {\r\n                    resultMetaTemp.push(meta);\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        this.resultMeta = resultMetaTemp;\r\n        // 如果过滤后，作品元数据发生了改变，或者强制要求重新生成结果，才会重排作品。以免浪费资源。\r\n        if (this.resultMeta.length !== nowLength || this.needReAdd) {\r\n            this.reAddResult();\r\n        }\r\n        this.needReAdd = false;\r\n        this.crawlWorks = false;\r\n        // 发布 crawlFinish 事件，会在日志上显示下载数量。\r\n        EVT.fire(EVT.events.crawlFinish);\r\n    }\r\n    // 当筛选结果的元数据改变时，重新生成抓取结果\r\n    reAddResult() {\r\n        store.resetResult();\r\n        this.clearWorks();\r\n        this.resultMeta.forEach((data) => {\r\n            const dlCount = setting.getDLCount(data.pageCount);\r\n            // 如果此时的 dlCount 与之前的 dlCount 不一样，则更新它\r\n            if (dlCount !== data.dlCount) {\r\n                data = Object.assign(data, { dlCount: dlCount });\r\n            }\r\n            store.addResult(data);\r\n        });\r\n        EVT.fire(EVT.events.worksUpdate);\r\n        titleBar.change('→');\r\n    }\r\n    // 在当前结果中再次筛选，会修改第一次筛选的结果\r\n    screenInResult() {\r\n        if (!store.states.allowWork) {\r\n            return alert(lang.transl('_当前任务尚未完成'));\r\n        }\r\n        log.clear();\r\n        filter.init();\r\n        this.getMultipleSetting();\r\n        this.filterResult((data) => {\r\n            const filterOpt = {\r\n                id: data.id,\r\n                illustType: data.type,\r\n                pageCount: data.pageCount,\r\n                tags: data.tags,\r\n                bookmarkCount: data.bmk,\r\n                bookmarkData: data.bookmarked,\r\n                width: data.fullWidth,\r\n                height: data.fullHeight,\r\n                createDate: data.date,\r\n            };\r\n            return filter.check(filterOpt);\r\n        });\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x页'), lang.transl('_下载所有页面'));\r\n        if (this.crawlNumber === -1 || this.crawlNumber > this.maxCount) {\r\n            this.crawlNumber = this.maxCount;\r\n        }\r\n    }\r\n    // 获取搜索页的数据。因为有多处使用，所以进行了封装\r\n    async getSearchData(p) {\r\n        let data = await API.getSearchData(pageInfo.getPageTag, this.worksType, p, this.option);\r\n        return data.body.illust || data.body.illustManga || data.body.manga;\r\n    }\r\n    // 组织要请求的 url 中的参数\r\n    initFetchURL() {\r\n        // 从 URL 中获取分类。可能有语言标识。\r\n        /*\r\n        https://www.pixiv.net/tags/Fate%2FGrandOrder/illustrations\r\n        https://www.pixiv.net/en/tags/Fate%2FGrandOrder/illustrations\r\n        */\r\n        let URLType = location.pathname.split('tags/')[1].split('/')[1];\r\n        // 但在“顶部”页面的时候是没有分类的，会是 undefined\r\n        if (URLType === undefined) {\r\n            URLType = '';\r\n        }\r\n        switch (URLType) {\r\n            case '':\r\n                this.worksType = 'artworks';\r\n                break;\r\n            case 'illustrations':\r\n            case 'illust_and_ugoira':\r\n            case 'ugoira':\r\n            case 'illust':\r\n                this.worksType = 'illustrations';\r\n                break;\r\n            case 'manga':\r\n                this.worksType = 'manga';\r\n                break;\r\n            default:\r\n                this.worksType = 'artworks';\r\n                break;\r\n        }\r\n        let p = API.getURLSearchField(location.href, 'p');\r\n        this.startpageNo = parseInt(p) || 1;\r\n        // 从页面 url 中获取可以使用的选项\r\n        this.option = {};\r\n        this.allOption.forEach((param) => {\r\n            let value = API.getURLSearchField(location.href, param);\r\n            if (value !== '') {\r\n                this.option[param] = value;\r\n            }\r\n        });\r\n    }\r\n    // 计算应该抓取多少页\r\n    async calcNeedCrawlPageCount() {\r\n        let data = await this.getSearchData(1);\r\n        // 计算总页数\r\n        let pageCount = Math.ceil(data.total / this.worksNoPerPage);\r\n        if (pageCount > this.maxCount) {\r\n            // 最大为 1000\r\n            pageCount = this.maxCount;\r\n        }\r\n        // 计算从本页开始抓取的话，有多少页\r\n        let needFetchPage = pageCount - this.startpageNo + 1;\r\n        // 比较用户设置的页数，取较小的那个数值\r\n        if (needFetchPage < this.crawlNumber) {\r\n            return needFetchPage;\r\n        }\r\n        else {\r\n            return this.crawlNumber;\r\n        }\r\n    }\r\n    // 计算页数之后，准备建立并发抓取线程\r\n    startGetIdList() {\r\n        if (this.needCrawlPageCount <= this.ajaxThreadsDefault) {\r\n            this.ajaxThreads = this.needCrawlPageCount;\r\n        }\r\n        else {\r\n            this.ajaxThreads = this.ajaxThreadsDefault;\r\n        }\r\n        for (let i = 0; i < this.ajaxThreads; i++) {\r\n            this.getIdList();\r\n        }\r\n    }\r\n    async getIdList() {\r\n        let p = this.startpageNo + this.sendCrawlTaskCount;\r\n        this.sendCrawlTaskCount++;\r\n        // 发起请求，获取列表页\r\n        let data;\r\n        try {\r\n            data = await this.getSearchData(p);\r\n        }\r\n        catch (_a) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        data = data.data;\r\n        for (const nowData of data) {\r\n            // 排除广告信息\r\n            if (nowData.isAdContainer) {\r\n                continue;\r\n            }\r\n            const filterOpt = {\r\n                id: nowData.illustId,\r\n                width: nowData.width,\r\n                height: nowData.height,\r\n                pageCount: nowData.pageCount,\r\n                bookmarkData: nowData.bookmarkData,\r\n                illustType: nowData.illustType,\r\n                tags: nowData.tags,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: API.getWorkType(nowData.illustType),\r\n                    id: nowData.illustId,\r\n                });\r\n            }\r\n        }\r\n        this.listPageFinished++;\r\n        log.log(lang.transl('_列表页抓取进度', this.listPageFinished.toString()), 1, false);\r\n        if (this.sendCrawlTaskCount + 1 <= this.needCrawlPageCount) {\r\n            // 继续发送抓取任务（+1 是因为 sendCrawlTaskCount 从 0 开始）\r\n            this.getIdList();\r\n        }\r\n        else {\r\n            // 抓取任务已经全部发送\r\n            if (this.listPageFinished === this.needCrawlPageCount) {\r\n                // 抓取任务全部完成\r\n                log.log(lang.transl('_列表页抓取完成'));\r\n                this.getIdListFinished();\r\n            }\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listPageFinished = 0;\r\n        this.sendCrawlTaskCount = 0;\r\n    }\r\n    // 搜索页把下载任务按收藏数从高到低下载\r\n    sortResult() {\r\n        store.resultMeta.sort(API.sortByProperty('bmk'));\r\n        store.result.sort(API.sortByProperty('bmk'));\r\n    }\r\n    setPreviewResult(value) {\r\n        this.previewResult = value;\r\n        // 如果设置了“预览搜索结果”，则“不自动下载”。否则允许自动下载\r\n        store.states.notAutoDownload = value ? true : false;\r\n    }\r\n}\r\nexport { InitSearchArtworkPage };\r\n","// 初始化插画/漫画的系列作品页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { API } from '../API';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../Options';\r\nimport { filter } from '../Filter';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nclass InitSeriesPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.baseUrl = '';\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        this.maxCount = 100;\r\n        options.setWantPage({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n            value: this.maxCount.toString(),\r\n        });\r\n    }\r\n    getWantPage() {\r\n        const check = this.checkWantPageInputGreater0();\r\n        if (check == undefined) {\r\n            return;\r\n        }\r\n        this.crawlNumber = check;\r\n        if (this.crawlNumber > this.maxCount) {\r\n            this.crawlNumber = this.maxCount;\r\n        }\r\n        log.warning(lang.transl('_任务开始1', this.crawlNumber.toString()));\r\n    }\r\n    getPageUrl() {\r\n        // 设置起始页面\r\n        const p = API.getURLSearchField(location.href, 'p');\r\n        this.startpageNo = parseInt(p) || 1;\r\n        const url = new URL(window.location.href);\r\n        url.searchParams.set('p', '1');\r\n        this.baseUrl = url.toString();\r\n        // https://www.pixiv.net/user/3698796/series/61267?p=1\r\n    }\r\n    nextStep() {\r\n        this.getPageUrl();\r\n        this.getIdList();\r\n    }\r\n    async getIdList() {\r\n        let p = this.startpageNo + this.listPageFinished;\r\n        let dom;\r\n        try {\r\n            const res = await fetch(this.baseUrl.replace('p=1', 'p=' + p));\r\n            const text = await res.text();\r\n            const parse = new DOMParser();\r\n            dom = parse.parseFromString(text, 'text/html');\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        this.listPageFinished++;\r\n        if (dom.querySelector('.no-content')) {\r\n            // 此页没有内容，也就没有后续内容了\r\n            return this.getIdListFinished();\r\n        }\r\n        const workList = dom.querySelectorAll('.works .image-item');\r\n        // 检查每个作品的信息\r\n        for (const item of workList) {\r\n            // https://www.pixiv.net/user/3698796/series/61267\r\n            const link = item.querySelector('a').href;\r\n            const id = parseInt(link.split('/artworks/')[1]);\r\n            const tagString = item.querySelector('img').dataset.tags;\r\n            const tags = tagString ? tagString.split(' ') : [];\r\n            const bookmarkBtn = item.querySelector('._one-click-bookmark');\r\n            const bookmarked = bookmarkBtn\r\n                ? bookmarkBtn.classList.contains('on')\r\n                : false;\r\n            const filterOpt = {\r\n                id: id,\r\n                tags: tags,\r\n                bookmarkData: bookmarked,\r\n            };\r\n            // 其实 type 这里有个存疑的地方。如果插画没有系列页面，只有漫画有系列页面，那么这里可以直接断言 type 为 manga。但是这一点尚不能完全确定，所以这里 type 是 unknown\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: 'unknown',\r\n                    id: id.toString(),\r\n                });\r\n            }\r\n        }\r\n        log.log(lang.transl('_列表页抓取进度', this.listPageFinished.toString()), 1, false);\r\n        // 抓取完毕\r\n        if (p >= this.maxCount || this.listPageFinished === this.crawlNumber) {\r\n            log.log(lang.transl('_列表页抓取完成'));\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 继续抓取\r\n            this.getIdList();\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listPageFinished = 0;\r\n    }\r\n}\r\nexport { InitSeriesPage };\r\n","import { API } from '../API';\r\nimport { filter } from '../Filter';\r\nimport { setting, form } from '../Settings';\r\nimport { store } from '../Store';\r\n// 保存单个图片作品的数据\r\nclass SaveArtworkData {\r\n    async save(data) {\r\n        // 获取需要检查的信息\r\n        const body = data.body;\r\n        const fullWidth = body.width; // 原图宽度\r\n        const fullHeight = body.height; // 原图高度\r\n        const bmk = body.bookmarkCount; // 收藏数\r\n        const tagArr = body.tags.tags; // 取出 tag 信息\r\n        const tags = []; // 保存 tag 列表\r\n        const tagTranslation = []; // 保存 tag 列表，附带翻译后的 tag\r\n        for (const tagData of tagArr) {\r\n            tags.push(tagData.tag);\r\n            tagTranslation.push(tagData.tag);\r\n            if (tagData.translation && tagData.translation.en) {\r\n                tagTranslation.push(tagData.translation.en);\r\n            }\r\n        }\r\n        const filterOpt = {\r\n            createDate: body.createDate,\r\n            id: body.illustId,\r\n            illustType: body.illustType,\r\n            tags: tags,\r\n            pageCount: body.pageCount,\r\n            bookmarkCount: bmk,\r\n            bookmarkData: body.bookmarkData,\r\n            width: fullWidth,\r\n            height: fullHeight,\r\n            mini: body.urls.mini,\r\n        };\r\n        // 检查通过\r\n        if (await filter.check(filterOpt)) {\r\n            const illustId = body.illustId;\r\n            const idNum = parseInt(body.illustId);\r\n            const title = body.illustTitle; // 作品标题\r\n            const userid = body.userId; // 用户id\r\n            const user = body.userName; // 用户名\r\n            const thumb = body.urls.thumb;\r\n            const pageCount = body.pageCount;\r\n            const bookmarked = !!body.bookmarkData;\r\n            // 时间原数据如 \"2019-12-18T22:23:37+00:00\"\r\n            // 网页上显示的日期是转换成了本地时间的，如北京时区显示为 \"2019-12-19\"，不是显示原始日期 \"2019-12-18\"。所以这里转换成本地时区的日期，和网页上保持一致，以免用户困惑。\r\n            const date0 = new Date(body.createDate);\r\n            const y = date0.getFullYear();\r\n            const m = (date0.getMonth() + 1).toString().padStart(2, '0');\r\n            const d = date0.getDate().toString().padStart(2, '0');\r\n            const date = `${y}-${m}-${d}`;\r\n            let rank = ''; // 保存作品在排行榜上的编号\r\n            let testRank = store.getRankList(body.illustId);\r\n            if (testRank !== undefined) {\r\n                rank = '#' + testRank;\r\n            }\r\n            let seriesTitle = body.seriesNavData ? body.seriesNavData.title : '';\r\n            let seriesOrder = body.seriesNavData ? '#' + body.seriesNavData.order : '';\r\n            // 储存作品信息\r\n            if (body.illustType !== 2) {\r\n                // 插画或漫画\r\n                // 下载该作品的前面几张\r\n                const dlCount = setting.getDLCount(body.pageCount);\r\n                const imgUrl = body.urls.original; // 作品的原图 URL\r\n                const tempExt = imgUrl.split('.');\r\n                const ext = tempExt[tempExt.length - 1];\r\n                // 添加作品信息\r\n                store.addResult({\r\n                    id: illustId,\r\n                    idNum: idNum,\r\n                    thumb: thumb,\r\n                    pageCount: pageCount,\r\n                    dlCount: dlCount,\r\n                    url: imgUrl,\r\n                    title: title,\r\n                    tags: tags,\r\n                    tagsTranslated: tagTranslation,\r\n                    user: user,\r\n                    userId: userid,\r\n                    fullWidth: fullWidth,\r\n                    fullHeight: fullHeight,\r\n                    ext: ext,\r\n                    bmk: bmk,\r\n                    bookmarked: bookmarked,\r\n                    date: date,\r\n                    type: body.illustType,\r\n                    rank: rank,\r\n                    seriesTitle: seriesTitle,\r\n                    seriesOrder: seriesOrder,\r\n                });\r\n            }\r\n            else if (body.illustType === 2) {\r\n                // 动图\r\n                // 获取动图的信息\r\n                const meta = await API.getUgoiraMeta(illustId);\r\n                // 动图帧延迟数据\r\n                const ugoiraInfo = {\r\n                    frames: meta.body.frames,\r\n                    mime_type: meta.body.mime_type,\r\n                };\r\n                const ext = form.ugoiraSaveAs.value; // 扩展名可能是 webm、gif、zip\r\n                store.addResult({\r\n                    id: illustId,\r\n                    idNum: idNum,\r\n                    thumb: thumb,\r\n                    pageCount: pageCount,\r\n                    url: meta.body.originalSrc,\r\n                    title: title,\r\n                    tags: tags,\r\n                    tagsTranslated: tagTranslation,\r\n                    user: user,\r\n                    userId: userid,\r\n                    fullWidth: fullWidth,\r\n                    fullHeight: fullHeight,\r\n                    ext: ext,\r\n                    bmk: bmk,\r\n                    bookmarked: bookmarked,\r\n                    date: date,\r\n                    type: body.illustType,\r\n                    rank: rank,\r\n                    ugoiraInfo: ugoiraInfo,\r\n                    seriesTitle: seriesTitle,\r\n                    seriesOrder: seriesOrder,\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\nconst saveArtworkData = new SaveArtworkData();\r\nexport { saveArtworkData };\r\n","const langText = {\r\n    _只下载已收藏: [\r\n        '只下载已收藏',\r\n        'ブックマークのみをダウンロードする',\r\n        'Download only bookmarked works',\r\n        '只下載已收藏',\r\n    ],\r\n    _只下载已收藏的提示: [\r\n        '只下载已经收藏的作品',\r\n        'ブックマークした作品のみをダウンロードする',\r\n        'Download only bookmarked works',\r\n        '只下載已經收藏的作品。',\r\n    ],\r\n    _下载作品类型: [\r\n        '下载作品类型',\r\n        'ダウンロード作品の種類',\r\n        'Download work type',\r\n        '下載作品類型',\r\n    ],\r\n    _下载作品类型的提示: [\r\n        '下载哪些类型的作品',\r\n        'どの種類の作品をダウンロードしますか',\r\n        'Which types of works to download',\r\n        '下載哪些類型的作品。',\r\n    ],\r\n    _多p下载前几张: [\r\n        '设置作品张数',\r\n        '作品ごとにダウンロード画像の数',\r\n        'Number of images downloaded per work',\r\n        '設定作品張數',\r\n    ],\r\n    _多p下载前几张提示: [\r\n        '下载每个作品的前几张图片。默认值 0 表示全部下载。',\r\n        '各作品の画像が最初の何枚をダウンロードしますか？ デフォルト値の 0 は、すべてをダウンロードします。',\r\n        'Download the first few images of each piece. The default value of 0 means all downloads.',\r\n        '下載每個作品的前幾張圖片。預設值 0 表示全部下載。',\r\n    ],\r\n    _不能含有tag: [\r\n        '不能含有 tag&nbsp;',\r\n        '指定した tag を除外する',\r\n        'Exclude specified tag',\r\n        '不能含有 tag&nbsp;',\r\n    ],\r\n    _排除tag的提示文字: [\r\n        '您可在下载前设置要排除的tag，这样在下载时将不会下载含有这些tag的作品。不区分大小写；如需排除多个tag，请使用英文逗号分隔。请注意要排除的tag的优先级大于要包含的tag的优先级。',\r\n        'ダウンロード前に、除外する tag を設定できます。大文字と小文字を区別しない；複数の tag を設定する必要がある場合は、「,」で区切ってください。除外された tag は、必要な tag よりも優先されます',\r\n        'Before downloading, you can set the tag you want to exclude. Not case sensitive; If you need to set multiple tags, you can use comma (,) separated. The excluded tag takes precedence over the included tag',\r\n        '可在下載前設定要排除的 tag，下載時將排除含有這些 tag 的作品，不區分大小寫；如需排除多個 tag，請使用半形逗號（,）分隔。請注意，要排除的 tag 優先於要包含的 tag。',\r\n    ],\r\n    _设置了排除tag之后的提示: [\r\n        '排除 tag：',\r\n        '以下の tag を除外：',\r\n        'Excludes tag: ',\r\n        '排除 tag：',\r\n    ],\r\n    _必须含有tag: [\r\n        '必须含有 tag&nbsp;',\r\n        '必要な tag&nbsp;',\r\n        'Must contain tag',\r\n        '必須含有 tag&nbsp;',\r\n    ],\r\n    _必须tag的提示文字: [\r\n        '您可在下载前设置作品里必须包含的tag，不区分大小写；如需包含多个tag，请使用英文逗号分隔。',\r\n        'ダウンロードする前に、必要な tag を設定することができます。大文字と小文字を区別しない；複数の tag を設定する必要がある場合は、「,」で区切ってください。',\r\n        'Before downloading, you can set the tag that must be included. Not case sensitive; If you need to set multiple tags, you can use comma (,) separated. ',\r\n        '可在下載前設定作品裡必須包含的 tag，不區分大小寫；如需包含多個 tag，請使用半形逗號（,）分隔。',\r\n    ],\r\n    _设置了必须tag之后的提示: [\r\n        '包含 tag：',\r\n        '以下の tag を含める：',\r\n        'Include tag: ',\r\n        '包含 tag：',\r\n    ],\r\n    _筛选宽高的按钮文字: [\r\n        '设置宽高条件',\r\n        '幅と高さの条件を設定する',\r\n        'Set the width and height',\r\n        '設定寬高條件',\r\n    ],\r\n    _筛选宽高的按钮Title: [\r\n        '在下载前，您可以设置要下载的图片的宽高条件。',\r\n        'ダウンロードする前に、画像の幅と高さの条件を設定できます。',\r\n        'Before downloading, you can set the width and height conditions of the images you want to download.',\r\n        '在下載前可以設定要下載的圖片的寬高條件。',\r\n    ],\r\n    _设置宽高比例: [\r\n        '设置宽高比例',\r\n        '縦横比を設定する',\r\n        'Set the aspect ratio',\r\n        '設定寬高比例',\r\n    ],\r\n    _设置宽高比例Title: [\r\n        '设置宽高比例，也可以手动输入宽高比',\r\n        '縦横比を設定する、手動で縦横比を入力することもできる',\r\n        'Set the aspect ratio, or manually type the aspect ratio',\r\n        '設定寬高比，也可以手動輸入寬高比。',\r\n    ],\r\n    _不限制: ['不限制', '無制限', 'not limited', '不限制'],\r\n    _横图: ['横图', '横長', 'Horizontal', '橫圖'],\r\n    _竖图: ['竖图', '縦長', 'Vertical', '豎圖'],\r\n    _输入宽高比: ['宽高比 >=', '縦横比 >=', 'Aspect ratio >=', '寬高比 >='],\r\n    _设置了宽高比之后的提示: [\r\n        '宽高比：{}',\r\n        '縦横比：{}',\r\n        'Aspect ratio: {}',\r\n        '寬高比：{}',\r\n    ],\r\n    _宽高比必须是数字: [\r\n        '宽高比必须是数字',\r\n        '縦横比は数値でなければなりません',\r\n        'The aspect ratio must be a number',\r\n        '寬高比必須是數字',\r\n    ],\r\n    _筛选宽高的提示文字: [\r\n        '请输入最小宽度和最小高度，不会下载不符合要求的图片。',\r\n        '最小幅と最小高さを入力してください。要件を満たしていない画像はダウンロードされません。',\r\n        'Please type the minimum width and minimum height. Will not download images that do not meet the requirements',\r\n        '請輸入最小寬度和最小高度，只會下載符合要求的圖片。',\r\n    ],\r\n    _本次输入的数值无效: [\r\n        '本次输入的数值无效',\r\n        '無効な入力',\r\n        'Invalid input',\r\n        '本次輸入的數值無效',\r\n    ],\r\n    _设置了筛选宽高之后的提示文字p1: [\r\n        '宽度 >= ',\r\n        '幅 >= ',\r\n        'Width >= ',\r\n        '寬度 >= ',\r\n    ],\r\n    _或者: [' 或者 ', ' または ', ' or ', ' 或是 '],\r\n    _并且: [' 并且 ', ' そして ', ' and ', ' 並且 '],\r\n    _高度设置: ['高度 >= ', '高さ >= ', 'height >= ', '高度 >= '],\r\n    _个数: [\r\n        '设置作品数量',\r\n        '作品数を設定する',\r\n        'Set the number of works',\r\n        '設定作品數量',\r\n    ],\r\n    _页数: [\r\n        '设置页面数量',\r\n        'ページ数を設定する',\r\n        'Set the number of pages',\r\n        '設定頁面數量',\r\n    ],\r\n    _筛选收藏数的按钮文字: [\r\n        '设置收藏数量',\r\n        'ブックマークされた数を設定する',\r\n        'Set the bookmarkCount conditions',\r\n        '設定收藏數量',\r\n    ],\r\n    _筛选收藏数的按钮Title: [\r\n        '在下载前，您可以设置对收藏数量的要求。',\r\n        'ダウンロードする前に、ブックマークされた数の条件を設定することができます。',\r\n        'Before downloading, You can set the requirements for the number of bookmarks.',\r\n        '下載前可以設定對收藏數量的要求。',\r\n    ],\r\n    _设置收藏数量: [\r\n        '设置收藏数量',\r\n        'ブックマークされた数を設定する',\r\n        'Set the number of bookmarks',\r\n        '設定收藏數量',\r\n    ],\r\n    _设置收藏数量的提示: [\r\n        '如果作品的收藏数小于设置的数字，作品不会被下载。',\r\n        '作品のブックマークされた数が設定された数字よりも少ない場合、作品はダウンロードされません。',\r\n        'If the number of bookmarks of the work is less than the set number, the work will not be downloaded.',\r\n        '只會下載設定收藏數範圍內的作品。',\r\n    ],\r\n    _筛选收藏数的提示文字: [\r\n        '请输入一个数字，如果作品的收藏数小于这个数字，作品不会被下载。',\r\n        '数字を入力してください。 作品のブックマークされた数がこの数字より少ない場合、作品はダウンロードされません。',\r\n        'Please type a number. If the number of bookmarks of the work is less than this number, the work will not be downloaded.',\r\n        '請輸入數字，只會下載設定收藏數範圍內的作品。',\r\n    ],\r\n    _收藏数大于: [\r\n        '收藏数 >= ',\r\n        'ブックマークの数 >= ',\r\n        'Number of bookmarks >= ',\r\n        '收藏數 >= ',\r\n    ],\r\n    _收藏数小于: [\r\n        '收藏数 <= ',\r\n        'ブックマークの数 <= ',\r\n        'Number of bookmarks <= ',\r\n        '收藏數 <= ',\r\n    ],\r\n    _本次任务已全部完成: [\r\n        '本次任务已全部完成。',\r\n        'このタスクは完了しました。',\r\n        'This task has been completed.',\r\n        '本次工作已全部完成',\r\n    ],\r\n    _本次任务条件: [\r\n        '本次任务条件: ',\r\n        'このタスクの条件：',\r\n        'This task condition: ',\r\n        '本次工作條件：',\r\n    ],\r\n    _参数不合法: [\r\n        '参数不合法，本次操作已取消。',\r\n        'パラメータは有効ではありません。この操作はキャンセルされました。',\r\n        'Parameter is not legal, this operation has been canceled.',\r\n        '參數不合法，本次動作已取消。',\r\n    ],\r\n    _从本页开始下载x个作品: [\r\n        '从本页开始下载-num-个作品',\r\n        'このページから -num- 枚の作品をダウンロード。',\r\n        'Download -num- works from this page.',\r\n        '從本頁開始下載-num-個作品',\r\n    ],\r\n    _向下获取所有作品: [\r\n        '向下获取所有作品',\r\n        'このページからすべての作品をダウンロードする。',\r\n        'download all the work from this page.',\r\n        '向下取得所有作品',\r\n    ],\r\n    _从本页开始下载提示: [\r\n        '从本页开始下载<br>如果要限制下载的页数，请输入从1开始的数字，1为仅下载本页。',\r\n        'このページからダウンロードする<br>ダウンロードするページを設定する場合は、1から始まる数字を入力してください。 1は現在のページのみをダウンロードする。',\r\n        'Download from this page<br>If you want to set the number of pages to download, type a number starting at 1. This page is 1.',\r\n        '從本頁開始下載。<br>如果要限制下載的頁數，請輸入從 1 開始的數字，1 為僅下載本頁。',\r\n    ],\r\n    _从本页开始下载x页: [\r\n        '从本页开始下载-num-页',\r\n        '現在のページから -num- ページをウンロードします',\r\n        'download -num- pages from the current page',\r\n        '從本頁開始下載-num-頁',\r\n    ],\r\n    _下载所有页面: [\r\n        '下载所有页面',\r\n        'すべてのページをダウンロードする',\r\n        'download all pages',\r\n        '下載所有頁面',\r\n    ],\r\n    _下载x个相关作品: [\r\n        '下载 -num- 个相关作品',\r\n        '関連作品 -num- 枚をダウンロードする。',\r\n        'download -num- related works.',\r\n        '下載 -num- 個相關作品',\r\n    ],\r\n    _下载所有相关作品: [\r\n        '下载所有相关作品',\r\n        '関連作品をすべてダウンロードする。',\r\n        'download all related works.',\r\n        '下載所有相關作品',\r\n    ],\r\n    _下载推荐作品: [\r\n        '下载推荐作品',\r\n        'お勧め作品をダウンロードする',\r\n        'download recommend works',\r\n        '下載推薦作品',\r\n    ],\r\n    _下载排行榜前x个作品: [\r\n        '下载排行榜前 -num- 个作品',\r\n        'ランク前 -num- 位の作品をダウンロードする。',\r\n        'download the top -num- works in the ranking list',\r\n        '下載排行榜前 -num- 個作品',\r\n    ],\r\n    _输入超过了最大值: [\r\n        '您输入的数字超过了最大值',\r\n        '入力した番号が最大値を超えています',\r\n        'The number you entered exceeds the maximum',\r\n        '輸入的數字超出最大值',\r\n    ],\r\n    _任务开始1: [\r\n        '从本页开始下载{}页',\r\n        'このページから {} ページをダウンロードする',\r\n        'download {} pages from this page',\r\n        '從本頁開始下載 {} 頁',\r\n    ],\r\n    _任务开始0: ['任务开始', 'タスクが開始されます', 'Task starts', '工作開始'],\r\n    _checkNotdownTypeAll: [\r\n        '由于您排除了所有作品类型，本次任务已取消。',\r\n        'すべての種類の作品を除外したため、タスクはキャンセルされました。',\r\n        'Because you excluded all types of work, the task was canceled.',\r\n        '由於排除了所有作品類型，本次工作已取消。',\r\n    ],\r\n    _checkNotdownTypeResult: [\r\n        '排除作品类型：',\r\n        'これらのタイプの作品を除外します：',\r\n        'Excludes these types of works: ',\r\n        '排除作品類型：',\r\n    ],\r\n    _多图作品: [\r\n        '多图作品',\r\n        'マルチイメージ作品',\r\n        'Multi-image works',\r\n        '多圖作品',\r\n    ],\r\n    _多图下载设置: [\r\n        '多图下载设置',\r\n        'マルチイメージ設定',\r\n        'Download multi-image works',\r\n        '多圖下載設定',\r\n    ],\r\n    _怎样下载多图作品: [\r\n        '怎样下载多图作品？',\r\n        'どのようにマルチイメージ作品をダウンロードしますか？',\r\n        'How to download multi-image works?',\r\n        '如何下載多圖作品？',\r\n    ],\r\n    _多图建立目录: [\r\n        '多图建立目录',\r\n        'マルチイメージにフォルダを作成',\r\n        'Create directory for multi-image works',\r\n        '多圖建立目錄',\r\n    ],\r\n    _多图建立目录提示: [\r\n        '当你下载多图作品时，下载器可以自动创建一个目录，保存里面的图片。',\r\n        'マルチイメージをダウンロードする時、自動的にフォルダを作成し、イメージをその中で保存することができます。',\r\n        'When you download a multi-image work, the downloader can automatically create a directory and save the images inside.',\r\n        '當下載多圖作品時，下載器可以自動建立一個目錄，儲存裡面的圖片。',\r\n    ],\r\n    _不下载: ['不下载', '必要なし', 'No', '不下載'],\r\n    _全部下载: ['全部下载', '全部ダウンロード', 'Yes', '全部下載'],\r\n    _下载前几张图片: [\r\n        '下载前几张图片：',\r\n        '最初のいくつかの画像：',\r\n        'First few images:',\r\n        '下載前幾張圖片：',\r\n    ],\r\n    _不下载多图作品: [\r\n        '不下载多图作品',\r\n        'マルチイメージ作品をダウンロードしない',\r\n        'Do not download multi-image works',\r\n        '不下載多圖作品',\r\n    ],\r\n    _多图作品下载前n张图片: [\r\n        '多图作品下载前 {} 张图片',\r\n        'マルチイメージ作品は、最初の {} イメージをダウンロードします',\r\n        'Multi-image works download the first {} images',\r\n        '多圖作品下載前 {} 張圖片',\r\n    ],\r\n    _插画: ['插画 ', 'イラスト', 'Illustrations', '插畫 '],\r\n    _漫画: ['漫画 ', '漫画', 'Manga', '漫畫 '],\r\n    _动图: ['动图 ', 'うごイラ', 'Ugoira', '動圖 '],\r\n    _动图保存格式: [\r\n        '动图保存格式',\r\n        'うごイラをどのタイプが保存するか',\r\n        'Save the ugoira work as',\r\n        '動圖儲存格式',\r\n    ],\r\n    _动图保存格式title: [\r\n        '下载动图时，可以把它转换成视频文件',\r\n        'うごイラをダウンロードするとき、動画に変換することができます。',\r\n        'When you download a ugoira work, you can convert it to a video file.',\r\n        '下載動圖時，可以將它轉換為影片檔案。',\r\n    ],\r\n    _webmVideo: ['WebM 视频', 'WebM ビデオ', 'WebM video', '影片（WebM）'],\r\n    _gif: ['GIF 图片', 'GIF 画像', 'GIF picture', '圖片（GIF）'],\r\n    _zipFile: ['Zip 文件', 'ZIP ファイル', 'Zip file', '壓縮檔（Zip）'],\r\n    _当前作品个数: [\r\n        '当前有 {} 个作品 ',\r\n        '今は　{}　枚の作品があります ',\r\n        'There are now {} works ',\r\n        '目前有 {} 個作品 ',\r\n    ],\r\n    _当前有x个用户: [\r\n        '当前有 {} 个用户 ',\r\n        '現在 {} 人のユーザーがいます ',\r\n        'There are currently {} users ',\r\n        '目前有 {} 個使用者 ',\r\n    ],\r\n    _排行榜进度: [\r\n        '已抓取本页面第{}部分',\r\n        'このページの第　{}　部がクロールされました',\r\n        'Part {} of this page has been crawled',\r\n        '已擷取本頁面第 {} 部分',\r\n    ],\r\n    _新作品进度: [\r\n        '已抓取本页面 {} 个作品',\r\n        'このページの {} つの作品をクロールしました',\r\n        'This page has been crawled {} works',\r\n        '已擷取本頁面 {} 個作品',\r\n    ],\r\n    _抓取多少个作品: [\r\n        '抓取本页面 {} 个作品',\r\n        'このページの {} つの作品をクロールします',\r\n        'Crawl this page {} works',\r\n        '擷取本頁面 {} 個作品',\r\n    ],\r\n    _相关作品抓取完毕: [\r\n        '相关作品抓取完毕。包含有{}个作品，开始获取作品信息。',\r\n        '関連作品はクロールされました。 {} 作品を含み、その作品に関する情報の取得を開始します。',\r\n        'The related works have been crawled. Contains {} works and starts getting information about the work.',\r\n        '相關作品擷取完畢。包含有 {} 個作品，開始取得作品資訊。',\r\n    ],\r\n    _排行榜任务完成: [\r\n        '本页面抓取完毕。<br>当前有{}个作品，开始获取作品信息。',\r\n        'このページのクロール終了。<br>{}枚の作品があります。 作品情報の取得を開始します。',\r\n        'This page is crawled and now has {} works.<br> Start getting the works for more information.',\r\n        '本頁面擷取完畢。<br>目前有 {} 個作品，開始取得作品資訊。',\r\n    ],\r\n    _列表页抓取进度: [\r\n        '已抓取列表页{}个页面',\r\n        '{} のリストページを取得しました',\r\n        'Has acquired {} list pages',\r\n        '已擷取清單頁 {} 個頁面',\r\n    ],\r\n    _列表页抓取完成: [\r\n        '列表页面抓取完成，开始获取图片网址',\r\n        'リストページがクロールされ、画像 URL の取得が開始されます',\r\n        'The list page is crawled and starts to get the image URL',\r\n        '清單頁面擷取完成，開始取得圖片網址',\r\n    ],\r\n    _抓取结果为零: [\r\n        '抓取完毕，但没有找到符合筛选条件的作品。',\r\n        'クロールは終了しましたが、フィルタ条件に一致する作品が見つかりませんでした。',\r\n        'Crawl finished but did not find works that match the filter criteria.',\r\n        '擷取完畢，但沒有找到符合篩選條件的作品。',\r\n    ],\r\n    _当前任务尚未完成: [\r\n        '当前任务尚未完成',\r\n        '現在のタスクはまだ完了していません',\r\n        'The current task has not yet been completed',\r\n        '目前工作尚未完成',\r\n    ],\r\n    _当前任务尚未完成2: [\r\n        '当前任务尚未完成，请等待完成后再下载。',\r\n        '現在のタスクはまだ完了していません、完了するまでお待ちください',\r\n        'The current task has not yet been completed',\r\n        '目前工作尚未完成，請等待完成後再下載。',\r\n    ],\r\n    _列表抓取完成开始获取作品页: [\r\n        '当前列表中有{}张作品，开始获取作品信息',\r\n        '{} 枚の作品があります。 作品情報の取得を開始します。',\r\n        'Now has {} works. Start getting the works for more information.',\r\n        '目前清單中有 {} 張作品，開始取得作品資訊',\r\n    ],\r\n    _开始获取作品页面: [\r\n        '开始获取作品页面',\r\n        '作品ページの取得を開始する',\r\n        'Start getting the works page',\r\n        '開始取得作品頁面',\r\n    ],\r\n    _无权访问2: [\r\n        '无权访问 {}，跳过该作品。',\r\n        '{} のアクセス権限がありません、作品を無視する。',\r\n        'No access {}, skip.',\r\n        '沒有權限存取 {}，跳過該作品。',\r\n    ],\r\n    _作品页状态码0: [\r\n        '请求的url不可访问',\r\n        '要求された URL にアクセスできません',\r\n        'The requested url is not accessible',\r\n        '要求的 url 無法存取',\r\n    ],\r\n    _作品页状态码400: [\r\n        '该作品已被删除',\r\n        '作品は削除されました',\r\n        'The work has been deleted',\r\n        '該作品已被刪除',\r\n    ],\r\n    _作品页状态码403: [\r\n        '无权访问请求的url 403',\r\n        'リクエストされた url にアクセスできない 403',\r\n        'Have no access to the requested url 403',\r\n        '沒有權限存取要求的 url 403',\r\n    ],\r\n    _作品页状态码404: [\r\n        '404 not found',\r\n        '404 not found',\r\n        '404 not found',\r\n        '404 not found',\r\n    ],\r\n    _抓取的文件数量: [\r\n        '已获取 {} 个文件网址',\r\n        '5つのファイルURLを取得する',\r\n        'Get {} file URLs',\r\n        '已取得 {} 個檔案網址',\r\n    ],\r\n    _正在抓取: [\r\n        '正在抓取，请等待……',\r\n        'クロール中、しばらくお待ちください...',\r\n        'Getting, please wait...',\r\n        '擷取中，請稍後……',\r\n    ],\r\n    _获取全部书签作品: [\r\n        '获取全部书签作品，时间可能比较长，请耐心等待。',\r\n        'ブックマークしたすべての作品を取得すると、時間がかかることがあります。お待ちください。',\r\n        'Get all bookmarked works, the time may be longer, please wait.',\r\n        '取得全部書籤作品，時間可能比較長，請耐心等待。',\r\n    ],\r\n    _抓取图片网址遇到中断: [\r\n        '当前任务已中断!',\r\n        '現在のタスクが中断されました。',\r\n        'The current task has been interrupted.',\r\n        '目前工作已中斷！',\r\n    ],\r\n    _关闭: ['关闭', 'クローズ', 'close', '關閉'],\r\n    _输出信息: ['输出信息', '出力情報', 'Output information', '輸出資訊'],\r\n    _复制: ['复制', 'コピー', 'Copy', '複製'],\r\n    _已复制到剪贴板: [\r\n        '已复制到剪贴板，可直接粘贴',\r\n        'クリップボードにコピーされました',\r\n        'Has been copied to the clipboard',\r\n        '已複製至剪貼簿，可直接貼上',\r\n    ],\r\n    _下载设置: ['下载设置', 'ダウンロード設定', 'Download settings', '下載設定'],\r\n    _收起展开设置项: [\r\n        '收起/展开设置项',\r\n        '設定の折りたたみ/展開',\r\n        'Collapse/expand settings',\r\n        '摺疊/展開設定項目',\r\n    ],\r\n    _github: [\r\n        'Github 页面，欢迎 star',\r\n        'Github のページ、star をクリックしてください',\r\n        'Github page, if you like, please star it',\r\n        'Github 頁面，歡迎 star',\r\n    ],\r\n    _wiki: ['使用手册', 'マニュアル', 'Wiki', 'Wiki'],\r\n    _快捷键切换显示隐藏: [\r\n        '使用 Alt + X，可以显示和隐藏下载面板',\r\n        'Alt + X を使用してダウンロードパネルを表示および非表示にする',\r\n        'Use Alt + X to show and hide the download panel',\r\n        'Alt + X 可以顯示或隱藏下載面板。',\r\n    ],\r\n    _共抓取到n个文件: [\r\n        '共抓取到 {} 个文件',\r\n        '合計 {} つのファイルがあります',\r\n        'Crawl a total of {} files',\r\n        '共擷取到 {} 個檔案',\r\n    ],\r\n    _设置文件名: [\r\n        '设置命名规则',\r\n        '命名規則を設定する',\r\n        'Set naming rules',\r\n        '設定命名規則',\r\n    ],\r\n    _设置文件夹名的提示: [\r\n        `可以使用 '/' 建立文件夹<br>示例：{p_title}/{user}/{id}`,\r\n        `フォルダーは '/' で作成できます<br>例：{p_title}/{user}/{id}`,\r\n        `You can create a directory with '/'<br>Example：{p_title}/{user}/{id}`,\r\n        `可以使用斜線（/）建立資料夾。<br>範例：{p_title}/{user}/{id}`,\r\n    ],\r\n    _添加命名标记前缀: [\r\n        '添加命名标记前缀',\r\n        '前に tag の名前を追加',\r\n        'Add named tag prefix',\r\n        '加入命名標記前綴',\r\n    ],\r\n    _添加字段名称提示: [\r\n        '例如，在用户名前面添加“user_”标记',\r\n        'たとえば、ユーザー名の前に 「user_」 tag を追加します。',\r\n        'For example, add the \"user_\" tag in front of the username',\r\n        '例如，在使用者名稱前面加入「user_」標記。',\r\n    ],\r\n    _查看标记的含义: [\r\n        '查看标记的含义',\r\n        ' tag の意味を表示する',\r\n        'View the meaning of the tag',\r\n        '檢視標記的意義',\r\n    ],\r\n    _命名标记id: [\r\n        '默认文件名，如 44920385_p0',\r\n        'デフォルトのファイル名，例 44920385_p0',\r\n        'Default file name, for example 44920385_p0',\r\n        '預設檔案名稱，例如：44920385_p0。',\r\n    ],\r\n    _命名标记title: ['作品标题', '作品のタイトル', 'works title', '作品標題'],\r\n    _命名标记tags: [\r\n        '作品的 tag 列表',\r\n        '作品の tags',\r\n        'The tags of the work',\r\n        '作品的 tag 清單',\r\n    ],\r\n    _命名标记user: ['画师名字', 'アーティスト名', 'Artist name', '畫師名稱'],\r\n    _命名标记userid: ['画师 id', 'アーティスト ID', 'Artist id', '畫師 id'],\r\n    _命名标记px: ['宽度和高度', '幅と高さ', 'width and height', '寬度和高度'],\r\n    _命名标记bmk: [\r\n        'bookmark-count，作品的收藏数。把它放在最前面可以让文件按收藏数排序。',\r\n        'bookmark-count，作品のボックマークの数、前に追加することでボックマーク数で并べることができます。',\r\n        'bookmark-count, bookmarks number of works.',\r\n        'bookmark-count，作品的收藏數。將它放在最前面可以讓檔案依收藏數排序。',\r\n    ],\r\n    _命名标记id_num: [\r\n        '数字 id，如 44920385',\r\n        '44920385 などの番号 ID',\r\n        'Number id, for example 44920385',\r\n        '數字 id，例如：44920385。',\r\n    ],\r\n    _命名标记p_num: [\r\n        '图片在作品内的序号，如 0、1、2 …… 每个作品都会重新计数。',\r\n        '0、1、2 など、作品の画像のシリアル番号。各ピースは再集計されます。',\r\n        'The serial number of the picture in the work, such as 0, 1, 2 ... Each work will be recounted.',\r\n        '圖片在作品內的序號，例如：0、1、2……每個作品都將重新計數。',\r\n    ],\r\n    _命名标记tags_trans: [\r\n        '作品的 tag 列表，附带翻译后的 tag（如果有）',\r\n        '作品の tag リスト、翻訳付き tag (あれば)',\r\n        'The tags of the work, with the translated tag (if any)',\r\n        '作品的 tag 清單，包含翻譯後的 tag（如果有的話）。',\r\n    ],\r\n    _命名标记date: [\r\n        '作品的创建日期，格式为 yyyy-MM-dd。如 2019-08-29',\r\n        '作品の作成日は yyyy-MM-dd の形式でした。 2019-08-29 など',\r\n        'The date the creation of the work was in the format yyyy-MM-dd. Such as 2019-08-29',\r\n        '作品的建立日期，格式為 yyyy-MM-dd，例如：2019-08-29。',\r\n    ],\r\n    _命名标记rank: [\r\n        '作品在排行榜中的排名。如 #1、#2 …… 只能在排行榜页面中使用。',\r\n        '作品のランキング。例え　#1、#2 …… ランキングページのみで使用できます。',\r\n        'The ranking of the work in the ranking pages. Such as #1, #2 ... Can only be used in ranking pages.',\r\n        '作品在排行榜中的排名。例如：#1、#2……只能在排行榜頁面中使用。',\r\n    ],\r\n    _命名标记type: [\r\n        '作品类型，分为 illustration、manga、ugoira、novel',\r\n        '作品分類は、illustration、manga、ugoira、novel',\r\n        'The type of work, divided into illustration, manga, ugoira, novel',\r\n        '作品類型，分為 illustration、manga、ugoira、novel。',\r\n    ],\r\n    _命名标记提醒: [\r\n        '您可以使用多个标记；建议在不同标记之间添加分割用的字符。示例：{id}-{userid}<br>一定要包含 {id} 或者 {id_num}。<br>* 在某些情况下，会有一些标记不可用。',\r\n        '複数のタグを使用することができます；異なるタグ間の分割のために文字を追加することをお勧めします。例：{id}-{userid}<br>必ず{id}または{id_num}を含めてください。<br>* 場合によっては、一部の tag が利用できず。',\r\n        'You can use multiple tags, and you can add a separate character between different tags. Example: {id}-{userid}<br>Be sure to include {id} or {id_num}.<br>* In some cases, some tags will not be available.',\r\n        '可以使用多個標記；建議在不同標記之間加入分隔用的字元。範例：{id}-{userid}<br>一定要包含 {id} 或者 {id_num}。<br>＊某些情況下有些標記無法使用。',\r\n    ],\r\n    _文件夹标记PTag: [\r\n        '当前页面的 tag。当前页面没有 tag 时不可用。',\r\n        '現在のページの tag。現在のページの tag がないときは使用できません。',\r\n        'The tag of the current page. Not available if the current page has no tag.',\r\n        '目前頁面的 tag。目前頁面沒有 tag 時無法使用。',\r\n    ],\r\n    _命名标记seriesTitle: [\r\n        '系列标题（可能为空）',\r\n        'シリーズタイトル（あれば）',\r\n        'Series title (may be empty)',\r\n        '系列標題（可能為空）',\r\n    ],\r\n    _命名标记seriesOrder: [\r\n        '作品在系列中的序号，如 #1 #2',\r\n        'シリーズの中の作品の番号，例え #1 #2',\r\n        'The number of the work in the series, such as #1 #2',\r\n        '作品在系列中的編號，如 #1 #2',\r\n    ],\r\n    _文件夹标记PTitle: [\r\n        '当前页面的标题',\r\n        'ページのタイトル',\r\n        'The title of this page',\r\n        '目前頁面的標題',\r\n    ],\r\n    _预览文件名: [\r\n        '预览文件名',\r\n        'ファイル名のプレビュー',\r\n        'Preview file name',\r\n        '預覽檔案名稱',\r\n    ],\r\n    _设置下载线程: [\r\n        '设置下载线程',\r\n        'ダウンロードスレッドを設定する',\r\n        'Set the download thread',\r\n        '設定下載執行緒',\r\n    ],\r\n    _线程数字: [\r\n        '可以输入 1-5 之间的数字，设置同时下载的数量',\r\n        '同時ダウンロード数を設定、1-5 の数値を入力してください',\r\n        'You can type a number between 1-5 to set the number of concurrent downloads',\r\n        '可以輸入 1-5 之間的數字，設定同時下載的數量。',\r\n    ],\r\n    _下载按钮1: ['开始下载', 'ダウンロードを開始', 'start download', '開始下載'],\r\n    _下载按钮2: [\r\n        '暂停下载',\r\n        'ダウンロードを一時停止',\r\n        'pause download',\r\n        '暫停下載',\r\n    ],\r\n    _下载按钮3: ['停止下载', 'ダウンロードを停止', 'stop download', '停止下載'],\r\n    _复制url: ['复制 url', 'URL をコピー', 'copy urls', '複製下載網址'],\r\n    _当前状态: ['当前状态 ', '現在の状態 ', 'State ', '目前狀態：'],\r\n    _未开始下载: [\r\n        '未开始下载',\r\n        'まだダウンロードを開始していません',\r\n        'Not yet started downloading',\r\n        '未開始下載',\r\n    ],\r\n    _下载进度: [\r\n        '下载进度：',\r\n        'ダウンロードの進行状況：',\r\n        'Total progress: ',\r\n        '下載進度：',\r\n    ],\r\n    _下载线程: ['下载线程：', 'スレッド：', 'Thread: ', '下載執行緒：'],\r\n    _常见问题: ['常见问题', 'よくある質問', 'Help', '常見問題'],\r\n    _uuid: [\r\n        '如果下载后的文件名异常，请禁用其他有下载功能的浏览器扩展。',\r\n        'ダウンロード後のファイル名が異常な場合は、ダウンロード機能を持つ他のブラウザ拡張機能を無効にしてください。',\r\n        'If the file name after downloading is abnormal, disable other browser extensions that have download capabilities.',\r\n        '如果下載後的檔案名稱異常，請停用其他有下載功能的瀏覽器擴充功能。',\r\n    ],\r\n    _下载说明: [\r\n        \"下载的文件保存在浏览器的下载目录里。<br>请不要在浏览器的下载选项里选中'总是询问每个文件的保存位置'。<br><b>如果下载后的文件名异常，请禁用其他有下载功能的浏览器扩展。</b><br>QQ群：675174717\",\r\n        'ダウンロードしたファイルは、ブラウザのダウンロードディレクトリに保存されます。<br><b>ダウンロード後のファイル名が異常な場合は、ダウンロード機能を持つ他のブラウザ拡張機能を無効にしてください。</b>',\r\n        'The downloaded file is saved in the browser`s download directory. <br><b>If the file name after downloading is abnormal, disable other browser extensions that have download capabilities.</b>',\r\n        '下載的檔案儲存在瀏覽器的下載目錄裡。<br>請不要在瀏覽器的下載選項裡選取「下載每個檔案前先詢問儲存位置」。<br><b>如果下載後的檔名異常，請停用其他有下載功能的瀏覽器擴充功能。</b><br>QQ 群：675174717',\r\n    ],\r\n    _正在下载中: ['正在下载中', 'ダウンロード中', 'Downloading', '正在下載'],\r\n    _下载完毕: [\r\n        '✓ 下载完毕!',\r\n        '✓ ダウンロードが完了しました',\r\n        '✓ Download finished',\r\n        '✓ 下載完畢！',\r\n    ],\r\n    _已暂停: [\r\n        '下载已暂停',\r\n        'ダウンロードは一時停止中です',\r\n        'Download is paused',\r\n        '下載已暫停',\r\n    ],\r\n    _已停止: [\r\n        '下载已停止',\r\n        'ダウンロードが停止しました',\r\n        'Download stopped',\r\n        '下載已停止',\r\n    ],\r\n    _已下载: ['已下载', 'downloaded', 'downloaded', '已下載'],\r\n    _抓取完毕: [\r\n        '抓取完毕！',\r\n        'クロールが終了しました！',\r\n        'Crawl finished!',\r\n        '擷取完畢！',\r\n    ],\r\n    _快速下载本页: [\r\n        '快速下载本页作品',\r\n        'この作品をすばやくダウンロードする',\r\n        'Download this work quickly',\r\n        '快速下載本頁作品',\r\n    ],\r\n    _从本页开始抓取new: [\r\n        '从本页开始抓取新作品',\r\n        'このページから新しい作品を入手する',\r\n        'Crawl the new works from this page',\r\n        '從本頁開始擷取新作品',\r\n    ],\r\n    _从本页开始抓取old: [\r\n        '从本页开始抓取旧作品',\r\n        'このページから古い作品を入手する',\r\n        'Crawl the old works from this page',\r\n        '從本頁開始擷取舊作品',\r\n    ],\r\n    _抓取推荐作品: [\r\n        '抓取推荐作品',\r\n        '推奨作品をダウンロードする',\r\n        'Crawl the recommend works',\r\n        '擷取推薦作品',\r\n    ],\r\n    _抓取推荐作品Title: [\r\n        '抓取页面底部的的推荐作品',\r\n        'ページの下部で推奨作品をクロールします',\r\n        'Crawl the recommended works at the bottom of the page',\r\n        '擷取頁面底部的推薦作品。',\r\n    ],\r\n    _抓取相关作品: [\r\n        '抓取相关作品',\r\n        '関連作品をダウンロードする',\r\n        'Crawl the related works',\r\n        '擷取相關作品',\r\n    ],\r\n    _相关作品大于0: [\r\n        ' （下载相关作品必须大于 0）',\r\n        ' 「ダウンロードする関連作品の数は0より大きくなければならない」',\r\n        '  (Download related works must be greater than 0)',\r\n        ' （下載相關作品必須大於 0）',\r\n    ],\r\n    _默认下载多页: [\r\n        ', 如有多页，默认会下载全部。',\r\n        '、複数のページがある場合、デフォルトですべてをダウンロードされます。',\r\n        ', If there are multiple pages, the default will be downloaded.',\r\n        '，如有多頁，預設會下載全部。',\r\n    ],\r\n    _调整完毕: [\r\n        '调整完毕，当前有{}个作品。',\r\n        '調整が完了し、今、{} の作品があります。',\r\n        'The adjustment is complete and now has {} works.',\r\n        '調整完畢，目前有 {} 個作品。',\r\n    ],\r\n    _抓取当前作品: [\r\n        '抓取当前作品',\r\n        '現在の作品をクロールする',\r\n        'Crawl the current work',\r\n        '擷取目前作品',\r\n    ],\r\n    _抓取当前作品Title: [\r\n        '抓取当前列表里的所有作品',\r\n        '現在のリスト内のすべての作品をクロールする',\r\n        'Crawl all the works in the current list',\r\n        '擷取目前清單裡的所有作品',\r\n    ],\r\n    _清除多图作品: [\r\n        '清除多图作品',\r\n        '複数の作品を削除する',\r\n        'Remove multi-drawing works',\r\n        '清除多圖作品',\r\n    ],\r\n    _清除多图作品Title: [\r\n        '如果不需要可以清除多图作品',\r\n        '必要がない場合は、複数のグラフを削除することができます',\r\n        'If you do not need it, you can delete multiple graphs',\r\n        '如果不需要可以清除多圖作品。',\r\n    ],\r\n    _清除动图作品: [\r\n        '清除动图作品',\r\n        'うごイラ作品を削除する',\r\n        'Remove ugoira work',\r\n        '清除動圖作品',\r\n    ],\r\n    _清除动图作品Title: [\r\n        '如果不需要可以清除动图作品',\r\n        '必要がない場合は、うごイラを削除することができます',\r\n        'If you do not need it, you can delete the ugoira work',\r\n        '如果不需要可以清除動圖作品。',\r\n    ],\r\n    _手动删除作品: [\r\n        '手动删除作品',\r\n        '作品を手動で削除する',\r\n        'Manually delete the work',\r\n        '手動刪除作品',\r\n    ],\r\n    _手动删除作品Title: [\r\n        '可以在下载前手动删除不需要的作品',\r\n        'ダウンロードする前に不要な作品を手動で削除することができます',\r\n        'You can manually delete unwanted work before downloading',\r\n        '可以在下載前手動刪除不需要的作品，點擊作品刪除。',\r\n    ],\r\n    _退出手动删除: [\r\n        '退出手动删除',\r\n        '削除モードを終了する',\r\n        'Exit manually delete',\r\n        '結束手動刪除',\r\n    ],\r\n    _抓取本页作品: [\r\n        '抓取本页作品',\r\n        'このページをクロールする',\r\n        'Crawl this page works',\r\n        '擷取本頁作品',\r\n    ],\r\n    _抓取本页作品Title: [\r\n        '抓取本页列表中的所有作品',\r\n        'このページの全ての作品をクロールする',\r\n        'Crawl this page works',\r\n        '擷取本頁清單中的所有作品',\r\n    ],\r\n    _抓取本排行榜作品: [\r\n        '抓取本排行榜作品',\r\n        'このリストの作品をクロールする',\r\n        'Crawl the works in this list',\r\n        '擷取本排行榜作品',\r\n    ],\r\n    _抓取本排行榜作品Title: [\r\n        '抓取本排行榜的所有作品，包括现在尚未加载出来的。',\r\n        'まだ読み込まれていないものを含めて、このリストの作品をダウンロードする',\r\n        'Crawl all of the works in this list, including those that are not yet loaded.',\r\n        '擷取本排行榜的所有作品，包括現在尚未載入出來的。',\r\n    ],\r\n    _抓取首次登场的作品: [\r\n        '抓取首次登场作品',\r\n        '初登場作品をダウンロードする',\r\n        'Crawl the debut works',\r\n        '擷取首次登場作品',\r\n    ],\r\n    _抓取首次登场的作品Title: [\r\n        '只下载首次登场的作品',\r\n        '初登場作品のみダウンロードします',\r\n        'Download only debut works',\r\n        '只下載首次登場的作品',\r\n    ],\r\n    _抓取该页面的图片: [\r\n        '抓取该页面的图片',\r\n        'ページの画像をクロールする',\r\n        'Crawl the picture of the page',\r\n        '擷取該頁面的圖片',\r\n    ],\r\n    _抓取相似图片: [\r\n        '抓取相似图片',\r\n        '類似の作品をクロールする',\r\n        'Crawl similar works',\r\n        '擷取相似圖片',\r\n    ],\r\n    _想要获取多少个作品: [\r\n        '您想要获取多少个作品？',\r\n        'いくつの作品をダウンロードしたいですか？',\r\n        'How many works do you want to download?',\r\n        '想要取得多少個作品？',\r\n    ],\r\n    _数字提示1: [\r\n        '-1, 或者大于 0',\r\n        '-1、または 0 より大きい',\r\n        '-1, or greater than 0',\r\n        '-1 或是大於 0',\r\n    ],\r\n    _下载大家的新作品: [\r\n        '下载大家的新作品',\r\n        'みんなの新作をダウンロードする',\r\n        'Download everyone`s new work',\r\n        '下載大家的新作品',\r\n    ],\r\n    _屏蔽设定: ['屏蔽設定', 'ミュート設定', 'Mute settings', '封鎖設定'],\r\n    _举报: ['举报', '報告', 'Report', '回報'],\r\n    _输入id进行抓取: [\r\n        '输入id进行抓取',\r\n        'idを入力してダウンロードする',\r\n        'Enter id to fetch',\r\n        '輸入 id 進行擷取',\r\n    ],\r\n    _输入id进行抓取的提示文字: [\r\n        '请输入作品id。如果有多个id，则以换行分割（即每行一个id）',\r\n        'イラストレーターIDを入力してください。 複数の id がある場合は、1 行に 1 つの id を付けます。',\r\n        'Please type the illustration id. If there is more than one id, one id per line.',\r\n        '請輸入作品 id。如果有多個 id，則以換行分隔（即每行一個 id）。',\r\n    ],\r\n    _开始抓取: ['开始抓取', 'クロールを開始する', 'Start crawling', '開始擷取'],\r\n    _添加tag: [\r\n        '给未分类作品添加 tag',\r\n        '未分類の作品に tag を追加',\r\n        'Add tag to unclassified work',\r\n        '幫未分類的作品加入 tag',\r\n    ],\r\n    _id不合法: [\r\n        'id不合法，操作取消。',\r\n        'id が不正な、操作はキャンセルされます。',\r\n        'id is illegal, the operation is canceled.',\r\n        'id 不合法，動作取消。',\r\n    ],\r\n    _快速收藏: [\r\n        '快速收藏',\r\n        'クイックブックマーク',\r\n        'Quick bookmarks',\r\n        '快速收藏',\r\n    ],\r\n    _启用: ['启用', '有効にする', 'Enable', '啟用'],\r\n    _自动开始下载: [\r\n        '自动开始下载',\r\n        'ダウンロードは自動的に開始されます',\r\n        'Download starts automatically',\r\n        '自動開始下載',\r\n    ],\r\n    _快速下载的提示: [\r\n        '当“开始下载”状态可用时，自动开始下载，不需要点击下载按钮。',\r\n        '「ダウンロードを開始する」ステータスが利用可能になると、ダウンロードは自動的に開始され、ダウンロードボタンをクリックする必要はありません。',\r\n        'When the &quot;Start Downloa&quot; status is available, the download starts automatically and no need to click the download button.',\r\n        '當可下載時自動開始下載，不需要點選下載按鈕。',\r\n    ],\r\n    _转换任务提示: [\r\n        '正在转换 {} 个文件',\r\n        '{} ファイルの変換',\r\n        'Converting {} files',\r\n        '正在轉換 {} 個檔案',\r\n    ],\r\n    _最近更新: ['最近更新', '最近更新する', 'What`s new', '最近更新'],\r\n    _确定: ['确定', '確定', 'Ok', '確定'],\r\n    _file404: [\r\n        '404 错误：文件 {} 不存在。',\r\n        '404 エラー：ファイル {} は存在しません。',\r\n        '404 error: File {} does not exist.',\r\n        '404 錯誤：檔案 {} 不存在。',\r\n    ],\r\n    _文件下载失败: [\r\n        '文件 {} 下载失败',\r\n        'ファイル {} のダウンロードを失敗しました',\r\n        'File {} download failed',\r\n        '檔案 {} 下載失敗',\r\n    ],\r\n    _重置设置: ['重置设置', 'リセット設定', 'Reset Settings', '重設設定'],\r\n    _是否重置设置: [\r\n        '是否重置设置？',\r\n        '設定をリセットしますか？',\r\n        'Do you want to reset the settings?',\r\n        '確定要重設設定嗎？',\r\n    ],\r\n    _newver: [\r\n        '有新版本可用',\r\n        '新しいバージョンがあります',\r\n        'A new version is available',\r\n        '有新版本可更新',\r\n    ],\r\n    _快速下载建立文件夹: [\r\n        '快速下载时，始终创建文件夹',\r\n        'クイックダウンロード時、常にフォルダを作成します',\r\n        'Always create directory when downloading quickly',\r\n        '快速下載時，始終建立資料夾',\r\n    ],\r\n    _快速下载建立文件夹提示: [\r\n        '快速下载时，如果只有一张图片，也会建立文件夹',\r\n        'すばやくダウンロードとき、イラストが一枚だけでも、フォルダも作成されます',\r\n        'When downloading quickly, if there is only one picture, a directory is also created',\r\n        '快速下載時，若只有一張圖片，也會建立資料夾',\r\n    ],\r\n    _设置id范围: [\r\n        '设置 id 范围',\r\n        'id 範囲を設定',\r\n        'Set id range',\r\n        '設定 id 範圍',\r\n    ],\r\n    _设置id范围提示: [\r\n        '您可以输入一个作品 id，抓取比它新或者比它旧的作品',\r\n        '1 つの作品 id を入力することで、それより新しいあるいは古い作品をクロールことができます',\r\n        'You can enter a work id and crawl works that are newer or older than it',\r\n        '可以輸入一個作品 id，擷取比它新或者比它舊的作品。',\r\n    ],\r\n    _大于: ['大于', 'より大きい', 'Bigger than', '大於'],\r\n    _小于: ['小于', 'より小さい', 'Less than', '小於'],\r\n    _设置投稿时间: [\r\n        '设置投稿时间',\r\n        '投稿日時を設定する',\r\n        'Set posting date',\r\n        '設定投稿時間',\r\n    ],\r\n    _设置投稿时间提示: [\r\n        '您可以下载指定时间内发布的作品',\r\n        '指定された時間内に配信された作品をダウンロードすることができます',\r\n        'You can download works posted in a specified period of time',\r\n        '可以下載指定時間內發布的作品。',\r\n    ],\r\n    _时间范围: ['时间范围', '時間範囲', 'Time range', '時間範圍'],\r\n    _必须大于0: [\r\n        '必须大于 0',\r\n        '0 より大きくなければなりません',\r\n        'must be greater than 0',\r\n        '必須大於 0',\r\n    ],\r\n    _开始筛选: ['开始筛选', 'スクリーニング開始', 'Start screening', '開始篩選'],\r\n    _开始筛选Title: [\r\n        '按照设置来筛选当前 tag 里的作品。',\r\n        '現在の tag にある作品を設定によってスクリーニングする',\r\n        'Screen the works in the current tag.',\r\n        '按照設定來篩選目前 tag 裡的作品。',\r\n    ],\r\n    _在结果中筛选: [\r\n        '在结果中筛选',\r\n        '結果の中からスクリーニング',\r\n        'Screen in results',\r\n        '在結果中篩選',\r\n    ],\r\n    _在结果中筛选Title: [\r\n        '您可以改变设置，并在结果中再次筛选。',\r\n        '設定を変えて、結果の中で再びスクリーニングすることができます。',\r\n        'You can change the settings and screen again in the results.',\r\n        '可以變更設定，並在結果中再次篩選。',\r\n    ],\r\n    _抓取筛选结果: [\r\n        '抓取筛选结果',\r\n        'スクリーニングの結果をクロールする',\r\n        'Crawl the screening results',\r\n        '擷取篩選結果',\r\n    ],\r\n    _尚未开始筛选: [\r\n        '尚未开始筛选',\r\n        'まだスクリーニングを開始していない',\r\n        'Screening has not started',\r\n        '尚未開始篩選',\r\n    ],\r\n    _没有数据可供使用: [\r\n        '没有数据可供使用',\r\n        '使用可能なデータはない',\r\n        'No data is available.',\r\n        '沒有資料可供使用',\r\n    ],\r\n    _预览搜索结果: [\r\n        '预览搜索页面的筛选结果',\r\n        '検索ページのフィルタ結果をプレビューします',\r\n        'Preview filter results on search page',\r\n        '預覽搜尋頁面的篩選結果',\r\n    ],\r\n    _预览搜索结果说明: [\r\n        '下载器可以把符合条件的作品显示在当前页面上。如果抓取结果太多导致页面崩溃，请关闭这个功能。<br>启用预览功能时，下载器不会自动开始下载。',\r\n        'ローダは、該当する作品を現在のページに表示することができます。クロール結果が多すぎてページが崩れる場合は、この機能をオフにしてください。<br>プレビュー機能を有効にすると、ダウンロードは自動的に開始されません。',\r\n        'The downloader can display the qualified works on the current page. If too many crawling results cause the page to crash, turn off this feature.<br>When the preview feature is enabled, the downloader does not start downloading automatically.',\r\n        '下載器可以將符合條件的作品顯示在目前頁面上。如果擷取結果太多導致頁面當掉，請關閉這個功能。<br>啟用預覽功能時，下載器不會自動開始下載。',\r\n    ],\r\n    _目录名使用: [\r\n        '目录名使用：',\r\n        'ディレクトリ名の使用：',\r\n        'Folder name use: ',\r\n        '資料夾名稱使用：',\r\n    ],\r\n    _命名规则: ['命名规则', '命名規則', 'Naming rule', '命名規則'],\r\n    _启用快速收藏: [\r\n        '启用快速收藏',\r\n        'クイックボックマークを有効にする',\r\n        'Enable quick bookmark',\r\n        '開啟快速收藏',\r\n    ],\r\n    _启用快速收藏说明: [\r\n        '当你点击下载器添加的收藏按钮(☆)，把作品添加到书签时，自动添加这个作品的 tag。',\r\n        'ダウンローダーに追加されたボックマークボタン「☆」をクリックして、作品をブックマークに追加すると、自動的に作品の tag が追加されます。',\r\n        'When you click the favorite button (☆) added by the downloader to bookmark a work, the tag of the work is automatically added.',\r\n        '當點選下載器新增的收藏按鈕（☆），將作品加入書籤時，自動新增這個作品的 tag。',\r\n    ],\r\n    _新增设置项: [\r\n        '新增设置项',\r\n        '新たな機能を追加されました。',\r\n        'Added setting items',\r\n        '新增設定項目',\r\n    ],\r\n    _抓取: ['抓取', 'クロール', 'Crawl', '擷取'],\r\n    _下载: ['下载', 'ダウンロード', 'Download', '下載'],\r\n    _其他: ['其他', 'その他', 'Other', '其他'],\r\n    _第一张图不带序号: [\r\n        '第一张图不带序号',\r\n        '最初のイメージの番号を削除します',\r\n        'The first picture without a serial number',\r\n        '第一張圖片不包含序號',\r\n    ],\r\n    _第一张图不带序号说明: [\r\n        '去掉每个作品第一张图的序号。例如 80036479_p0 变成 80036479',\r\n        '作品ごとの最初のイメージの番号を削除します。例えば 80036479_p0 は 80036479 になります。',\r\n        'Remove the serial number of the first picture of each work. For example 80036479_p0 becomes 80036479.',\r\n        '去掉每個作品第一張圖的序號。例如：80036479_p0 變成 80036479。',\r\n    ],\r\n    _最小值: ['最小值', '最小値', 'Minimum value', '最小值'],\r\n    _最大值: ['最大值', '最大値', 'maximum value', '最大值'],\r\n    _单图作品: [\r\n        '单图作品',\r\n        'シングルイメージ作品',\r\n        'Single image works',\r\n        '單圖作品',\r\n    ],\r\n    _彩色图片: ['彩色图片', 'カラーイメージ', 'Color picture', '彩色圖片'],\r\n    _黑白图片: [\r\n        '黑白图片',\r\n        '白黒イメージ',\r\n        'Black and white pictures',\r\n        '黑白圖片',\r\n    ],\r\n    _不保存图片因为颜色设置: [\r\n        '图片 {} 没有被保存，因为它的颜色不符合设定。',\r\n        'イメージ {} は色が設定に合わないため、保存されていません。',\r\n        'The image {} was not saved because its colors do not match the settings.',\r\n        '圖片 {} 並未儲存，因為它的色彩不符合設定。',\r\n    ],\r\n    _同时转换多少个动图: [\r\n        '同时转换多少个动图',\r\n        '同時変換のうごイラの上限',\r\n        'How many animations are converted at the same time',\r\n        '同時轉換多少個動圖',\r\n    ],\r\n    _同时转换多少个动图警告: [\r\n        '同时转换多个动图会增加资源占用。<br>转换动图时，请保持该标签页激活，否则浏览器会降低转换速度。',\r\n        '複数の動画を同時に変換すると、リソースの占有が増加します。<br>うごイラを変換するときは、このタブを有効にしてください。そうしないと、ブラウザは変換速度を下げます。',\r\n        'Converting multiple animations at the same time will increase resource consumption. <br> Please keep the tab active when converting animation, otherwise the browser will reduce the conversion speed.',\r\n        '同時轉換多個動圖會增加資源占用。<br>轉換動圖時，請保持這個分頁啟動，否則瀏覽器會降低轉換速度。',\r\n    ],\r\n    _提示: ['提示', 'ヒント', 'tip', '提示'],\r\n    _fanboxDownloader: [\r\n        'Fanbox 下载器',\r\n        'Fanbox ダウンロード',\r\n        'Fanbox Downloader',\r\n        'Fanbox 下載器',\r\n    ],\r\n    _不保存图片因为体积: [\r\n        '{} 没有被保存，因为它的体积不符合设定。',\r\n        '{} はファイルサイズが設定に合わないため、保存されていません。',\r\n        '{} was not saved because its size do not match the settings.',\r\n        '{} 並未儲存，因為它的大小不符合設定。',\r\n    ],\r\n    _文件体积限制: [\r\n        '文件体积限制',\r\n        'ファイルサイズ制限',\r\n        'File size limit',\r\n        '檔案大小限制',\r\n    ],\r\n    _不符合要求的文件不会被保存: [\r\n        '不符合要求的文件不会被保存。',\r\n        '設定 に合わないファイルは保存されません。',\r\n        'Files that do not meet the requirements will not be saved.',\r\n        '不符合要求的檔案不會被儲存。',\r\n    ],\r\n    _小说: ['小说', '小説', 'novel', '小說'],\r\n    _抓取系列小说: [\r\n        '抓取系列小说',\r\n        '小説のシリーズをクロールする',\r\n        'Crawl series of novels',\r\n        '擷取系列小說',\r\n    ],\r\n    _小说保存格式: [\r\n        '小说保存格式',\r\n        '小説の保存形式',\r\n        'Save the novel as',\r\n        '小說儲存格式',\r\n    ],\r\n    _在小说里保存元数据: [\r\n        '在小说里保存元数据',\r\n        '小説の中にメタデータを保存する',\r\n        'Save metadata in the novel',\r\n        '將中繼資料（metadata）儲存在小說裡',\r\n    ],\r\n    _在小说里保存元数据提示: [\r\n        '把作者、网址等信息保存到小說里',\r\n        '作者やURLなどの情報をファイルの中に保存します。',\r\n        'Save the author, url and other information in the file',\r\n        '將作者、網址等訊息儲存到小說裡',\r\n    ],\r\n    _收藏本页面的所有作品: [\r\n        '收藏本页面的所有作品',\r\n        'この頁の全ての作品をブックマークに追加します',\r\n        'Bookmark all works on this page',\r\n        '收藏本頁面的所有作品',\r\n    ],\r\n    _输出内容太多已经为你保存到文件: [\r\n        '因为输出内容太多，已经为您保存到文件。',\r\n        '出力内容が多いため、txt ファイルに保存しました。',\r\n        'Because the output is too much, it has been saved to a file.',\r\n        '因為輸出內容太多，已經為你保存到檔案。',\r\n    ],\r\n    _不下载重复文件: [\r\n        '不下载重复文件',\r\n        '重複ファイルをダウンロードしない',\r\n        'Don`t download duplicate files',\r\n        '不下載重複檔案',\r\n    ],\r\n    _不下载重复文件的提示: [\r\n        '下载器会保存自己的下载记录，以避免下载重复的文件。',\r\n        'ダウンローダーは独自のダウンロード履歴を保存して、重複ファイルのダウンロードを回避する。',\r\n        'The downloader will save its download record to avoid downloading duplicate files.',\r\n        '下載器會儲存自己的下載記錄，以避免下載重複的檔案。',\r\n    ],\r\n    _策略: ['策略：', 'フィルター：', 'Strategy:', '策略：'],\r\n    _严格: ['严格', '厳格', 'Strict', '嚴格'],\r\n    _宽松: ['宽松', '緩い', 'Loose', '寬鬆'],\r\n    _严格模式说明: [\r\n        '当文件的 id 和文件名都相同时，认为是重复文件',\r\n        'ファイルの ID とファイル名が同じ場合、重複ファイルとみなされます',\r\n        'When the file id and file name are the same, it is considered a duplicate file',\r\n        '當檔案 id 和檔名都相同時，認為是重複檔案',\r\n    ],\r\n    _宽松模式说明: [\r\n        '只要文件的 id 相同，就认为是重复文件',\r\n        'ファイルの ID が同じである限り、重複ファイルと見なされます',\r\n        'As long as the id of the file is the same, it is considered a duplicate file',\r\n        '只要檔案 id 相同，就認為是重複檔案',\r\n    ],\r\n    _清除下载记录: [\r\n        '清除下载记录',\r\n        '履歴をクリア',\r\n        'Clear download record',\r\n        '清除下載記錄',\r\n    ],\r\n    _下载记录已清除: [\r\n        '下载记录已清除',\r\n        'ダウンロード履歴がクリアされました',\r\n        'Download record has been cleared',\r\n        '已清除下載記錄',\r\n    ],\r\n    _跳过下载因为重复文件: [\r\n        '检测到文件 {} 已经下载过，跳过此次下载',\r\n        '重複ファイル {} をスキップ',\r\n        'Skip downloading duplicate files {}',\r\n        '偵測到檔案 {} 已經下載過，跳過此次下載。',\r\n    ],\r\n    _xzNew660: [\r\n        '添加点续传功能；添加不下载重复文件的功能。',\r\n        '「レジューム機能を追加しました；重複ファイルの除外機能を追加しました。',\r\n        'Add breakpoint resume function; add the function not to download duplicate files.',\r\n        '新增断點續傳功能；新增不下載重複檔案的功能。',\r\n    ],\r\n    _保存用户头像为图标: [\r\n        '保存用户头像为图标',\r\n        'プロフィール画像をアイコンとして保存',\r\n        'Save user avatar as icon',\r\n        '將使用者頭像另存為圖示檔案',\r\n    ],\r\n    _保存用户头像为图标说明: [\r\n        '把用户头像保存为 ico 文件，可以手动设置成文件夹的图标。',\r\n        'ユーザーのプロフィール画像を ico ファイルとして保存して、フォルダーアイコンとして設定できます。',\r\n        'Save user avatar as icon',\r\n        '將使用者頭像儲存為 ico 檔案，可以手動設定成資料夾圖示。',\r\n    ],\r\n    _正在保存抓取结果: [\r\n        '正在保存抓取结果',\r\n        'クロール結果を保存しています',\r\n        'Saving crawl results',\r\n        '正在儲存擷取結果',\r\n    ],\r\n    _已保存抓取结果: [\r\n        '已保存抓取结果',\r\n        'クロール結果を保存しました',\r\n        'Crawl results saved',\r\n        '已儲存擷取結果',\r\n    ],\r\n    _正在恢复抓取结果: [\r\n        '正在恢复抓取结果',\r\n        'クロール結果を再開しています',\r\n        'Restoring crawl results',\r\n        '正在還原擷取結果',\r\n    ],\r\n    _已恢复抓取结果: [\r\n        '已恢复抓取结果',\r\n        'クロール結果を再開しました',\r\n        'Crawl results resumed',\r\n        '已還原擷取結果',\r\n    ],\r\n};\r\nexport { langText };\r\n","// 初始化收藏的新作小说页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { API } from '../API';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../Options';\r\nimport { filter } from '../Filter';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nclass InitBookmarkNewNovelPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.baseUrl = '';\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        this.maxCount = 100;\r\n        options.setWantPage({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n            value: this.maxCount.toString(),\r\n        });\r\n    }\r\n    getWantPage() {\r\n        const check = this.checkWantPageInputGreater0();\r\n        if (check == undefined) {\r\n            return;\r\n        }\r\n        this.crawlNumber = check;\r\n        if (this.crawlNumber > this.maxCount) {\r\n            this.crawlNumber = this.maxCount;\r\n        }\r\n        log.warning(lang.transl('_任务开始1', this.crawlNumber.toString()));\r\n    }\r\n    getPageUrl() {\r\n        // 设置起始页面\r\n        const p = API.getURLSearchField(location.href, 'p');\r\n        this.startpageNo = parseInt(p) || 1;\r\n        const url = new URL(window.location.href);\r\n        url.searchParams.set('p', '1');\r\n        this.baseUrl = url.toString();\r\n        // https://www.pixiv.net/novel/bookmark_new.php?p=1\r\n        // https://www.pixiv.net/novel/bookmark_new_r18.php?p=1\r\n    }\r\n    nextStep() {\r\n        this.getPageUrl();\r\n        this.getIdList();\r\n    }\r\n    async getIdList() {\r\n        let p = this.startpageNo + this.listPageFinished;\r\n        let dom;\r\n        try {\r\n            const res = await fetch(this.baseUrl.replace('p=1', 'p=' + p));\r\n            const text = await res.text();\r\n            const parse = new DOMParser();\r\n            dom = parse.parseFromString(text, 'text/html');\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        this.listPageFinished++;\r\n        if (dom.querySelector('._no-item')) {\r\n            // 此页没有内容，也就没有后续内容了\r\n            return this.getIdListFinished();\r\n        }\r\n        const NovelItem = dom.querySelectorAll('.novel-items>li');\r\n        // 检查每个作品的信息\r\n        for (const item of NovelItem) {\r\n            // https://www.pixiv.net/novel/show.php?id=12831389\r\n            const link = item.querySelector('.imgbox a').href;\r\n            const id = parseInt(link.split('id=')[1]);\r\n            const bmkEl = item.querySelector('.bookmark-count');\r\n            let bmk = bmkEl ? parseInt(bmkEl.innerText) : 0;\r\n            const tags = [];\r\n            const tagsA = item.querySelectorAll('.tags>li>a');\r\n            for (const a of tagsA) {\r\n                tags.push(a.innerText.trim());\r\n            }\r\n            // 有的作品没有收藏按钮，点进去之后发现这个作品已经被删除了，只是排行榜里没有及时更新。这样的作品没有收藏按钮。\r\n            const bookmarkBtn = item.querySelector('._one-click-bookmark');\r\n            const bookmarked = bookmarkBtn\r\n                ? bookmarkBtn.classList.contains('on')\r\n                : false;\r\n            const filterOpt = {\r\n                id: id,\r\n                illustType: 3,\r\n                tags: tags,\r\n                bookmarkCount: bmk,\r\n                bookmarkData: bookmarked,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: 'novels',\r\n                    id: id.toString(),\r\n                });\r\n            }\r\n        }\r\n        log.log(lang.transl('_列表页抓取进度', this.listPageFinished.toString()), 1, false);\r\n        // 抓取完毕\r\n        if (p >= this.maxCount || this.listPageFinished === this.crawlNumber) {\r\n            log.log(lang.transl('_列表页抓取完成'));\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 继续抓取\r\n            this.getIdList();\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listPageFinished = 0;\r\n    }\r\n}\r\nexport { InitBookmarkNewNovelPage };\r\n","// 初始化 大家的新作小说页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { options } from '../Options';\r\nimport { filter } from '../Filter';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nimport { DOM } from '../DOM';\r\nclass InitNewNovelPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.option = this.resetOption();\r\n        this.limitMax = 20; // 每次请求的数量最大是 20\r\n        this.fetchCount = 0; // 已请求的作品数量\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_下载大家的新作品')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    appendElseEl() { }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        options.setWantPage({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_想要获取多少个作品'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n            value: '100',\r\n        });\r\n    }\r\n    getWantPage() {\r\n        const check = this.checkWantPageInputGreater0();\r\n        if (check == undefined) {\r\n            return;\r\n        }\r\n        this.crawlNumber = check;\r\n        if (this.crawlNumber > this.maxCount) {\r\n            this.crawlNumber = this.maxCount;\r\n        }\r\n        log.warning(lang.transl('_抓取多少个作品', this.crawlNumber.toString()));\r\n    }\r\n    nextStep() {\r\n        this.initFetchURL();\r\n        this.getIdList();\r\n    }\r\n    resetOption() {\r\n        return {\r\n            lastId: '0',\r\n            limit: '20',\r\n            type: '',\r\n            r18: '',\r\n        };\r\n    }\r\n    // 组织要请求的 url\r\n    initFetchURL() {\r\n        this.option = this.resetOption();\r\n        if (this.crawlNumber < this.limitMax) {\r\n            this.option.limit = this.crawlNumber.toString();\r\n        }\r\n        else {\r\n            this.option.limit = this.limitMax.toString();\r\n        }\r\n        // 是否是 R18 模式\r\n        this.option.r18 = (location.href.includes('_r18.php') || false).toString();\r\n    }\r\n    async getIdList() {\r\n        let data;\r\n        try {\r\n            data = await API.getNewNovleData(this.option);\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        let useData = data.body.novels;\r\n        for (const nowData of useData) {\r\n            // 抓取够了指定的数量\r\n            if (this.fetchCount + 1 > this.crawlNumber) {\r\n                break;\r\n            }\r\n            else {\r\n                this.fetchCount++;\r\n            }\r\n            const filterOpt = {\r\n                id: nowData.id,\r\n                bookmarkData: nowData.bookmarkData,\r\n                bookmarkCount: nowData.bookmarkCount,\r\n                illustType: 3,\r\n                tags: nowData.tags,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: 'novels',\r\n                    id: nowData.id,\r\n                });\r\n            }\r\n        }\r\n        log.log(lang.transl('_新作品进度', this.fetchCount.toString()), 1, false);\r\n        // 抓取完毕\r\n        if (this.fetchCount >= this.crawlNumber ||\r\n            this.fetchCount >= this.maxCount) {\r\n            log.log(lang.transl('_开始获取作品页面'));\r\n            this.getIdListFinished();\r\n            return;\r\n        }\r\n        // 继续抓取\r\n        this.option.lastId = data.body.lastId;\r\n        this.getIdList();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.fetchCount = 0;\r\n    }\r\n}\r\nexport { InitNewNovelPage };\r\n","//初始化小说作品页\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { options } from '../Options';\r\nimport { store } from '../Store';\r\nimport { QuickBookmark } from '../QuickBookmark';\r\nimport { DOM } from '../DOM';\r\nimport { API } from '../API';\r\nimport { log } from '../Log';\r\nimport { EVT } from '../EVT';\r\nimport { SaveAvatarIcon } from '../SaveAvatarIcon';\r\nclass InitNovelPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.crawlDirection = 0; // 抓取方向，在作品页内指示抓取新作品还是旧作品\r\n        this.quickDownBtn = document.createElement('div');\r\n        this.init();\r\n    }\r\n    initElse() {\r\n        this.initQuickBookmark();\r\n        window.addEventListener(EVT.events.pageSwitch, this.initQuickBookmark);\r\n    }\r\n    initQuickBookmark() {\r\n        new QuickBookmark();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_从本页开始抓取new')).addEventListener('click', () => {\r\n            this.crawlDirection = -1;\r\n            this.readyCrawl();\r\n        });\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_从本页开始抓取old')).addEventListener('click', () => {\r\n            this.crawlDirection = 1;\r\n            this.readyCrawl();\r\n        });\r\n        const btn = DOM.addBtn('otherBtns', Colors.green, lang.transl('_保存用户头像为图标'), [\r\n            ['title', lang.transl('_保存用户头像为图标说明')],\r\n        ]);\r\n        new SaveAvatarIcon(btn);\r\n    }\r\n    appendElseEl() {\r\n        // 在右侧创建快速下载按钮\r\n        this.quickDownBtn.id = 'quick_down_btn';\r\n        this.quickDownBtn.textContent = '↓';\r\n        this.quickDownBtn.setAttribute('title', lang.transl('_快速下载本页'));\r\n        document.body.appendChild(this.quickDownBtn);\r\n        this.quickDownBtn.addEventListener('click', () => {\r\n            store.states.quickDownload = true;\r\n            this.readyCrawl();\r\n        }, false);\r\n    }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        options.setWantPage({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_从本页开始下载提示') +\r\n                '<br>' +\r\n                lang.transl('_相关作品大于0'),\r\n            rangTip: lang.transl('_数字提示1'),\r\n            value: '-1',\r\n        });\r\n    }\r\n    destroy() {\r\n        DOM.clearSlot('crawlBtns');\r\n        DOM.clearSlot('otherBtns');\r\n        // 删除快速下载按钮\r\n        DOM.removeEl(this.quickDownBtn);\r\n        window.removeEventListener(EVT.events.pageSwitch, this.initQuickBookmark);\r\n    }\r\n    /*\r\n    -1 抓取新作品\r\n    0 不设置抓取方向\r\n    1 抓取旧作品\r\n    */\r\n    getWantPage() {\r\n        if (store.states.quickDownload) {\r\n            // 快速下载\r\n            this.crawlNumber = 1;\r\n        }\r\n        else {\r\n            // 检查下载页数的设置\r\n            const crawlAllTip = this.crawlDirection === -1\r\n                ? lang.transl('_从本页开始抓取new')\r\n                : lang.transl('_从本页开始抓取old');\r\n            this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x个作品'), crawlAllTip);\r\n        }\r\n    }\r\n    nextStep() {\r\n        if (store.states.quickDownload) {\r\n            // 快速下载\r\n            store.idList.push({\r\n                type: 'novels',\r\n                id: API.getNovelId(window.location.href),\r\n            });\r\n            log.log(lang.transl('_开始获取作品页面'));\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 向前向后下载\r\n            this.getIdList();\r\n        }\r\n    }\r\n    async getIdList() {\r\n        let type = ['novels'];\r\n        let idList = await API.getUserWorksByType(DOM.getUserId(), type);\r\n        // 储存符合条件的 id\r\n        let nowId = parseInt(API.getIllustId(window.location.href));\r\n        idList.forEach((id) => {\r\n            let idNum = parseInt(id.id);\r\n            // 新作品\r\n            if (idNum >= nowId && this.crawlDirection === -1) {\r\n                store.idList.push(id);\r\n            }\r\n            else if (idNum <= nowId && this.crawlDirection === 1) {\r\n                // 旧作品\r\n                store.idList.push(id);\r\n            }\r\n        });\r\n        // 当设置了下载个数时，进行裁剪\r\n        if (this.crawlNumber !== -1) {\r\n            // 新作品 升序排列\r\n            if (this.crawlDirection === -1) {\r\n                store.idList.sort(API.sortByProperty('id')).reverse();\r\n            }\r\n            else {\r\n                // 旧作品 降序排列\r\n                store.idList.sort(API.sortByProperty('id'));\r\n            }\r\n            store.idList = store.idList.splice(0, this.crawlNumber);\r\n        }\r\n        this.getIdListFinished();\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.crawlDirection = 0; // 解除下载方向的标记\r\n    }\r\n}\r\nexport { InitNovelPage };\r\n","//初始化小说系列作品页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { options } from '../Options';\r\nimport { store } from '../Store';\r\nimport { DOM } from '../DOM';\r\nimport { API } from '../API';\r\nclass InitNovelSeriesPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.seriesId = '';\r\n        this.limit = 30;\r\n        this.last = 0;\r\n        this.init();\r\n    }\r\n    initElse() { }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取系列小说')).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    appendElseEl() { }\r\n    setFormOption() {\r\n        // 隐藏“个数/页数”选项\r\n        options.hideOption([1]);\r\n    }\r\n    getWantPage() { }\r\n    nextStep() {\r\n        this.seriesId = API.getURLPathField('series');\r\n        this.getIdList();\r\n    }\r\n    async getIdList() {\r\n        const seriesData = await API.getNovelSeriesData(this.seriesId, this.limit, this.last, 'asc');\r\n        const list = seriesData.body.seriesContents;\r\n        for (const item of list) {\r\n            store.idList.push({\r\n                type: 'novels',\r\n                id: item.id,\r\n            });\r\n        }\r\n        this.last += list.length;\r\n        // 如果这一次返回的作品数量达到了每批限制，可能这次没有请求完，继续请求后续的数据\r\n        if (list.length === this.limit) {\r\n            this.getIdList();\r\n        }\r\n        else {\r\n            this.getIdListFinished();\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.seriesId = '';\r\n        this.last = 0;\r\n    }\r\n}\r\nexport { InitNovelSeriesPage };\r\n","// 初始化小说排行榜页面\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { DOM } from '../DOM';\r\nimport { options } from '../Options';\r\nimport { filter } from '../Filter';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nclass InitRankingNovelPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.pageUrlList = [];\r\n        this.init();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.blue, lang.transl('_抓取本排行榜作品'), [\r\n            ['title', lang.transl('_抓取本排行榜作品Title')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    setFormOption() {\r\n        // 设置“个数/页数”选项\r\n        this.maxCount = 100;\r\n        options.setWantPage({\r\n            text: lang.transl('_个数'),\r\n            tip: lang.transl('_想要获取多少个作品'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n            value: this.maxCount.toString(),\r\n        });\r\n    }\r\n    getWantPage() {\r\n        // 检查下载页数的设置\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_下载排行榜前x个作品'), lang.transl('_向下获取所有作品'));\r\n        // 如果设置的作品个数是 -1，则设置为下载所有作品\r\n        if (this.crawlNumber === -1) {\r\n            this.crawlNumber = this.maxCount;\r\n        }\r\n    }\r\n    getPageUrl() {\r\n        const ul = document.querySelector('.ui-selectbox-container ul');\r\n        if (ul) {\r\n            const li = ul.querySelectorAll('li');\r\n            this.maxCount = li.length * 50;\r\n            for (const el of li) {\r\n                this.pageUrlList.push(el.dataset.url);\r\n            }\r\n        }\r\n        else {\r\n            // 只有一页的话，没有页码部分的 ul li\r\n            this.pageUrlList.push(location.href);\r\n        }\r\n    }\r\n    nextStep() {\r\n        this.getPageUrl();\r\n        this.getIdList();\r\n    }\r\n    async getIdList() {\r\n        let dom;\r\n        try {\r\n            const res = await fetch(this.pageUrlList[this.listPageFinished]);\r\n            const text = await res.text();\r\n            const parse = new DOMParser();\r\n            dom = parse.parseFromString(text, 'text/html');\r\n        }\r\n        catch (error) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        this.listPageFinished++;\r\n        const rankingItem = dom.querySelectorAll('._ranking-items>div');\r\n        // 检查每个作品的信息\r\n        for (const item of rankingItem) {\r\n            const rank = parseInt(item.querySelector('h1').innerText);\r\n            // 检查是否已经抓取到了指定数量的作品\r\n            if (rank > this.crawlNumber) {\r\n                return this.getIdListFinished();\r\n            }\r\n            // https://www.pixiv.net/novel/show.php?id=12831389\r\n            const link = item.querySelector('.imgbox a').href;\r\n            const id = parseInt(link.split('id=')[1]);\r\n            const bmkEl = item.querySelector('.bookmark-count');\r\n            let bmk = bmkEl ? parseInt(bmkEl.innerText) : 0;\r\n            const tags = [];\r\n            const tagsA = item.querySelectorAll('.tags>li>a');\r\n            for (const a of tagsA) {\r\n                tags.push(a.innerText.trim());\r\n            }\r\n            // 有的作品没有收藏按钮，点进去之后发现这个作品已经被删除了，只是排行榜里没有及时更新。这样的作品没有收藏按钮。\r\n            const bookmarkBtn = item.querySelector('._one-click-bookmark');\r\n            const bookmarked = bookmarkBtn\r\n                ? bookmarkBtn.classList.contains('on')\r\n                : false;\r\n            const filterOpt = {\r\n                id: id,\r\n                illustType: 3,\r\n                tags: tags,\r\n                bookmarkCount: bmk,\r\n                bookmarkData: bookmarked,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.setRankList(id.toString(), rank.toString());\r\n                store.idList.push({\r\n                    type: 'novels',\r\n                    id: id.toString(),\r\n                });\r\n            }\r\n        }\r\n        log.log(lang.transl('_排行榜进度', this.listPageFinished.toString()), 1, false);\r\n        // 抓取完毕\r\n        if (store.idList.length >= this.crawlNumber ||\r\n            this.listPageFinished === this.pageUrlList.length) {\r\n            this.getIdListFinished();\r\n        }\r\n        else {\r\n            // 继续抓取\r\n            this.getIdList();\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.pageUrlList = [];\r\n        this.listPageFinished = 0;\r\n    }\r\n}\r\nexport { InitRankingNovelPage };\r\n","// 初始化小说搜索页\r\nimport { InitPageBase } from '../InitPageBase';\r\nimport { Colors } from '../Colors';\r\nimport { lang } from '../Lang';\r\nimport { options } from '../Options';\r\nimport { pageInfo } from '../PageInfo';\r\nimport { filter } from '../Filter';\r\nimport { API } from '../API';\r\nimport { store } from '../Store';\r\nimport { log } from '../Log';\r\nimport { FastScreen } from '../FastScreen';\r\nimport { DOM } from '../DOM';\r\nimport { BookmarkAllWorks } from '../BookmarkAllWorks';\r\nclass InitSearchNovelPage extends InitPageBase {\r\n    constructor() {\r\n        super();\r\n        this.worksWrapSelector = '#root section>div>ul';\r\n        this.option = {};\r\n        this.worksNoPerPage = 24; // 每个页面有多少个作品\r\n        this.needCrawlPageCount = 0; // 一共有有多少个列表页面\r\n        this.sendCrawlTaskCount = 0; // 已经抓取了多少个列表页面\r\n        this.allOption = [\r\n            'order',\r\n            'type',\r\n            'wlt',\r\n            'wgt',\r\n            'hlt',\r\n            'hgt',\r\n            'ratio',\r\n            'tool',\r\n            's_mode',\r\n            'mode',\r\n            'scd',\r\n            'ecd',\r\n            'blt',\r\n            'bgt',\r\n            'tgt',\r\n            'original_only',\r\n        ];\r\n        this.init();\r\n    }\r\n    initElse() {\r\n        new FastScreen();\r\n    }\r\n    appendCenterBtns() {\r\n        DOM.addBtn('crawlBtns', Colors.green, lang.transl('_开始抓取'), [\r\n            ['title', lang.transl('_开始抓取') + lang.transl('_默认下载多页')],\r\n        ]).addEventListener('click', () => {\r\n            this.readyCrawl();\r\n        });\r\n    }\r\n    getWorksWrap() {\r\n        const test = document.querySelectorAll(this.worksWrapSelector);\r\n        if (test.length > 0) {\r\n            // 小说页面用这个选择器，只匹配到了一个 ul\r\n            return test[test.length - 1];\r\n        }\r\n        return null;\r\n    }\r\n    appendElseEl() {\r\n        // 添加收藏本页所有作品的功能\r\n        const bookmarkAll = new BookmarkAllWorks();\r\n        bookmarkAll.btn.addEventListener('click', () => {\r\n            const listWrap = this.getWorksWrap();\r\n            if (listWrap) {\r\n                const list = document.querySelectorAll('#root section>div>ul>li');\r\n                bookmarkAll.setWorkList(list);\r\n            }\r\n        });\r\n    }\r\n    setFormOption() {\r\n        this.maxCount = 1000;\r\n        // 设置“个数/页数”选项\r\n        options.setWantPage({\r\n            text: lang.transl('_页数'),\r\n            tip: lang.transl('_从本页开始下载提示'),\r\n            rangTip: `1 - ${this.maxCount}`,\r\n            value: this.maxCount.toString(),\r\n        });\r\n    }\r\n    async nextStep() {\r\n        this.initFetchURL();\r\n        this.needCrawlPageCount = await this.calcNeedCrawlPageCount();\r\n        if (this.needCrawlPageCount === 0) {\r\n            return this.noResult();\r\n        }\r\n        this.startGetIdList();\r\n    }\r\n    getWantPage() {\r\n        this.crawlNumber = this.checkWantPageInput(lang.transl('_从本页开始下载x页'), lang.transl('_下载所有页面'));\r\n        if (this.crawlNumber === -1 || this.crawlNumber > this.maxCount) {\r\n            this.crawlNumber = this.maxCount;\r\n        }\r\n    }\r\n    // 获取搜索页的数据。因为有多处使用，所以进行了封装\r\n    async getSearchData(p) {\r\n        let data = await API.getNovelSearchData(pageInfo.getPageTag, p, this.option);\r\n        return data.body.novel;\r\n    }\r\n    // 组织要请求的 url 中的参数\r\n    initFetchURL() {\r\n        let p = API.getURLSearchField(location.href, 'p');\r\n        this.startpageNo = parseInt(p) || 1;\r\n        // 从页面 url 中获取可以使用的选项\r\n        this.option = {};\r\n        this.allOption.forEach((param) => {\r\n            let value = API.getURLSearchField(location.href, param);\r\n            if (value !== '') {\r\n                this.option[param] = value;\r\n            }\r\n        });\r\n    }\r\n    // 计算应该抓取多少页\r\n    async calcNeedCrawlPageCount() {\r\n        let data = await this.getSearchData(1);\r\n        // 计算总页数\r\n        let pageCount = Math.ceil(data.total / this.worksNoPerPage);\r\n        if (pageCount > this.maxCount) {\r\n            // 最大为 1000\r\n            pageCount = this.maxCount;\r\n        }\r\n        // 计算从本页开始抓取的话，有多少页\r\n        let needFetchPage = pageCount - this.startpageNo + 1;\r\n        // 比较用户设置的页数，取较小的那个数值\r\n        if (needFetchPage < this.crawlNumber) {\r\n            return needFetchPage;\r\n        }\r\n        else {\r\n            return this.crawlNumber;\r\n        }\r\n    }\r\n    // 计算页数之后，准备建立并发抓取线程\r\n    startGetIdList() {\r\n        if (this.needCrawlPageCount <= this.ajaxThreadsDefault) {\r\n            this.ajaxThreads = this.needCrawlPageCount;\r\n        }\r\n        else {\r\n            this.ajaxThreads = this.ajaxThreadsDefault;\r\n        }\r\n        for (let i = 0; i < this.ajaxThreads; i++) {\r\n            this.getIdList();\r\n        }\r\n    }\r\n    async getIdList() {\r\n        let p = this.startpageNo + this.sendCrawlTaskCount;\r\n        this.sendCrawlTaskCount++;\r\n        // 发起请求，获取列表页\r\n        let data;\r\n        try {\r\n            data = await this.getSearchData(p);\r\n        }\r\n        catch (_a) {\r\n            this.getIdList();\r\n            return;\r\n        }\r\n        data = data.data;\r\n        for (const nowData of data) {\r\n            const filterOpt = {\r\n                id: nowData.id,\r\n                bookmarkData: nowData.bookmarkData,\r\n                bookmarkCount: nowData.bookmarkCount,\r\n                illustType: 3,\r\n                tags: nowData.tags,\r\n            };\r\n            if (await filter.check(filterOpt)) {\r\n                store.idList.push({\r\n                    type: 'novels',\r\n                    id: nowData.id,\r\n                });\r\n            }\r\n        }\r\n        this.listPageFinished++;\r\n        log.log(lang.transl('_列表页抓取进度', this.listPageFinished.toString()), 1, false);\r\n        if (this.sendCrawlTaskCount + 1 <= this.needCrawlPageCount) {\r\n            // 继续发送抓取任务（+1 是因为 sendCrawlTaskCount 从 0 开始）\r\n            this.getIdList();\r\n        }\r\n        else {\r\n            // 抓取任务已经全部发送\r\n            if (this.listPageFinished === this.needCrawlPageCount) {\r\n                // 抓取任务全部完成\r\n                log.log(lang.transl('_列表页抓取完成'));\r\n                this.getIdListFinished();\r\n            }\r\n        }\r\n    }\r\n    resetGetIdListStatus() {\r\n        this.listPageFinished = 0;\r\n        this.sendCrawlTaskCount = 0;\r\n    }\r\n    // 搜索页把下载任务按收藏数从高到低下载\r\n    sortResult() {\r\n        store.resultMeta.sort(API.sortByProperty('bmk'));\r\n        store.result.sort(API.sortByProperty('bmk'));\r\n    }\r\n}\r\nexport { InitSearchNovelPage };\r\n","import { API } from '../API';\r\nclass MakeEPUB {\r\n    constructor() { }\r\n    // epub 内部会使用标题 title 建立一个文件夹，把一些文件存放进去，所以这里要替换掉标题的特殊字符，特殊字符会导致这个文件夹名被截断，结果就是这个 epub 文件无法被解析。\r\n    make(data, content = '') {\r\n        return new Promise((resolve, reject) => {\r\n            content = content.replace(/\\n/g, '<br/>');\r\n            new EpubMaker()\r\n                .withTemplate('idpf-wasteland')\r\n                .withAuthor(API.replaceUnsafeStr(data.body.userName))\r\n                .withModificationDate(new Date(data.body.createDate))\r\n                .withRights({\r\n                description: data.body.description,\r\n                license: '',\r\n            })\r\n                .withAttributionUrl(`https://www.pixiv.net/novel/show.php?id=${data.body.id}`)\r\n                .withCover(data.body.coverUrl, {\r\n                license: '',\r\n                attributionUrl: '',\r\n            })\r\n                .withTitle(API.replaceUnsafeStr(data.body.title))\r\n                .withSection(new EpubMaker.Section('1', null, { content: content }, false, true))\r\n                .makeEpub()\r\n                .then((blob) => {\r\n                resolve(blob);\r\n            });\r\n        });\r\n    }\r\n}\r\nconst makeEPUB = new MakeEPUB();\r\nexport { makeEPUB };\r\n","import { makeEPUB } from './MakeEPUB';\r\nclass MakeNovelFile {\r\n    static async makeEPUB(novelData, text) {\r\n        return makeEPUB.make(novelData, text);\r\n    }\r\n    static makeTXT(content) {\r\n        // 替换换行标签，移除 html 标签\r\n        content = content.replace(/<br \\/>/g, '\\n').replace(/<\\/?.+?>/g, '');\r\n        return new Blob([content], {\r\n            type: 'text/plain',\r\n        });\r\n    }\r\n}\r\nexport { MakeNovelFile };\r\n","import { filter } from '../Filter';\r\nimport { store } from '../Store';\r\nimport { form } from '../Settings';\r\nimport { MakeNovelFile } from './MakeNovelFile';\r\n// 保存单个小说作品的数据\r\nclass SaveNovelData {\r\n    async save(data) {\r\n        // 小说没有 illustType 属性， 把小说的 illustType 设置为 3，这是为了方便检查\r\n        const illustType = 3;\r\n        // 获取需要检查的信息\r\n        const body = data.body;\r\n        const bmk = body.bookmarkCount; // 收藏数\r\n        const tagArr = body.tags.tags; // 取出 tag 信息\r\n        const tags = []; // 保存 tag 列表\r\n        for (const tagData of tagArr) {\r\n            tags.push(tagData.tag);\r\n        }\r\n        const filterOpt = {\r\n            createDate: body.createDate,\r\n            id: body.id,\r\n            illustType: illustType,\r\n            tags: tags,\r\n            bookmarkCount: bmk,\r\n            bookmarkData: body.bookmarkData,\r\n        };\r\n        // 检查通过\r\n        if (await filter.check(filterOpt)) {\r\n            const id = body.id;\r\n            const idNum = parseInt(id);\r\n            const title = body.title;\r\n            const userid = body.userId;\r\n            const user = body.userName;\r\n            const bookmarked = !!body.bookmarkData;\r\n            // 时间原数据如 \"2019-12-18T22:23:37+00:00\"\r\n            // 网页上显示的日期是转换成了本地时间的，如北京时区显示为 \"2019-12-19\"，不是显示原始日期 \"2019-12-18\"。所以这里转换成本地时区的日期，和网页上保持一致，以免用户困惑。\r\n            const date0 = new Date(body.createDate);\r\n            const y = date0.getFullYear();\r\n            const m = (date0.getMonth() + 1).toString().padStart(2, '0');\r\n            const d = date0.getDate().toString().padStart(2, '0');\r\n            const date = `${y}-${m}-${d}`;\r\n            // 保存作品在排行榜上的编号\r\n            let rank = '';\r\n            let testRank = store.getRankList(body.id);\r\n            if (testRank !== undefined) {\r\n                rank = '#' + testRank;\r\n            }\r\n            let seriesTitle = body.seriesNavData ? body.seriesNavData.title : '';\r\n            let seriesOrder = body.seriesNavData ? '#' + body.seriesNavData.order : '';\r\n            let ext = form.novelSaveAs.value;\r\n            let metaArr = [];\r\n            let meta = '';\r\n            if (form.saveNovelMeta.checked) {\r\n                const pageUrl = `https://www.pixiv.net/novel/show.php?id=${id}`;\r\n                const tagsA = [];\r\n                for (const tag of tags) {\r\n                    tagsA.push('#' + tag);\r\n                }\r\n                metaArr.push(title, user, pageUrl, body.description, tagsA.join('\\n'));\r\n                meta = metaArr.join('\\n\\n') + '\\n\\n\\n';\r\n            }\r\n            let content = this.replaceFlag(meta + body.content);\r\n            let blob;\r\n            if (ext === 'txt') {\r\n                blob = MakeNovelFile.makeTXT(content);\r\n            }\r\n            else {\r\n                // 创建 epub 文件，如果失败则回滚到 txt\r\n                try {\r\n                    blob = await MakeNovelFile.makeEPUB(data, content);\r\n                }\r\n                catch (_a) {\r\n                    ext = 'txt';\r\n                    blob = MakeNovelFile.makeTXT(content);\r\n                }\r\n            }\r\n            const url = URL.createObjectURL(blob);\r\n            // 添加作品信息\r\n            store.addResult({\r\n                id: id,\r\n                idNum: idNum,\r\n                thumb: body.coverUrl || undefined,\r\n                dlCount: 1,\r\n                url: url,\r\n                title: title,\r\n                tags: tags,\r\n                tagsTranslated: tags,\r\n                user: user,\r\n                userId: userid,\r\n                ext: ext,\r\n                bmk: bmk,\r\n                bookmarked: bookmarked,\r\n                date: date,\r\n                type: illustType,\r\n                rank: rank,\r\n                seriesTitle: seriesTitle,\r\n                seriesOrder: seriesOrder,\r\n                novelBlob: blob,\r\n            });\r\n        }\r\n    }\r\n    // '[[jumpuri:予約ページ>https://www.amazon.co.jp/dp/4758092486]]'\r\n    // 替换成\r\n    // '予約ページ（https://www.amazon.co.jp/dp/4758092486）'\r\n    replaceJumpuri(str) {\r\n        let reg = /\\[\\[jumpuri:(.*?)>(.*?)\\]\\]/g;\r\n        let temp;\r\n        while ((temp = reg.exec(str))) {\r\n            str = str.replace(temp[0], `${temp[1].trim()}（${temp[2].trim()}）`);\r\n            reg.lastIndex = 0;\r\n        }\r\n        return str;\r\n    }\r\n    // > '[[rb:莉莉丝 > Lilith]]'\r\n    // 替换成\r\n    // '莉莉丝（Lilith）'\r\n    replaceRb(str) {\r\n        let reg = /\\[\\[rb:(.*?)>(.*?)\\]\\]/g;\r\n        let temp;\r\n        while ((temp = reg.exec(str))) {\r\n            str = str.replace(temp[0], `${temp[1].trim()}（${temp[2].trim()}）`);\r\n            reg.lastIndex = 0;\r\n        }\r\n        return str;\r\n    }\r\n    // > '[chapter:标题]'\r\n    // 替换成\r\n    // '标题'\r\n    replaceChapter(str) {\r\n        const reg = /\\[chapter:(.*?)\\]/g;\r\n        let temp;\r\n        while ((temp = reg.exec(str))) {\r\n            str = str.replace(temp[0], temp[1]);\r\n            reg.lastIndex = 0;\r\n        }\r\n        return str;\r\n    }\r\n    // > [pixivimage:70551567]\r\n    // 替换成\r\n    // [pixiv image link: <a href=\"http://pixiv.net/i/70551567\" target=\"_blank\">http://pixiv.net/i/70551567</a>]\r\n    replacePixivImage(str) {\r\n        let reg = /\\[pixivimage:(.*?)\\]/g;\r\n        let temp;\r\n        while ((temp = reg.exec(str))) {\r\n            const url = `http://pixiv.net/i/${temp[1].trim()}`;\r\n            str = str.replace(temp[0], `[pixiv image link: <a href=\"${url}\" target=\"_blank\">${url}</a>]`);\r\n            reg.lastIndex = 0;\r\n        }\r\n        return str;\r\n    }\r\n    // 对小说里的一些标记进行替换\r\n    replaceFlag(str) {\r\n        str = str.replace(/\\[newpage\\]/g, '');\r\n        str = this.replaceJumpuri(str);\r\n        str = str.replace(/\\[jump:.*?\\]/g, '');\r\n        str = this.replaceRb(str);\r\n        str = this.replaceChapter(str);\r\n        str = this.replacePixivImage(str);\r\n        return str;\r\n    }\r\n}\r\nconst saveNovelData = new SaveNovelData();\r\nexport { saveNovelData };\r\n"],"sourceRoot":""}