# 预览动图

以该作品为例： https://www.pixiv.net/artworks/99298109

## 对动图的一些调查

### 动图原图的体积上限

在上传多张静态图片制作动图时，上传的文件总体积不能超过 30MB。

我上传了一个动图，原图 9 张，都是 1920x1080 的 png 图片，共 29.7MB。

https://www.pixiv.net/artworks/99636469

https://www.pixiv.net/ajax/illust/99636469

### 服务器上保存有原图

从动图作品的数据里，可以生成每一帧图片的 URL，这样也可以加载所有图片。

https://www.pixiv.net/ajax/illust/99636469

其中 `original` 的 URL 获取的就是原图。

例如 `JSON.body.urls.original` 是下面这样的：

```
https://i.pximg.net/img-original/img/2022/07/10/21/09/53/99636469-c939f0c867922f29d84622aa93ee80f4_ugoira0.png
```

把末尾 `ugoira0` 最后的 0 依次替换成帧数，就可以获取每一帧的原图。

原图是未压缩过的，体积比较大。zip 包里的是压缩过的，所以 zip 压缩包的体积会比较小。

### zip 压缩包里的图片是压缩后的 jpg

我上传的是每张 3MB 多一点的 PNG 图片，总体积 29.7MB。

下载“原图”尺寸的 zip 文件，其体积只有 3MB。

```
https://i.pximg.net/img-zip-ugoira/img/2022/07/10/21/09/53/99636469-c939f0c867922f29d84622aa93ee80f4_ugoira1920x1080.zip
```

zip 里的图片都是压缩过的 jpg 图片。所以我推测，不管用户制作动图时上传的是 png 格式还是 jpg 格式，都会压缩成 jpg 格式再打包。

原图尺寸压缩包里的图片压缩了画质，但是图片的尺寸没有变。

普通尺寸（600x600）压缩包里的图片尺寸最大是 600x600，如果原图超过这个尺寸会被压缩到最大 600px。

## 使用的 URL

先获取 meta 数据：

https://www.pixiv.net/ajax/illust/99636469/ugoira_meta

```json
{
  "src": "https://i.pximg.net/img-zip-ugoira/img/2022/07/10/21/09/53/99636469-c939f0c867922f29d84622aa93ee80f4_ugoira600x600.zip",
  "originalSrc": "https://i.pximg.net/img-zip-ugoira/img/2022/07/10/21/09/53/99636469-c939f0c867922f29d84622aa93ee80f4_ugoira1920x1080.zip",
  "mime_type": "image/jpeg",
}
```

目前我假定压缩包里的都是 jpg 图片，没有其他格式。先检查 `mime_type`，不是 `jpeg` 的就不进行处理。

## 先显示静态预览图

## 然后分区块加载压缩包

### 获取压缩包体积

Pixiv 在加载动图时是分区块加载的，并不是一次性加载整个压缩包。这样能先加载出一部分图像，使预览能够尽早的显示出来。

首先发一个 HEAD 请求，获取 headers。

```js
async function head () {
  const r = await fetch('https://i.pximg.net/img-zip-ugoira/img/2022/06/25/22/07/04/99298109_ugoira600x600.zip', {
    method: 'head',
    credentials: 'same-origin'
  })

  for (const iterator of r.headers.entries()) {
    console.log(iterator)
  }
  
  console.log(r.headers.get('content-length'))
}

head()
```

循环之后输出了以下 headers：

```js
['cache-control', 'max-age=31536000']
['content-length', '3596438']
['content-type', 'application/zip']
['expires', 'Sat, 08 Jul 2023 04:12:13 GMT']
['last-modified', 'Sat, 25 Jun 2022 09:51:54 GMT']
```

主要是看 `content-length`，获取压缩包的总字节数。

如果体积很小，就不用分块了，直接加载整个压缩包。

### 分块加载

然后发送多个 GET 请求，使用 `range` 请求头来定义要加载的区块。

```yml
range: bytes=0-299999
```

Pixiv 官方是一次加载 `299999` 字节，不知道这个数字有没有什么特殊含义。

```js
async function load (rang) {
  const r = await fetch('https://i.pximg.net/img-zip-ugoira/img/2022/06/25/22/07/04/99298109_ugoira600x600.zip', {
    method: 'get',
    headers: {
      range: rang,
    }
  })
  const d = await r.blob()
}
load('bytes=0-299999')
```

有多个区块时，依次按顺序加载，才能保证先显示开头的图片。

## 汇总分块数据，提取出图像数据

我遇到了问题，当压缩包只加载了一部分时，它不是一个完整的压缩包，它结尾处的图片文件也是会被截断的，我现在使用的 zip 库无法解压。

我只好采用笨办法，直接操作二进制数据了。

## 当从压缩包里解压出图片后，开始绘制动画

当从压缩包里解压出图片后，在容器元素里创建画布，播放动画。

一开始只能播放开头的几张图片，等到加载出的图片越来越多，就可以逐渐完整的播放了。

